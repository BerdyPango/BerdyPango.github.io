<!DOCTYPE html>




<html class="theme-next mist" lang="default">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="asp.net core," />










<meta name="description" content="管道由一个服务器和一个 HttpApplication 构成，服务器负责监听请求并将接收到的请求传递给给 HttpApplication 对象处理，HttpApplication 则将请求处理任务委托给注册的中间件来完成。">
<meta name="keywords" content="asp.net core">
<meta property="og:type" content="article">
<meta property="og:title" content="ASP.NET Core 框架基础 - 管道和中间件">
<meta property="og:url" content="https://berdypango.github.io/Web/ASP-NET-Core/aspnetcore-fundamentals-pipelines/index.html">
<meta property="og:site_name" content="Pango.Handbook">
<meta property="og:description" content="管道由一个服务器和一个 HttpApplication 构成，服务器负责监听请求并将接收到的请求传递给给 HttpApplication 对象处理，HttpApplication 则将请求处理任务委托给注册的中间件来完成。">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://berdypango.github.io/Web/ASP-NET-Core/aspnetcore-fundamentals-pipelines/pipes_01.png">
<meta property="og:image" content="https://berdypango.github.io/Web/ASP-NET-Core/aspnetcore-fundamentals-pipelines/pipes_02.png">
<meta property="og:image" content="https://berdypango.github.io/Web/ASP-NET-Core/aspnetcore-fundamentals-pipelines/pipes_03.png">
<meta property="og:image" content="https://berdypango.github.io/Web/ASP-NET-Core/aspnetcore-fundamentals-pipelines/pipes_05.png">
<meta property="og:image" content="https://berdypango.github.io/Web/ASP-NET-Core/aspnetcore-fundamentals-pipelines/pipes_06.png">
<meta property="og:image" content="https://berdypango.github.io/Web/ASP-NET-Core/aspnetcore-fundamentals-pipelines/pipes_07.png">
<meta property="og:image" content="https://berdypango.github.io/Web/ASP-NET-Core/aspnetcore-fundamentals-pipelines/pipes_08.png">
<meta property="og:image" content="https://berdypango.github.io/Web/ASP-NET-Core/aspnetcore-fundamentals-pipelines/pipes_09.png">
<meta property="og:updated_time" content="2018-04-23T12:31:11.667Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ASP.NET Core 框架基础 - 管道和中间件">
<meta name="twitter:description" content="管道由一个服务器和一个 HttpApplication 构成，服务器负责监听请求并将接收到的请求传递给给 HttpApplication 对象处理，HttpApplication 则将请求处理任务委托给注册的中间件来完成。">
<meta name="twitter:image" content="https://berdypango.github.io/Web/ASP-NET-Core/aspnetcore-fundamentals-pipelines/pipes_01.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":false},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://berdypango.github.io/Web/ASP-NET-Core/aspnetcore-fundamentals-pipelines/"/>





  <title>ASP.NET Core 框架基础 - 管道和中间件 | Pango.Handbook</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Pango.Handbook</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="Searching..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://berdypango.github.io/Web/ASP-NET-Core/aspnetcore-fundamentals-pipelines/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Frost He">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pango.Handbook">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">ASP.NET Core 框架基础 - 管道和中间件</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-06-05T23:15:04+08:00">
                2016-06-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Web/" itemprop="url" rel="index">
                    <span itemprop="name">Web</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Web/ASP-NET-Core/" itemprop="url" rel="index">
                    <span itemprop="name">ASP.NET Core</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  5,589
                </span>
              

              

              
            </div>
          

          
              <div class="post-description">
                  管道由一个服务器和一个 HttpApplication 构成，服务器负责监听请求并将接收到的请求传递给给 HttpApplication 对象处理，HttpApplication 则将请求处理任务委托给注册的中间件来完成。
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>参考资料: </p>
<ul>
<li><a href="http://www.cnblogs.com/artech/p/rebuild-pipeline-01.html" target="_blank" rel="noopener">采用管道处理请求</a></li>
<li><a href="http://www.cnblogs.com/artech/p/rebuild-pipeline-02.html" target="_blank" rel="noopener">管道如何处理请求</a></li>
<li><a href="http://www.cnblogs.com/artech/p/rebuild-pipeline-03.html" target="_blank" rel="noopener">管道如何创建</a></li>
</ul>
<p>本文大纲:<br><!-- TOC --></p>
<ul>
<li><a href="#%E6%80%BB%E8%A7%88">总览</a></li>
<li><a href="#%E7%AE%A1%E9%81%93%E7%9A%84%E6%9E%84%E6%88%90">管道的构成</a><ul>
<li><a href="#%E5%AE%9A%E5%88%B6%E7%AE%A1%E9%81%93">定制管道</a></li>
</ul>
</li>
<li><a href="#httpapplication---%E4%B8%80%E7%BB%84%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88">HttpApplication - 一组中间件的有序集合</a><ul>
<li><a href="#hostingapplication">HostingApplication</a></li>
</ul>
</li>
<li><a href="#httpcontext---%E5%BD%93%E5%89%8D-http-%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84%E6%8A%BD%E8%B1%A1">HttpContext - 当前 HTTP 上下文的抽象</a><ul>
<li><a href="#defaulthttpcontext">DefaultHttpContext</a></li>
</ul>
</li>
<li><a href="#%E6%9C%8D%E5%8A%A1%E5%99%A8---%E5%AF%B9%E8%AF%B7%E6%B1%82%E7%9A%84%E7%9B%91%E5%90%AC%EF%BC%8C%E6%8E%A5%E6%94%B6%E5%92%8C%E5%93%8D%E5%BA%94">服务器 - 对请求的监听，接收和响应</a></li>
<li><a href="#applicationbulder---%E6%B3%A8%E5%86%8C%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%B9%B6%E5%88%9B%E5%BB%BA%E7%AE%A1%E9%81%93">ApplicationBulder - 注册中间件并创建管道</a></li>
<li><a href="#webhost-%E5%92%8C-webhostbuilder">WebHost 和 WebHostBuilder</a></li>
</ul>
<!-- /TOC -->
<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><p>HTTP 协议自身的特性决定了任何一个 Web 应用的工作方式都是监听、接收并处理 HTTP 请求，并最终对请求予以响应。HTTP 请求处理是管道式设计典型的应用场景，我们根据具体一个的 HTTP 请求构建一个管道，接收到的 HTTP 请求消息像水一样流入这个管道，组成这个管道的各个环节依次对它作相应的处理。整个请求处理完成后的结果同样转变成消息逆向流入这个管道进行处理，并最终变成回复给客户端的 HTTP 响应。</p>
<p>首先来看一个简单的 .NET Core 应用程序:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> WebHostBuilder()</span><br><span class="line">            .UseKestrel()</span><br><span class="line">            .Configure(app =&gt; app.Run(<span class="keyword">async</span> context=&gt; <span class="keyword">await</span> context.Response.WriteAsync(<span class="string">"Hello World"</span>)))            </span><br><span class="line">            .Build()</span><br><span class="line">            .Run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>WebHost</code> 对象可以看成是 Web 应用的宿主，启动 Web 应用本质上就是启动作为宿主的 <code>WebHost</code> 对象。<code>WebHostBuilder</code> 是 <code>WebHost</code> 的创建者，调用它的 <code>Build</code> 方法创建并返回相应的 <code>WebHost。</code></p>
<p><code>Configure</code> 方法注册到 <code>WebHostBuilder</code> 上的委托对象（委托类型为 <code>Action&lt;IApplicationBuilder&gt;</code>）将用于管道的定制。调用 <code>WebHost</code> 的扩展方法 <code>Run</code> 启动应用的时候，用于监听、接收、处理和响应 HTTP 请求的管道随之被建立。<br><img src="/Web/ASP-NET-Core/aspnetcore-fundamentals-pipelines/pipes_01.png" title="对象关系示意图"></p>
<h1 id="管道的构成"><a href="#管道的构成" class="headerlink" title="管道的构成"></a>管道的构成</h1><p>HTTP 请求处理流程始于对请求的监听与接收，终于对请求的响应，这两项工作均由同一个对象来完成，我们称之为 <strong>「服务器(Server)」</strong> 。尽管 ASP.NET Core 的请求处理管道可以任意定制，但是该管道必须有一个 Server，Server 是整个管道的”水龙头”。在上述的 Hello World 应用中，在 <code>Build</code> 一个 <code>WebHost</code> 之前，首先调用了扩展方法 <code>UseKestrel</code>，该方法就是为后续构建的管道注册一个名为 <code>KestrelServer</code> 的 <code>Server</code>。</p>
<p>随着调用 <code>WebHost</code> 的 <code>Start</code> 方法(调用 <code>WebHost</code> 的扩展方法 <code>Run</code> 时，它的 <code>Start</code> 方法会被自动调用)，定制的管道会被构建出来，管道的服务器将绑定到一个预设的端口(KestrelServer 默认采用 5000 作为监听端口)开始监听请求。HTTP 请求一旦抵达，Server 会将其标准化并分发给管道后续的节点。管道中位于服务器之后的节点称为<strong>「中间件(Middleware)」</strong>。每个中间件都具有各自独立的功能，例如有专门实现路由功能的中间件，有专门实施用户认证的中间件。<strong>所谓的管道定制体现在根据具体的需求选择对应的中间件组成最终处理请求的管道</strong>。下图揭示了由一个服务器和一组中间件构成的请求处理管道:<br><img src="/Web/ASP-NET-Core/aspnetcore-fundamentals-pipelines/pipes_02.png" title="管道示意图"><br>一个基于 ASP.NET Core 的应用一般都是根据某个框架开发的，而框架本身就是通过某个或多个中间件构建的。ASP.NET Core MVC 就是基于 ASP.NET Core 的开发框架为例，它实际上是借助于一个叫做<strong>「路由」</strong>的中间件实现了请求地址与 <code>Controller/Action</code> 之间的映射，并在此基础实现了激活 <code>Controller</code>，执行 <code>Action</code> 以及呈现 <code>View</code> 等一系列的功能。所以应用程序可以视为某个中间件的一部分，如果一定要将它独立出来，整个请求处理管道将呈现出如下图所示的结构:<br><img src="/Web/ASP-NET-Core/aspnetcore-fundamentals-pipelines/pipes_03.png" title="应用程序位于框架中的位置"></p>
<h2 id="定制管道"><a href="#定制管道" class="headerlink" title="定制管道"></a>定制管道</h2><p>在上述的 Hello World 程序中，调用扩展方法 <code>UseKestrel</code> 注册 KestrelServer 服务器之后，还调用 <code>WebHostBuilder</code> 的 <code>Configure</code> 的扩展方法注册了一个类型为 <code>Action&lt;IApplicationBuilder&gt;</code> 的委托对象。注册这个委托对象的目的在于对构建的管道进行定制，即为管道注册中间件。这个委托对象调用 <code>ApplicationBuilder</code> 的扩展方法 <code>Run</code> 注册了一个中间件来为每个请求响应一个 “Hello World” 字符串。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IWebHostBuilder <span class="title">Configure</span>(<span class="params"><span class="keyword">this</span> IWebHostBuilder hostBuilder, Action&lt;IApplicationBuilder&gt; configureApp</span>) </span></span><br></pre></td></tr></table></figure><br>除了调用 <code>WebHostBuilder</code> 的 <code>Configure</code> 方法来注册一个 <code>Action&lt;IApplicationBuilder&gt;</code> 类型的委托，注册中间件定义管道的逻辑更多地还是定义在一个单独的类型中。由于管道的定制总是在应用启动(Startup)的时候进行，一般称这个用于定制管道的类型为<strong>「启动类型」</strong>，并在大部分情况下会直接命名为 Startup。<strong>按照约定，通过注册中间件定制管道的操作会实现在名为 <code>Configure</code> 的方法中，方法的第一个参数类型必须是 <code>IApplicationBuilder</code> 接口</strong>，后面可定义任意数量和类型的参数，当这个方法被 ASP.NET Core 框架调用的时候，这些参数会采用依赖注入的方式来提供。启动类型可以通过调用 <code>WebHostBuilder</code> 的扩展方法 <code>UseStartup&lt;T&gt;</code> 进行注册，如下面的代码与前面演示的示例是完全等效的。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Startup</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">IApplicationBuilder app</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        app.Run(<span class="keyword">async</span> context =&gt; <span class="keyword">await</span> context.Response.WriteAsync(<span class="string">"Hello World"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> WebHostBuilder()</span><br><span class="line">            .UseKestrel()</span><br><span class="line">            .UseStartup()         </span><br><span class="line">            .Build()</span><br><span class="line">            .Run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在真正的项目开发中，我们会利用 <code>ApplicationBuilder</code> 注册相应的中间件进而构建一个适合当前需求的请求处理管道。如下面的代码片段所示，我们除了按照如上的方式调用扩展方法 UseMvc 注册了支撑 MVC 框架的中间件(实际上是一个实现路由的中间件)之外，我们还调用了其它的扩展方法注册了相应的中间件实现了对静态文件的访问(<code>UseStaticFiles</code>)，错误页面的呈现(<code>UseExceptionHandler</code>)以及基于 ASP.NET Identity Framework 的认证(<code>UseIdentity</code>):<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Startup</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">IApplicationBuilder app</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        app.UseExceptionHandler(<span class="string">"/Home/Error"</span>);</span><br><span class="line">        app.UseStaticFiles();</span><br><span class="line">        app.UseIdentity();           </span><br><span class="line"> </span><br><span class="line">        app.UseMvc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="HttpApplication-一组中间件的有序集合"><a href="#HttpApplication-一组中间件的有序集合" class="headerlink" title="HttpApplication - 一组中间件的有序集合"></a>HttpApplication - 一组中间件的有序集合</h1><p>ASP.NET Core 请求处理管道由一个服务器和一组有序排列的中间件组合而成。在这个基础上作进一步抽象，将后者抽象成一个 <code>HttpApplication</code> 对象，该管道就成了一个 Server 和 <code>HttpApplication</code> 的综合体。Server 将接收到的 HTTP 请求转发给 <code>HttpApplication</code> 对象，后者会针对当前请求创建一个上下文，并在此上下文中处理请求，请求处理完成并完成响应之后 <code>HttpApplication</code> 会对此上下文实施回收释放处理。<br><br><code>IHttpApplication&lt;TContext&gt;</code> 类型表示上述的 <code>HttpApplication</code>，泛型参数 <code>TContext</code> 代表它针对每个请求创建的上下文。一个 <code>HttpApplication</code> 对象在接收到 Server 转发的请求之后完成三项基本的操作，即<strong>「创建上下文」</strong>，<strong>「在上下文中处理请求」</strong>以及<strong>「请求处理完成之后释放上下文」</strong>，这些操作通过三个方法来完成。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface IHttpApplication&lt;TContext&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">TContext <span class="title">CreateContext</span>(<span class="params">IFeatureCollection contextFeatures</span>)</span>; </span><br><span class="line">    <span class="function">Task <span class="title">ProcessRequestAsync</span>(<span class="params">TContext context</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DisposeContext</span>(<span class="params">TContext context, Exception exception</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>CreateContext</code> 方法接收一个类型为 <code>IFeatureCollection</code> 接口的参数，该接口用于描述某个对象所具有的一组特性，我们可以将它视为一个 <code>Dictionary&lt;Type, object&gt;</code> 对象，字典的 Value 代表特性对象，Key 则表示该对象的注册类型(特性描述对象的具体类型，具体类型的基类或者接口)。调用 <code>Set</code> 方法来注册特性对象，而 <code>Get</code> 方法则根据指定的注册类型得到对应的特性对象。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface IFeatureCollection : IEnumerable&lt;KeyValuePair&lt;Type, object&gt;&gt;, IEnumerable</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">object</span> <span class="keyword">this</span>[Type key] &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">bool</span> IsReadOnly &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">int</span> Revision &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    TFeature Get&lt;TFeature&gt;();</span><br><span class="line">    <span class="keyword">void</span> Set&lt;TFeature&gt;(TFeature instance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="HostingApplication"><a href="#HostingApplication" class="headerlink" title="HostingApplication"></a>HostingApplication</h2><p>在 ASP.NET Core 中，<code>HostingApplication</code> 类型是 <code>IHttpApplication&lt;Context&gt;</code> 默认实现类:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class HostingApplication : IHttpApplication&lt;HostingApplication.Context&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HostingApplication</span>(<span class="params">RequestDelegate application, ILogger logger, DiagnosticSource diagnosticSource, IHttpContextFactory httpContextFactory</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Context <span class="title">CreateContext</span>(<span class="params">IFeatureCollection contextFeatures</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DisposeContext</span>(<span class="params">Context context, Exception exception</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Task <span class="title">ProcessRequestAsync</span>(<span class="params">Context context</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">struct</span> Context</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> HttpContext HttpContext &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> IDisposable Scope &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">long</span> StartTimestamp &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>泛型参数 <code>Context</code> 是一个针对当前请求的上下文对象。<code>Context</code> 是对一个 <code>HttpContext</code> 的封装，后者是真正描述当前 HTTP 请求的上下文，承载着核心的上下文信息。除此之外，<code>Context</code> 还定义了 <code>Scope</code> 和 <code>StartTimestamp</code> 两个属性，两者与日志记录和事件追踪有关，前者用来将针对同一请求的多次日志记录关联到同一个上下文区限(见<a href="/Web/ASP-NET-Core/aspnetcore-fundamentals-logging/#日志类别Category">日志区限</a>；后者表示请求开始处理的时间戳，如果在完成请求处理的时候记录下当时的时间戳，就可以计算出整个请求处理所花费的时间。</p>
<p>以上涉及的类型和接口和所在的命名空间：</p>
<table>
<thead>
<tr>
<th>类型或接口</th>
<th>命名空间</th>
</tr>
</thead>
<tbody>
<tr>
<td>IHttpApplication<tcontext></tcontext></td>
<td>Microsoft.AspNetCore.Hosting.Server</td>
</tr>
<tr>
<td>HostingApplication</td>
<td>Microsoft.AspNetCore.Hosting.Internal</td>
</tr>
<tr>
<td>Context</td>
<td>Microsoft.AspNetCore.Hosting.Internal</td>
</tr>
<tr>
<td>HttpContext</td>
<td>Microsoft.AspNetCore.Http</td>
</tr>
<tr>
<td>IFeatureCollection</td>
<td>Microsoft.AspNetCore.Http.Features</td>
</tr>
<tr>
<td>FeatureCollection</td>
<td>Microsoft.AspNetCore.Http.Features</td>
</tr>
</tbody>
</table>
<p>以及它们之间的 UML 关系图:<br><img src="/Web/ASP-NET-Core/aspnetcore-fundamentals-pipelines/pipes_05.png" title="对象关系图"></p>
<h1 id="HttpContext-当前-HTTP-上下文的抽象"><a href="#HttpContext-当前-HTTP-上下文的抽象" class="headerlink" title="HttpContext - 当前 HTTP 上下文的抽象"></a>HttpContext - 当前 HTTP 上下文的抽象</h1><p>用来描述当前 HTTP 请求上下文的 <code>HttpContext</code> 在 ASP.NET Core 请求处理管道中是一个非常重要的对象，我们不仅仅可以利用它获取当前请求的所有细节，还可以直接利用它完成对请求的响应。<code>HttpContext</code> 是一个抽象类，很多用于描述当前 HTTP 请求的上下文信息的属性被定义在这个类型中:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">HttpContext</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> IFeatureCollection Features &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> HttpRequest Request &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> HttpResponse Response &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> ConnectionInfo Connection &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> WebSocketManager WebSockets &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> AuthenticationManager Authentication &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> ClaimsPrincipal User &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> IDictionary&lt;<span class="keyword">object</span>, <span class="keyword">object</span>&gt; Items &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> IServiceProvider RequestServices &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> CancellationToken RequestAborted &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">string</span> TraceIdentifier &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> ISession Session &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Abort</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>表示请求和响应的 <code>HttpRequest</code> 和 <code>HttpResponse</code> 同样是抽象类:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">HttpRequest</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Uri    Url &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">string</span> PathBase &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    ... 其他成员</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">HttpResponse</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Stream     OutputStream &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">string</span>     ContentType &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span>        StatusCode &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    ... 其他成员</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="DefaultHttpContext"><a href="#DefaultHttpContext" class="headerlink" title="DefaultHttpContext"></a>DefaultHttpContext</h2><p>对于管道来说，<strong>请求的接收者和最终响应者都是服务器，服务器接收到请求之后会创建与之对应的「原始上下文」，请求的响应也通过这个「原始上下文」来完成。</strong></p>
<p>但对于建立在管道上的应用程序来说，它们不需要关注管道究竟采用了何种类型的服务器，更不会关注由这个服务器创建的<strong>「原始上下文」</strong>。ASP.NET Core 默认使用 <code>DefaultHttpContext</code> 类型来描述请求上下文，应用程序统一采用 <code>DefaultHttpContext</code> 对象来获取请求信息，同时还利用它来完成对请求的响应。<code>DefaultHttpContext</code> 对象与服务器创建的<strong>「原始上下文」</strong>通过 <code>FeatureCollection</code> 对象来实现关联。<br><img src="/Web/ASP-NET-Core/aspnetcore-fundamentals-pipelines/pipes_06.png" title="原始上下文与 DefaultHttpContext 的关系"><br>不同类型的服务器在接收到请求时会创建一个<strong>「原始上下文」</strong>，接下来服务器将<strong>「原始上下文」</strong>的操作封装成一系列标准的特性对象(<code>IFeature</code>)，进而封装成一个 <code>FeatureCollection</code> 对象，应用程序中使用的 <code>DefaultHttpContext</code> 就是根据它创建的，当调用 <code>DefaultHttpContext</code> 相应的属性和方法时，其内部则借助封装的特性对象去操作<strong>「原始上下文」</strong>。</p>
<p>现在，来看看 <code>DefaultHttpContext</code> 类型的定义:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DefaultHttpContext</span> : <span class="title">HttpContext</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">public</span> IFeatureCollection HttpContextFeatures &#123; <span class="keyword">get</span>;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultHttpContext</span>(<span class="params">IFeatureCollection httpContextFeatures</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.HttpContextFeatures = httpContextFeatures;</span><br><span class="line">        <span class="keyword">this</span>.Request      = <span class="keyword">new</span> DefaultHttpRequest(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">this</span>.Response     = <span class="keyword">new</span> DefaultHttpResponse(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> HttpRequest      Request &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> HttpResponse     Response &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>DefaultHttpContext</code> 引用一个 <code>IFeatureCollection</code> 类型的属性 <code>HttpContextFeatures</code>，它表示由服务器创建的用于封装原始 HTTP 上下文相关特性的 <code>FeatureCollection</code> 对象。由其构造函数的定义我们看到在一个 <code>DefaultHttpContext</code> 对象中，表示请求和响应的分别是 <code>DefaultHttpRequest</code> 和 <code>DefaultHttpResponse</code> 对象。</p>
<p>由不同类型的服务器创建的特性对象之所以能够统一被 <code>DefaultHttpContext</code> 所用，原因在于它们的类型都实现了统一的接口 <code>IHttpRequestFeature</code> 和 <code>IHttpResponseFeature</code>，它们与 <code>HttpRequest</code> 和 <code>HttpResponse</code> 由相似的成员定义:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IHttpRequestFeature</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Uri    Url &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">string</span> PathBase &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    ... 其他成员</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IHttpResponseFeature</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Stream     OutputStream &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">string</span>     ContentType &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span>        StatusCode &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    ... 其他成员</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>DefaultHttpContext</code> 对象中表示请求和响应的 <code>DefaultHttpRequest</code> 和 <code>DefaultHttpResponse</code> 对象就是分别提取 <code>FeatureCollection</code> 中的 <code>HttpRequestFeature</code> 和 <code>HttpResponseFeature</code> 对象来初始化的，具体的实现体现在如下所示的代码片断中:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DefaultHttpRequest</span> : <span class="title">HttpRequest</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> IHttpRequestFeature RequestFeature &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultHttpRequest</span>(<span class="params">DefaultHttpContext context</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.RequestFeature = context.HttpContextFeatures.Get&lt;IHttpRequestFeature&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> Uri Url</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> <span class="keyword">this</span>.RequestFeature.Url; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">string</span> PathBase</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> <span class="keyword">this</span>.RequestFeature.PathBase; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DefaultHttpResponse</span> : <span class="title">HttpResponse</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> IHttpResponseFeature ResponseFeature &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> Stream OutputStream</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> <span class="keyword">this</span>.ResponseFeature.OutputStream; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">string</span> ContentType</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> <span class="keyword">this</span>.ResponseFeature.ContentType; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; <span class="keyword">this</span>.ResponseFeature.ContentType = <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">int</span> StatusCode</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> <span class="keyword">this</span>.ResponseFeature.StatusCode; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; <span class="keyword">this</span>.ResponseFeature.StatusCode = <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultHttpResponse</span>(<span class="params">DefaultHttpContext context</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ResponseFeature = context.HttpContextFeatures.Get&lt;IHttpResponseFeature&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基于以上对 <code>DefaultHttpContext</code> 实现原理的理解，我们再来看看 <code>HostingApplication</code> 的定义:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class HostingApplication : IHttpApplication&lt;Context&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> RequestDelegate Application &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HostingApplication</span>(<span class="params">RequestDelegate application</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.Application = application;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Context <span class="title">CreateContext</span>(<span class="params">IFeatureCollection contextFeatures</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        HttpContext httpContext = <span class="keyword">new</span> DefaultHttpContext(contextFeatures);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Context</span><br><span class="line">        &#123;</span><br><span class="line">            HttpContext     = httpContext,</span><br><span class="line">            StartTimestamp  = Stopwatch.GetTimestamp()</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DisposeContext</span>(<span class="params">Context context, Exception exception</span>) </span>=&gt; context.Scope?.Dispose();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Task <span class="title">ProcessRequestAsync</span>(<span class="params">Context context</span>) </span>=&gt; <span class="keyword">this</span>.Application(context.HttpContext);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> Task <span class="title">RequestDelegate</span>(<span class="params">HttpContext context</span>)</span>;</span><br></pre></td></tr></table></figure><br>由于一个 <code>HttpApplication</code> 是一组中间件的封装，它对请求的处理工作最终会交给这些中间件来完成，当创建 <code>HostingApplication</code> 对象时，所有注册的中间件被转换成一个 <code>RequestDelegate</code> 类型的委托对象，并将其作为参数传入构造函数，<code>ProcessRequestAsync</code> 方法会直接利用这个委托对象来处理请求。CreateContext 会直接利用封装原始 HTTP 上下文的 <code>FeatureCollection</code> 对象创建 <code>DefaultHttpContext</code> 对象，再将其传递给 <code>Context</code> 对象。</p>
<p>以上涉及的类型和接口和所在的命名空间：</p>
<table>
<thead>
<tr>
<th>类型或接口</th>
<th>命名空间</th>
</tr>
</thead>
<tbody>
<tr>
<td>HttpContext</td>
<td>Microsoft.AspNetCore.Http</td>
</tr>
<tr>
<td>HttpRequest</td>
<td>Microsoft.AspNetCore.Http</td>
</tr>
<tr>
<td>HttpResponse</td>
<td>Microsoft.AspNetCore.Http</td>
</tr>
<tr>
<td>DefaultHttpRequest</td>
<td>Microsoft.AspNetCore.Http.Internal</td>
</tr>
<tr>
<td>DefaultHttpResponse</td>
<td>Microsoft.AspNetCore.Http.Internal</td>
</tr>
<tr>
<td>IHttpRequestFeature</td>
<td>Microsoft.AspNetCore.Http.Features</td>
</tr>
<tr>
<td>IHttpResponseFeature</td>
<td>Microsoft.AspNetCore.Http.Features</td>
</tr>
</tbody>
</table>
<p>以及它们之间的 UML 关系图:<br><img src="/Web/ASP-NET-Core/aspnetcore-fundamentals-pipelines/pipes_07.png" title="对象关系图"></p>
<h1 id="服务器-对请求的监听，接收和响应"><a href="#服务器-对请求的监听，接收和响应" class="headerlink" title="服务器 - 对请求的监听，接收和响应"></a>服务器 - 对请求的监听，接收和响应</h1><p>管道中的服务器通过 IServer 接口表示:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IServer</span></span><br><span class="line">&#123;</span><br><span class="line">    IFeatureCollection Features &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">void</span> Start&lt;TContext&gt;(IHttpApplication&lt;TContext&gt; application);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>简单起见，只保留了两个核心成员，其中 <code>Features</code> 属性返回描述服务器的特性，而 <code>Start</code> 方法则负责启动服务器。</p>
<p><code>Start</code> 方法一旦执行，服务会马上开始监听工作。任何 HTTP 请求抵达，该方法会利用作为参数的<code>HttpApplication</code> 对象创建一个上下文，并在此上下文中完成对请求的所有处理操作。当完成了对请求的处理任务之后，<code>HttpApplication</code> 对象会自行负责回收释放由它创建的上下文。</p>
<p>监听地址的获取是通过一个由 <code>IServerAddressesFeature</code> 接口表示的特性来提供的。如下面的代码片段所示，这个特性接口通过一个字符串集合类型的 Addresses 属性表示监听地址列，<code>ServerAddressesFeature</code> 是这个特性接口的默认实现类型。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IServerAddressesFeature</span></span><br><span class="line">&#123;</span><br><span class="line">    ICollection&lt;<span class="keyword">string</span>&gt; Addresses &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ServerAddressesFeature</span> : <span class="title">IServerAddressesFeature</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> ICollection&lt;<span class="keyword">string</span>&gt; Addresses &#123; <span class="keyword">get</span>; &#125; = <span class="keyword">new</span> Collection&lt;<span class="keyword">string</span>&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在 <code>IServer</code> 初始化时，构造了一个 <code>FeatureCollection</code> 对象，并对其添加一个 <code>ServerAddressFeature</code>，通过自定义类型 <code>HttpListenerServer</code> 实现 <code>IServer</code> 对象:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HttpListenerServer</span> : <span class="title">IServer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> HttpListener         Listener &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> IFeatureCollection     Features &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HttpListenerServer</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.Listener = <span class="keyword">new</span> HttpListener();</span><br><span class="line">        <span class="keyword">this</span>.Features = <span class="keyword">new</span> FeatureCollection()</span><br><span class="line">            .Set&lt;IServerAddressesFeature&gt;(<span class="keyword">new</span> ServerAddressesFeature());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> Start&lt;TContext&gt;(IHttpApplication&lt;TContext&gt; application)</span><br><span class="line">    &#123;</span><br><span class="line">        IServerAddressesFeature addressFeatures = <span class="keyword">this</span>.Features.Get&lt;IServerAddressesFeature&gt;();</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">string</span> address <span class="keyword">in</span> addressFeatures.Addresses)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.Listener.Prefixes.Add(address.TrimEnd(<span class="string">'/'</span>) + <span class="string">"/"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">this</span>.Listener.Start();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            HttpListenerContext httpListenerContext = <span class="keyword">this</span>.Listener.GetContext();</span><br><span class="line"> </span><br><span class="line">            HttpListenerContextFeature feature = <span class="keyword">new</span> HttpListenerContextFeature(httpListenerContext, <span class="keyword">this</span>.Listener);</span><br><span class="line">            IFeatureCollection contextFeatures = <span class="keyword">new</span> FeatureCollection()</span><br><span class="line">                .Set&lt;IHttpRequestFeature&gt;(feature)</span><br><span class="line">                .Set&lt;IHttpResponseFeature&gt;(feature);</span><br><span class="line">            TContext context = application.CreateContext(contextFeatures);</span><br><span class="line"> </span><br><span class="line">            application.ProcessRequestAsync(context)</span><br><span class="line">                .ContinueWith(_ =&gt; httpListenerContext.Response.Close())</span><br><span class="line">                .ContinueWith(_ =&gt; application.DisposeContext(context, _.Exception));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在 <code>Start</code> 方法中，从特性集合提取这个 <code>ServerAddressFeature</code> 对象，并将其地址设置到服务器的侦听列表中。HTTP 请求一旦抵达，首先调用 <code>HttpListener</code> 的 <code>GetContext</code> 方法得到表示原始 HTTP 上下文的 <code>HttpListenerContext</code> 对象，并根据它创建一个类型为 <code>HttpListenerContextFeature</code> 的特性对象，该对象分别实现 <code>IHttpRequestFeature</code> 和 <code>IHttpResponseFeature</code> 接口并将其自身注册到创建的 <code>FeatureCollection</code> 对象上。<code>HttpApplication</code> 对象使用 <code>FeatureCollection</code> 参数调用 <code>CreateContext</code> 方法并返回类型为 TContext 的上下文对象，最终，TContext 作为参数调用 <code>HttpApplication</code> 对象的 <code>ProcessRequestAsync</code> 方法让注册的中间件来处理当前请求。</p>
<p>当所有的请求处理工作结束之后，调用 <code>HttpApplication</code> 对象的 <code>DisposeContext</code> 方法回收释放这个上下文。</p>
<p><code>HttpListenerServer</code> 采用一个 <code>HttpListener</code> 对象作为监听器，由它接收的请求将被封装成一个类型为 <code>HttpListenerContext</code> 的上下文对象。我们通过一个 <code>HttpListenerContextFeature</code> 类型来封装这个 <code>HttpListenerContext</code> 对象，如下所示:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class HttpListenerContextFeature : IHttpRequestFeature, IHttpResponseFeature</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> HttpListenerContext context;    </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> ContentType</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> context.Response.ContentType; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; context.Response.ContentType = <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> Stream OutputStream &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> StatusCode</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> context.Response.StatusCode; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; context.Response.StatusCode = <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> Uri Url &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> PathBase &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HttpListenerContextFeature</span>(<span class="params">HttpListenerContext context, HttpListener listener</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.context = context;</span><br><span class="line">        <span class="keyword">this</span>.Url = context.Request.Url;</span><br><span class="line">        <span class="keyword">this</span>.OutputStream = context.Response.OutputStream;</span><br><span class="line">        <span class="keyword">this</span>.PathBase = (<span class="keyword">from</span> it <span class="keyword">in</span> listener.Prefixes</span><br><span class="line">          <span class="keyword">let</span> pathBase = <span class="keyword">new</span> Uri(it).LocalPath.TrimEnd(<span class="string">'/'</span>)</span><br><span class="line">          <span class="keyword">where</span> context.Request.Url.LocalPath.StartsWith(pathBase, StringComparison.OrdinalIgnoreCase)</span><br><span class="line">          <span class="keyword">select</span> pathBase).First();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>下图所示的 UML 体现了与服务器相关的接口/类型之间的关系。通过接口 IServer 表示的服务器在管道中完成请求监听，接收与响应的组件，自定义的 <code>HttpListenerServer</code> 利用一个 <code>HttpListener</code> 实现了三项基本操作。当 <code>HttpListenerServer</code> 接收到抵达的 HTTP 请求之后，它会将表示原始 HTTP 上下文的特性封装成一个 <code>HttpListenerContextFeature</code> 对象，<code>HttpListenerContextFeature</code> 分别实现了用于描述请求和响应特性的 <code>IHttpRequestFeature</code> 和 <code>IHttpResponseFeature</code> 接口，<code>HostingApplication</code> 利用这个 <code>HttpListenerContextFeature</code> 对象来创建 <code>DefaultHttpContext</code> 对象。<br><img src="/Web/ASP-NET-Core/aspnetcore-fundamentals-pipelines/pipes_08.png" title="对象关系图"></p>
<h1 id="ApplicationBulder-注册中间件并创建管道"><a href="#ApplicationBulder-注册中间件并创建管道" class="headerlink" title="ApplicationBulder - 注册中间件并创建管道"></a>ApplicationBulder - 注册中间件并创建管道</h1><p>创建 <code>WebHost</code> 的 <code>WebHostBuilder</code> 提供了一个用于管道定制的 <code>Configure</code> 方法，它利用 <code>ApplicationBuilder</code> 参数进行中间件的注册。中间件在请求处理流程中体现为一个类型为 <code>Func&lt;RequestDelegate，RequestDelegate&gt;</code> 的委托对象，<code>RequestDelegate</code> 相当于一个 <code>Func&lt;HttpContext, Task&gt;</code> 对象，它体现了针对 <code>HttpContext</code> 所进行的某项操作，进而代表某个中间件针对请求的处理。那为何我们不直接用一个 RequestDelegate 对象来表示一个中间件，而将它表示成一个 <code>Func&lt;RequestDelegate，RequestDelegate&gt;</code> 对象呢？</p>
<p>在多数情况下，具体的请求处理需要注册多个不同的中间件，这些中间件按照注册时间的顺序进行排列构成了管道。对于单个中间件来说，在它完成了自身的请求处理任务之后，需要将请求传递给下一个中间件作后续的处理。<code>Func&lt;RequestDelegate，RequestDelegate&gt;</code> 中作为输入参数的 <code>RequestDelegate</code> 对象代表一个委托链，体现了后续中间件对请求的处理。当某个中间件将自身实现的请求处理任务添加到这个委托链中，新的委托链将作为这个 <code>Func&lt;RequestDelegate，RequestDelegate&gt;</code> 对象的返回值。<br><img src="/Web/ASP-NET-Core/aspnetcore-fundamentals-pipelines/pipes_09.png" title="中间件的委托链"><br>以上图为例，如果用一个 <code>Func&lt;RequestDelegate，RequestDelegate&gt;</code> 来表示中间件 B，那么作为输入参数的 <code>RequestDelegate</code> 对象代表的是中间件 C 对请求的处理操作，而返回值则代表 B 和 C 先后对请求的处理操作。如果一个 <code>Func&lt;RequestDelegate，RequestDelegate&gt;</code> 代表第一个从服务器接收请求的中间件(比如 A)，那么执行该委托对象返回的 <code>RequestDelegate</code> 实际上体现了整个管道对请求的处理。</p>
<p>现在，来看看 <code>IApplicationBuilder</code> 接口的定义:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IApplicationBuilder</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">RequestDelegate <span class="title">Build</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function">IApplicationBuilder <span class="title">Use</span>(<span class="params">Func&lt;RequestDelegate, RequestDelegate&gt; middleware</span>)</span>;</span><br><span class="line">    ... 其他成员</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>Use</code> 方法实现对中间件的注册，而 <code>Build</code> 方法则将所有注册的中间件转换成一个 <code>RequestDelegate</code> 对象。</p>
<p>从编程便利性考虑，很多预定义的中间件类型都具有对应的用来注册的扩展方法，比如 <code>UseStaticFiles</code> 注册处理静态文件请求的中间件。</p>
<p><code>ApplicationBuilder</code> 类型作为 <code>IApplicationBuilder</code> 的默认实现者，如下所示，一个 <code>List&lt;Func&lt;RequestDelegate, RequestDelegate&gt;&gt;</code> 来存放所有注册的中间件，在 <code>Build</code> 方法中，调用 <code>Aggregate</code> 方法将它转换成一个 <code>RequestDelegate</code> 对象。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ApplicationBuilder</span> : <span class="title">IApplicationBuilder</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> IList&lt;Func&lt;RequestDelegate, RequestDelegate&gt;&gt; middlewares = <span class="keyword">new</span> List&lt;Func&lt;RequestDelegate, RequestDelegate&gt;&gt;();  </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> RequestDelegate <span class="title">Build</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        RequestDelegate seed = context =&gt; Task.Run(() =&gt; &#123;&#125;);</span><br><span class="line">        <span class="keyword">return</span> middlewares.Reverse().Aggregate(seed, (next, current) =&gt; current(next));</span><br><span class="line">    &#125;    </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> IApplicationBuilder <span class="title">Use</span>(<span class="params">Func&lt;RequestDelegate, RequestDelegate&gt; middleware</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        middlewares.Add(middleware);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="WebHost-和-WebHostBuilder"><a href="#WebHost-和-WebHostBuilder" class="headerlink" title="WebHost 和 WebHostBuilder"></a>WebHost 和 WebHostBuilder</h1><p>ASP.NET Core 管道是由作为应用程序宿主的 <code>WebHost</code> 对象创建出来的。我们总是利用一个 <code>WebHostBuilder</code> 对象来创建 <code>WebHost</code>，Build 方法实现创建 <code>WebHost</code>。<code>WebHost</code> 在 <code>Start</code> 的时候将整个管道构建出来，管道创建过程中所需的所有信息都来源于作为创建者的 <code>WebHostBuilder</code>，它采用<strong>「依赖注入」</strong>的形式来为 <code>WebHost</code> 提供这些信息。换句话说，我们将 <code>WebHost</code> 在管道构建过程中所需的对象以服务的形式注册到 <code>WebHostBuilder</code> 上。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IWebHostBuilder</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">IWebHost <span class="title">Build</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function">IWebHostBuilder <span class="title">ConfigureServices</span>(<span class="params">Action&lt;IServiceCollection&gt; configureServices</span>)</span>;</span><br><span class="line">    <span class="function">IWebHostBuilder <span class="title">UseSetting</span>(<span class="params"><span class="keyword">string</span> key, <span class="keyword">string</span> <span class="keyword">value</span></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>当调用 <code>Build</code> 方法创建对应 <code>WebHost</code> 的时候，<code>WebHostBuilder</code> 会根据注册的这些服务创建一个 <code>ServiceProvider</code> 对象并提供给 <code>WebHost</code>，后者利用这个 <code>ServiceProvider</code> 得到它所需要的服务对象。<code>IWebHostBuilder</code> 接口通过 <code>ConfigureServices</code> 方法完成服务的注册。除了向创建的 <code>WebHost</code> 提供一个 <code>ServiceProvider</code> 之外，<code>WebHostBuilder</code> 还可以将一些额外的配置提供给 <code>WebHost</code>，配置数据通过 <code>UseSetting</code> 方法设置。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/asp-net-core/" rel="tag"># asp.net core</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/Web/ASP-NET-Core/aspnetcore-fundamentals-logging/" rel="next" title="ASP.NET Core 框架基础 - 日志系统">
                <i class="fa fa-chevron-left"></i> ASP.NET Core 框架基础 - 日志系统
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/Web/ASP-NET-Core/aspnetcore-application-localization/" rel="prev" title="ASP.NET Core 应用 - 国际化与本土化">
                ASP.NET Core 应用 - 国际化与本土化 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Frost He</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">25</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2015 &mdash; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Frost He</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>








        




  <script type="text/javascript">
    (function() {
      var hm = document.createElement("script");
      hm.src = "//tajs.qq.com/stats?sId=65458438";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === '') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
