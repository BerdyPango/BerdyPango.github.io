<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="K2S73UudyU-JTh9S0U_KnOKgOvE7aW7EpO560okLyUU">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://blog.frosthe.net').hostname,
    root: '/',
    scheme: 'Mist',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left","display":"remove","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: 'BT5SWZNUIG',
      apiKey: '7aa3fedb7b30411323b0cc8d7f90e05c',
      indexName: 'FrostHe.Handbook',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="值对象用于度量和描述事物，即便一个领域概念必须建模成实体，在设计时也应该更偏向于将其作为值对象的容器，而不是子实体的容器">
<meta name="keywords" content="ddd">
<meta property="og:type" content="article">
<meta property="og:title" content="《实现领域驱动设计》读书笔记(5) - 战术建模之值对象">
<meta property="og:url" content="https://blog.frosthe.net/ddd-tactical-value-object/index.html">
<meta property="og:site_name" content="FrostHe.Handbook">
<meta property="og:description" content="值对象用于度量和描述事物，即便一个领域概念必须建模成实体，在设计时也应该更偏向于将其作为值对象的容器，而不是子实体的容器">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2018-11-20T12:38:24.994Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="《实现领域驱动设计》读书笔记(5) - 战术建模之值对象">
<meta name="twitter:description" content="值对象用于度量和描述事物，即便一个领域概念必须建模成实体，在设计时也应该更偏向于将其作为值对象的容器，而不是子实体的容器">

<link rel="canonical" href="https://blog.frosthe.net/ddd-tactical-value-object/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>《实现领域驱动设计》读书笔记(5) - 战术建模之值对象 | FrostHe.Handbook</title>
  
    <script>
      function sendPageView() {
        if (CONFIG.hostname !== location.hostname) return;
        var uid = localStorage.getItem('uid') || (Math.random() + '.' + Math.random());
        localStorage.setItem('uid', uid);
        navigator.sendBeacon('https://www.google-analytics.com/collect', new URLSearchParams({
          v  : 1,
          tid: 'UA-125853342-1',
          cid: uid,
          t  : 'pageview',
          dp : encodeURIComponent(location.pathname)
        }));
      }
      document.addEventListener('pjax:complete', sendPageView);
      sendPageView();
    </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <h1 class="site-title">FrostHe.Handbook</h1>
            <p class="site-subtitle">Talk less, do more</p>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-film"></i>时间线</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="sidebar-profile-container">
          <div class="sidebar-profile">
<div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Frost He"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Frost He</p>
  <div class="site-description" itemprop="description">
    <i class="fa fa-fw fa-map-marker"></i>
    <span>Chengdu, China</span>
  </div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">68</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">63</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/BerdyPango" title="GitHub → https://github.com/BerdyPango" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.linkedin.com/in/frosthe0419/" title="Linkedin → https://www.linkedin.com/in/frosthe0419/" rel="noopener" target="_blank"><i class="fa fa-fw fa-linkedin"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://steamcommunity.com/profiles/76561198049061021/" title="Steam → https://steamcommunity.com/profiles/76561198049061021/" rel="noopener" target="_blank"><i class="fa fa-fw fa-steam-square"></i></a>
      </span>
  </div>
</div>
        </div>
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.frosthe.net/ddd-tactical-value-object/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Frost He">
      <meta itemprop="description" content="Chengdu, China">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FrostHe.Handbook">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          《实现领域驱动设计》读书笔记(5) - 战术建模之值对象
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-03-06 22:16:22" itemprop="dateCreated datePublished" datetime="2017-03-06T22:16:22+08:00">2017-03-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-11-20 20:38:24" itemprop="dateModified" datetime="2018-11-20T20:38:24+08:00">2018-11-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Domain-Driven-Design/" itemprop="url" rel="index">
                    <span itemprop="name">Domain-Driven Design</span>
                  </a>
                </span>
            </span>

          
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6k</span>
            </span>
            <div class="post-description">值对象用于度量和描述事物，即便一个领域概念必须建模成实体，在设计时也应该更偏向于将其作为值对象的容器，而不是子实体的容器</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>系列大纲: <a href="/tags/ddd/">《实现领域驱动设计》读书笔记</a></p>
<p>本文大纲: </p>
<ul>
<li><a href="#%E4%B8%8D%E5%8F%98%E6%80%A7">不变性</a></li>
<li><a href="#%E6%A6%82%E5%BF%B5%E6%95%B4%E4%BD%93">概念整体</a></li>
<li><a href="#%E5%8F%AF%E6%9B%BF%E6%8D%A2%E6%80%A7">可替换性</a></li>
<li><a href="#%E5%80%BC%E5%AF%B9%E8%B1%A1%E7%9B%B8%E7%AD%89%E6%80%A7">值对象相等性</a></li>
<li><a href="#%E6%97%A0%E5%89%AF%E4%BD%9C%E7%94%A8%E8%A1%8C%E4%B8%BA">无副作用行为</a></li>
<li><a href="#%E6%9C%80%E5%B0%8F%E5%8C%96%E9%9B%86%E6%88%90">最小化集成</a></li>
<li><a href="#%E7%94%A8%E5%80%BC%E5%AF%B9%E8%B1%A1%E8%A1%A8%E7%A4%BA%E6%A0%87%E5%87%86%E7%B1%BB%E5%9E%8B">用值对象表示标准类型</a></li>
<li><a href="#%E5%AE%9E%E7%8E%B0">实现</a></li>
<li><a href="#%E6%8C%81%E4%B9%85%E5%8C%96%E5%80%BC%E5%AF%B9%E8%B1%A1">持久化值对象</a><ul>
<li><a href="#%E5%8D%95%E4%B8%AA%E5%80%BC%E5%AF%B9%E8%B1%A1">单个值对象</a></li>
<li><a href="#%E5%80%BC%E5%AF%B9%E8%B1%A1%E9%9B%86%E5%90%88%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%B0%E5%8D%95%E4%B8%AA%E5%88%97%E4%B8%AD">值对象集合序列化到单个列中</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E4%BD%93%E4%BF%9D%E5%AD%98%E5%A4%9A%E4%B8%AA%E5%80%BC%E5%AF%B9%E8%B1%A1">使用数据库实体保存多个值对象</a></li>
<li><a href="#orm-%E4%B8%8E%E6%9E%9A%E4%B8%BE%E7%8A%B6%E6%80%81%E5%AF%B9%E8%B1%A1">ORM 与枚举状态对象</a></li>
</ul>
</li>
</ul>
<p>值对象用于度量和描述事物，即便一个领域概念必须建模成实体，在设计时也应该更偏向于将其作为值对象的容器，而不是子实体的容器</p>
<blockquote>
<p>笔者曾一度认为值对象就是 C# 语言中使用 <code>struct</code> 结构来表示的多个数据代表一个整体的集合，后来发现书中讲到的值对象无关技术实现，而是从概念上定义它的职责，包括不可变性和非唯一性。</p>
</blockquote>
<blockquote>
<p>同样的，在有了实体这把武器之后，当一个实体需要嵌套其他对象时，实体经常遭到滥用。当面临将对象定义为实体还是值对象的选择时，由于缺乏对于值对象的充分认识，很多开发人员选择了嵌套实体。</p>
</blockquote>
<h2 id="不变性"><a href="#不变性" class="headerlink" title="不变性"></a>不变性</h2><p>当我们只关心某个对象的属性时，该对象便可作为一个值对象，为其添加有意义的属性，并赋予它们相应的行为。值对象在其生命周期中是「<strong>不可变</strong>」的，本身代表了某种状态，它没有任何身份标识，也应该尽量避免像实体一样复杂。在设计得当的前提下，我们可以对值对象的实例进行创建和传递，甚至在使用完之后将其直接扔掉。我们不必担心客户代码对值对象进行修改，一个值对象的生命周期可长可短，它就像一个无害的过客在系统中来来往往。</p>
<p>当决定一个领域概念是否是一个值对象时，考虑以下特征：</p>
<ul>
<li>它度量或者描述了领域中的一件东西</li>
<li>它可以作为不变量</li>
<li>它将不同的相关的属性组合成一个概念性的整体</li>
<li>当度量和描述改变时，可以用另一个值对象予以替换</li>
<li>它可以和其他值对象进行相等性比较</li>
<li>它不会对协作对象造成副作用</li>
</ul>
<p>为了保持值对象的不变性，创建它所依赖的参数必须一次性全部传给其构造函数，之后任何时间都不可能再改变它。有时根据需要，会在值对象中引用实体对象，这种情况需要谨慎，当实体对象的状态发生改变时，引用它的值对象也将发生改变，这违背了值对象不变性特征。</p>
<h2 id="概念整体"><a href="#概念整体" class="headerlink" title="概念整体"></a>概念整体</h2><p>编程语言提供的基元类型(如 <code>string</code>, <code>int</code>, <code>double</code> 等)似乎是值对象的最佳类型，但有时，这种思维方式会造成对基元类型的滥用。</p>
<p>假如需要在 「<strong>ThingOfWorth</strong>」 类中加入名为 「<strong>Name</strong>」 的属性，我们自然而然的会想到将其定义为 <code>string</code> 类型，但很快我们就发现该类型的名字需要以不同的方式进行展示，此时，处理展示方式的逻辑就会莫名其妙的由客户代码来完成，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户代码</span></span><br><span class="line">String name = thingOfWorth.name();</span><br><span class="line">String capitalizedName = name.subString(<span class="number">0</span>,<span class="number">1</span>).toUpperCase() + name.subString(<span class="number">1</span>).toLowerCase();</span><br></pre></td></tr></table></figure></p>
<p>在以上示例中，客户代码自己试图解决 <code>name</code> 的大小写问题。通过定义 「<strong>ThingName</strong>」 类型，我们可以将与 <code>name</code> 有关的所有逻辑操作放到该类型中，然后在构造该值对象时进行格式化，客户代码只需调用相应的方法即可得到结果，而不必自行处理这些逻辑。</p>
<p>有些编程语言允许我们简单地向一个类添加新的行为(例如 C# 的扩展方法)。此时，你可能会想着用 <code>Double</code> 类型来表示货币，如果需要计算不同货币之间的汇率，我们只需要向 <code>Double</code> 类型添加 <code>convertToCurrency(Currency aCurrency)</code> 扩展方法即可。但是在这种场景下使用语言特性就一定是一个好主意吗？首先，和货币相关的行为很有可能丢失在浮点数计算中；其次，<code>Double</code> 类型也丝毫没有表达出领域概念。很快，我们就会丢掉领域关注点。</p>
<blockquote>
<p>当你试图将多个属性加在一个实体上，这有可能弱化了各个属性之间的关系，那么此时就应该考虑将这些相互关联的属性组合在一个值对象中了。每个值对象都是一个「<strong>内聚的概念整体</strong>」，它表达了通用语言中的一个概念。</p>
</blockquote>
<h2 id="可替换性"><a href="#可替换性" class="headerlink" title="可替换性"></a>可替换性</h2><p>值对象的可替换性可通过数字的替换来理解，假设领域中有一个名为 <code>total</code> 的概念，该概念用整数表示。如果 <code>total</code> 的当前值为 <code>3</code>，但是之后需要重设为 <code>4</code>，此时我们并不会将整数修改成 <code>4</code>，而是简单地将 <code>total</code> 的值重新赋值为 <code>4</code>。</p>
<blockquote>
<p>从语言层面来说，这里的修改其实是对该属性赋新值，但看上去像是修改，实际上只是语法糖，原先为 <code>3</code> 的内存并不会被修改为 <code>4</code>，而是被新的代表 <code>4</code> 的内存块替代。</p>
</blockquote>
<p>考虑下面一种更复杂的值对象替换：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FullName name = <span class="keyword">new</span> FullName(<span class="string">"金"</span>,<span class="string">"沐"</span>);</span><br><span class="line"><span class="comment">// 稍后</span></span><br><span class="line">name = <span class="keyword">new</span> FullName(<span class="string">"金"</span>,<span class="string">"灶沐"</span>);</span><br></pre></td></tr></table></figure></p>
<p>这里，我们并没有使用 FullName 类型的某个方法来修改其自身的状态(<strong>这破坏了值对象的不变性</strong>)，而是构造一个新的值对象实例来替换原来的实例。</p>
<h2 id="值对象相等性"><a href="#值对象相等性" class="headerlink" title="值对象相等性"></a>值对象相等性</h2><p>值对象的相等性应该由组成其实例的每一个属性及其类型来决定，在上文的 「<strong>FullName</strong>」 对象中，当两个 「<strong>FullName</strong>」 实例的每个属性及其类型都相等，我们才认为两个实例相等，尽管他们在内存中是不同的地址。值对象的相等性可用来支撑「<strong>聚合</strong>」唯一标识的比较，实体的唯一标识是不能改变的，这可以部分通过值对象的不变性实现。值对象的整体概念也可以用来支撑不只一个属性的实体标识，同时，如果实体的唯一标识需要一些「<strong>无副作用行为</strong>」，这些行为便可以在值对象上实现。</p>
<h2 id="无副作用行为"><a href="#无副作用行为" class="headerlink" title="无副作用行为"></a>无副作用行为</h2><p>一个对象的方法可以设计成一个「<strong>无副作用函数(Side-Effect Free Function)</strong>」，该函数表示对某个对象的操作，只用于产生输出，而不会修改对象的状态。对于不变的值对象而言，所有的方法都必须是无副作用函数。下面的例子通过调用 「<strong>FullName</strong>」 对象上的无副作用方法将该对象本身替换成另一个实例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FullName name = <span class="keyword">new</span> FullName(<span class="string">"金"</span>,<span class="string">"沐"</span>);</span><br><span class="line"><span class="comment">// 稍后</span></span><br><span class="line">name = name.withMiddleInitial(<span class="string">"灶"</span>);</span><br></pre></td></tr></table></figure></p>
<p>这里的代码更具表达性，<code>withMiddleInitial</code> 方法并没有修改值对象的状态，因此它不会产生副作用。该方法通过已有 <code>firstName</code> 和 <code>lastName，外加传入的</code> <code>middleName</code> 创建一个新的 <code>FullName</code> 值对象实例。<code>withMiddleInitial()</code> 还捕获到了重要的领域业务逻辑，从而避免了将这些逻辑泄漏到客户代码中。</p>
<blockquote>
<p>这里所说的捕获重要的领域业务逻辑，是指该方法本身是具有表达性的，比起使用 <code>new</code> 语句创建实例，更像是调用了该实例支持的某个行为满足了客户代码的需求。</p>
</blockquote>
<p>有些值对象的方法引用了实体，这存在一些问题。例如下面的代码，我们有一个实体对象 <code>product</code>，该对象被值对象 <code>BusinessPriority</code> 引用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> priority = businessPriority.priorityOf(product);</span><br></pre></td></tr></table></figure></p>
<p>我们至少可以看出以下问题：</p>
<ul>
<li><code>BusinessPriority</code> 不仅依赖 <code>Product</code> 类型，还试图去理解该实体的内部状态，我们应该尽量使值对象只依赖于它自己的属性，并且只理解它自身的状态。</li>
<li>阅读本段代码的人并不知道使用了 <code>Product</code> 的哪些部分，这种表达方法并不明确，从而降低了模型的清晰度。更好的方式是只传入需要用到的 <code>Product</code> 属性。</li>
<li>更重要的是，在将实体作为参数的值对象方法中，我们很难看出该方法是否会对实体进行修改，测试也将变得非常困难。</li>
</ul>
<p>有了以上分析，我们需要对值对象进行改进，要增加一个值对象的健壮性，我们传给值对象方法的参数依然应该是值对象。这样我们可以获得更高层次的无副作用行为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> priority = businessPriority.priority(product.businessPriorityTotals());</span><br></pre></td></tr></table></figure></p>
<p>这里，我们把 <code>Product</code> 实体的 <code>BusinessPriorityTotals</code> 值对象传递给了 <code>priority()</code> 方法。</p>
<hr>
<p>如果打算使用编程语言提供的基本值对象类型，而不使用特定的值对象，我们是无法将领域特定的无副作用函数分配给编程语言提供的基元值对象的。有些真正简单的属性是没有必要特殊对待的。例如，一些布尔类型或数值类型，它们已经能够自给了，并不需要额外的功能支持，也并不和实体中的其他属性关联。这些简单的属性称为<strong>意义整体</strong>。</p>
<h2 id="最小化集成"><a href="#最小化集成" class="headerlink" title="最小化集成"></a>最小化集成</h2><p>当模型概念从上游上下文流入下游上下文时，尽量使用值对象来表示这些概念。这样做的好处是可以达到最小化集成，即最小化下游模型中用于管理职责的属性数目。</p>
<h2 id="用值对象表示标准类型"><a href="#用值对象表示标准类型" class="headerlink" title="用值对象表示标准类型"></a>用值对象表示标准类型</h2><p>系统中既有表示事物的实体和描述实体的值对象，同时还存在「<strong>标准类型(Standard Type)</strong>」来区分不同的类型。假设通用语言中定义了一个 「<strong>PhoneNumber</strong>」 值对象，同时需要为每个 「<strong>PhoneNumber</strong>」 对象制定一个类型，用以区分家庭电话，移动电话，工作电话还是其他类型的电话号码。不同类型的电话号码类型需要建模成一种类的层级关系吗？为每一个类型创建一个类对于客户代码的使用来说是非常困难的。此时，你需要标准类型来描述不同的电话号码，比如 <code>Home</code>，<code>Mobile</code>，<code>Work</code> 或者 <code>Other</code>。</p>
<p>枚举类型是实现标准类型的一种简单方法。枚举提供了一组有限数量的值对象，它非常轻量且无副作用。通常来说，<strong>没有必要为标准类型提供描述信息</strong>，只需要名字就足够了。为什么？文本描述通常只在<strong>用户界面层</strong>中才会用到，此时可以用一个显示资源和类型名字匹配起来。很多时候用于显示的文本都需要进行本地化，因此将这种功能放在模型中并不合适。通常来说，在模型中使用标准类型的名字是最好的方式。</p>
<blockquote>
<p>为了维护方便，最好是为标准类型创建单独的限界上下文。</p>
</blockquote>
<p>有些标准类型所表达的概念不像是某种标准而更像是一种状态，此时标准类型实现为状态模式，但为每一种状态创建单独的类会使系统变得复杂。对于实体的状态类来说，有些行为来自于自身，有些继承自抽象基类，这一方面在子类和父类之间形成了紧耦合，另一方面使代码的可读性变差。如果你不打算使用状态模式，那么枚举可能是最简单的方法。</p>
<p>一个共享不变的值对象可以从持久化存储中获取，此时可以通过标准类型的「<strong>领域服务</strong>」或「<strong>工厂</strong>」来获取值对象。<strong>我们应该为每组标准类型创建一个领域服务或工厂</strong>(比如一个服务处理电话号码类型，一个服务处理邮寄地址类型，另一个服务处理货币类型)，服务或工厂将按需从持久化存储中获取标准类型，而客户方代码并不知道这些标准类型是来自数据库中的。另外，使用领域服务或工厂还使得我们可以加入不同的缓存机制，由于值对象在数据库中是只读的，并且在整个系统中是不变的，缓存机制也将变得更加简单安全。</p>
<p>总的来说，建议尽量使用枚举来表示标准类型，即便你认为某个标准类型更像一种状态模式。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>通常来说，值对象至少包含两个构造函数，第一个构造函数接受用于构建对象状态的所有属性参数，称为主构造函数。该构造函数调用私有的 <code>setter</code> 方法初始化默认的对象状态，该私有的 <code>setter</code> 方法向我们展示了一种自委派性。</p>
<blockquote>
<p>只有主构造函数才能使用自委派性来设置属性值，除此之外，其他任何方法都不能使用 <code>setter</code> 方法。由于所有的 <code>setter</code> 方法都是私有的，消费方是没有机会调用这些方法的，这是保持值对象不变性的两个重要因素。</p>
</blockquote>
<p>第二个构造函数用于将一个值对象复制到另一个新的值对象，即复制构造函数。它将构造过程委派给主构造函数，先从原对象中取出各个属性，再将这些属性作为参数传给主构造函数。</p>
<blockquote>
<p>复制构造函数对于测试来说是非常重要的，测试对象时，我们希望验证值对象的不变性，通过复制构造函数创建一个原实例的副本，验证两者的相等性。</p>
</blockquote>
<h2 id="持久化值对象"><a href="#持久化值对象" class="headerlink" title="持久化值对象"></a>持久化值对象</h2><p>以下着重讨论如何持久化包含值对象的聚合实例。聚合的读取和保存通过资源库完成。</p>
<p>有时，值对象需要以实体的身份进行持久化。换句话说，某个值对象实例会单独占据一张表中的某条记录，而该表也是专门为这个值对象类型而设计的，它甚至拥有自己的主键列。当面临「<strong>对象 - 关系阻抗失配</strong>」时，考虑以下几个问题：</p>
<ol>
<li>我当前所建模的概念表示领域中的一个东西呢，还是只是用于描述和度量其他东西？</li>
<li>如果该概念起描述作用，那么它是否满足值对象的几个特征？</li>
<li>将该概念建模成实体是不是只是持久化上的考虑？</li>
<li>将该概念建模成实体是不是因为它拥有唯一标识，我们关注的是对象实例的个体性，并且需要在其整个生命周期中跟踪其变化？</li>
</ol>
<p>我们不应该使持久化机制影响到对值对象的建模。<strong>无论使用什么技术来完成数据建模，数据库实体，主键，引用完整性和索引都不能用来驱动你对领域概念的建模。</strong></p>
<h3 id="单个值对象"><a href="#单个值对象" class="headerlink" title="单个值对象"></a>单个值对象</h3><p>当实体包含单个值对象，值对象的属性需要和包含它的实体保存在一张数据表中时，其列名最好采用与数据库一致的形式，例如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BusinessPriority.Ratings.Benefit</span><br><span class="line">=&gt;</span><br><span class="line">business_priority_ratings_benefit</span><br></pre></td></tr></table></figure></p>
<h3 id="值对象集合序列化到单个列中"><a href="#值对象集合序列化到单个列中" class="headerlink" title="值对象集合序列化到单个列中"></a>值对象集合序列化到单个列中</h3><p>将一个 List 或 Set 的值对象保存在单个列中需要考虑以下问题：</p>
<ul>
<li>列宽：有些对象集合可以包含任意多个元素，但数据库的列宽是有限制的。</li>
<li>查询：如果需要对该集合中的元素进行查询，无法用 SQL 语句实现，但从一个集合中查询一个或多个属性是比较少见的情况。</li>
<li>序列化器和反序列化器：需要自定义类型来实现序列化器和反序列化器，这只是增加了工作量。</li>
</ul>
<h3 id="使用数据库实体保存多个值对象"><a href="#使用数据库实体保存多个值对象" class="headerlink" title="使用数据库实体保存多个值对象"></a>使用数据库实体保存多个值对象</h3><p>我们不能因为某个概念<strong>非常符合数据库实体而将其建模成领域模型中的实体</strong>。有时，是对象 - 关系阻抗失配需要我们采用这种方法，但这绝非 DDD 原则。要实现这种方案，我们可以采用「<strong>层超类型</strong>」，或又名「<strong>委派身份标识(主键)</strong>」。下面的例子使用了两层层超类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public abstract class IdentifiedDomainObject: ISerializable</span><br><span class="line">&#123;</span><br><span class="line">    private long _id = -1;</span><br><span class="line">    protected long Id </span><br><span class="line">    &#123;</span><br><span class="line">        get =&gt; this._id;</span><br><span class="line">        set =&gt; this._id = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来定义另一层层超类型，该层超类型是值对象专属的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public abstract class IdentifiedValueObject: IdentifiedDomainObject</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>虽然 <strong>IdentifiedValueObject</strong> 什么也不做，但它显式地表明了建模意图。<strong>IdentifiedValueObject</strong> 还应该有另外一个专属于实体的抽象子类 <strong>Entity</strong>。现在，每一个值对象类型都可以方便地获得一个隐藏的委派主键，我们可以自由地将其映射成数据库实体，而在领域模型中将其建模成值对象。</p>
<blockquote>
<p>委派标识主要用于数据建模，其没有领域模型含义，这里更多是说明当实体包含值对象集合并且需要对其进行查询时如何对它们进行持久化，这样的值对象在数据库中会有一张单独的表，但这并不代表他们就是领域模型中的实体。</p>
</blockquote>
<h3 id="ORM-与枚举状态对象"><a href="#ORM-与枚举状态对象" class="headerlink" title="ORM 与枚举状态对象"></a>ORM 与枚举状态对象</h3><p>参考 《实现领域驱动设计》 P230</p>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/ddd/" rel="tag"><i class="fa fa-tag"></i> ddd</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/ddd-tactical-entity/" rel="prev" title="《实现领域驱动设计》读书笔记(4) - 战术建模之实体">
      <i class="fa fa-chevron-left"></i> 《实现领域驱动设计》读书笔记(4) - 战术建模之实体
    </a></div>
      <div class="post-nav-item">
    <a href="/ddd-tactical-domain-service/" rel="next" title="《实现领域驱动设计》读书笔记(6) - 战术建模之领域服务">
      《实现领域驱动设计》读书笔记(6) - 战术建模之领域服务 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2015 – 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Frost He</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">295k</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
<script src="/js/utils.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>















  

  

</body>
</html>
