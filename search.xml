<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[《实现领域驱动设计》读书笔记(1) - 总览]]></title>
    <url>%2F%E6%9E%B6%E6%9E%84%E4%B8%8E%E6%A8%A1%E5%BC%8F%2FDDD%2Fnote-ddd-overview%2F</url>
    <content type="text"><![CDATA[面向对象编程的博大精深至今只浅尝一二，开发实践中一直希望能够持久向好的设计方向上靠而不过度设计。2015 年时第一次接触到领域驱动设计，当时买了 《实现领域驱动设计》这本书，初看时晦涩难懂，书中许多概念与当时自己的理解存在很大偏差，一度不理解为何要那样设计。在经过了几个项目的实战之后，如今再翻出来看，对书中总结的思考方式和方法论有了一番新的体会。现在看来，领域驱动设计之所以难以理解，在于其方法论的概念是抽象于任何语言和技术实现的，长期工作于一线的开发人员要转换思维去理解类似值对象，标准类型等这样的概念，需要一些时间。 总览一谈到领域驱动设计或者 DDD，总是很难通过一句话来概括，它既不是设计模式，也不代表任何技术实现，仅仅是面向对象程序设计的一种方法论，其中涵盖了在任何软件系统中可能涉及的方方面面。 领域模型什么是领域模型？领域模型是关于某个特定业务领域的软件模型。通常，领域模型通过对象来实现，这些对象同时包含了数据和行为，并且表达了准确的业务含义 ——《领域驱动设计》 全书由高层视角深入到实现的细枝末节来组织章节，其索引大致为： 战略建模 通用语言(Ubiquitous Language) 领域，子域和核心域 限界上下文(Bounded Context) 上下文映射图(Context Mapping) 架构(Archiecture) 战术建模 实体(Entity) 值对象(Value Object) 领域服务(Domain Service) 领域事件(Domain Event) 模块(Module) 聚合(Aggregate) 工厂(Factory) 资源库(Repository) 集成限界上下文(Integrating Bounded Contexts) 应用程序 这些不同的内容会在后续的笔记中一一提到，只取我觉得有价值的部分记录下来。设计一个系统时所需要的所有建模工具都能在以上这些概念中找到，并且针对这些应用场景提出了指导意见和最佳实践。]]></content>
      <categories>
        <category>架构与模式</category>
        <category>DDD</category>
      </categories>
      <tags>
        <tag>ddd</tag>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在 MacOS 上安装 nginx]]></title>
    <url>%2FMacOS%2Fmacos-install-nginx%2F</url>
    <content type="text"><![CDATA[不同于其他 Linux 系统，MacOS 使用了 brew 作为包管理器，并同时肩负了服务进程管理器的角色，在本机完成网站内容的准备工作之后，开始考虑把 MacOS 变成一个 web server。 安装 nginx使用 HomeBrew 在 MacOS 上安装 nginx:1$ brew install nginx 安装完成后，会显示如下提示信息：12345678910111213==&gt; CaveatsDocroot is: /usr/local/var/wwwThe default port has been set in /usr/local/etc/nginx/nginx.conf to 8080 so thatnginx can run without sudo.nginx will load all files in /usr/local/etc/nginx/servers/.To have launchd start nginx now and restart at login: brew services start nginxOr, if you don&apos;t want/need a background service you can just run: nginx==&gt; Summary 简要归纳为： 网站根目录在 /usr/local/var/www 默认端口在 为 /usr/local/etc/nginx/nginx.conf 文件中配置为 8080，这样 nginx 无需 $sudo 权限就可执行 nginx 将从 /usr/local/etc/nginx/servers/ 目录读取所有配置文件信息 要让 nginx 随用户登录一同启动请执行命令 brew services start nginx 若不需要作为后台服务启动，请直接执行命令 nginx 配置新站点创建一个目录作为新站点的根目录，例如1mkdir -p /usr/local/var/www/your-site-name 查看 /usr/local/etc/nginx 目录，有一个名为 nginx.conf.default 的文件，该文件通常为网站配置的起始点。首先导航到 /usr/local/etc/nginx/servers/ 目录，然后将该默认配置文件复制一份。12cd /usr/local/etc/nginx/servers/cp ../nginx.conf.default your-site-name.conf 修改 listen, server_name, location 块下的 root 和 index 项的值到对应的值，保存并退出配置文件。利用 nginx -t 检查配置的有效性，一切准备就绪后，执行 brew services reload nginx 命令重新加载配置。 之后，通过在浏览器中的输入对应主机的 ip 地址或域名及端口号，即可访问到部署到 nginx 的站点]]></content>
      <categories>
        <category>MacOS</category>
      </categories>
      <tags>
        <tag>diy</tag>
        <tag>make-the-best-of-my-macmini</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git push 到 MacOS]]></title>
    <url>%2FMacOS%2Fmacos-git-push-to-repository%2F</url>
    <content type="text"><![CDATA[MacOS 没有自带 git，需要通过 XCode Command Line Tools 进行安装，当通过 ssh 客户端远程登录到 MacOS 并执行 git --version，MacOS 会自动弹出确认框以进行安装，这里需要手动在 MacOS 系统界面下点击确认按钮才能继续。完成安装后再次执行 git --version，已能够看到版本号。新建或导航到一个目录，将其作为新 repository 的根目录。 12mkdir -p development/hobby-project/my-first-git-repositorycd development/hobby-project/my-first-git-repository 因为这里有 3 层目录结构，不带任何参数的 mkdir 命令将不会递归创建目录，-p 选项表示，如果任何层级的目录不存在，将递归创建目录，如果所有层次的目录都已存在，则不会进行任何操作。同时，要确保登录到远程机器的用户拥有针对创建目录的所有层级的读写权限，否则 git pull 和 git push 将会报错。如果权限不正确，使用 $sudo chown -R 命令更改文件夹或文件权限。 现在，development/hobby-project/my-first-git-repository 将作为远程 repository 根目录，执行：12$sudo git init --bareInitialized empty Git repository in /Users/XXX/development/hobby-project/my-first-git-repository/ git init --bare 参数指明该 repository 用于分布式版本控制的中心仓库，git 将仅保存历史记录，一般来说服务器上的仓库多使用 --bare 创建，其目的在于分发而非修改，参考 what is a git bare repository。 远程仓库创建完成后，回到客户端主机，这里采用 ssh 协议进行通信，如果没有现成的 key，需要先生成 key pair。ssh 默认配置存放在用户 home 目录下的 .ssh 文件夹下，如果没有指定 config 文件，则 id_rsa 作为默认的 key 文件名，具体参考 How To Configure Custom Connection Options for your SSH Client。]]></content>
      <categories>
        <category>MacOS</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>diy</tag>
        <tag>make-the-best-of-my-macmini</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在 Windows 环境下远程控制 MacOS]]></title>
    <url>%2FMacOS%2Fmacos-remote-control%2F</url>
    <content type="text"><![CDATA[为了把闲置已久的 Mac mini 变成一个可在 Windows 环境下远程操作的小型私有服务器，需要现实至少以下两点目标： 使用 ssh 客户端远程登录，类似通过 PuTTy 管理其他类 Linux 系统 使用 sftp客户端实现文件传输的需求 同时，要确保 MacOS 主机与客户端主机在网络上是互通的，要么在同一局域网下通过 ip 地址访问，要么使用域名映射固定 ip 地址。 准备工作MacOS 自带了 ssh，但默认是禁用的，通常我们进行以下步骤的确认： 12$sudo systemsetup -getremoteloginRemote Login: Off 该命令查询本地计算机远程登录功能是否启用，如果显示 Off，则执行以下命令开启：1$sudo systemsetup -setremotelogin on 再次执行查询命令以确认上一条命令生效并且该功能启用：12$sudo systemsetup -getremoteloginRemote Login: On $sudo systemsetup -getremotelogin 将同时启用 ssh 以及 sftp server 在这些命令前加上 sudo 是必须的，因为这些操作均要求管理员权限。 在 Windows 下远程操作 MacOS现在，在 Windows 系统下使用 bash 或 PuTTy 客户端，连接到该 Mac 所在的 ip 地址：1ssh username@ipaddress 登录完成后便与在 MacOS 本机上使用该账号操作 terminal 一样了。 远程登录同时开启了 sftp 服务，这意味着如果使用类似 winscp 之类的文件传输客户端也可以连接 MacOS 并完成文件传输。 为远程登录添加安全访问机制ssh 针对不同 group 的用户提供了不同的远程访问策略，使用密码登录是一件非常不安全的，如果该 MacOS 主机在通过内网穿透或拥有公网 ip 暴露在互联网下，那么随时有遭受攻击的可能，为了加强安全性，我们可以： 禁止使用密码验证登录 开启 ssh key pair 验证登录 确保我们已经进行远程登录后，首先导航到 ssh 配置所在的目录：1cd /etc/ssh/ 列出文件列表：1ls -ll 使用 vim 编辑器打开 sshd_config 文件：1vi sshd_config 按下 ‘i’ 使 vim 进入 insert 模式找到 #PasswordAuthentication yes 一行，删除行头的 ‘#’ 字符，并将 ‘yes’ 改为 ‘no’ ‘#’ 表示对该行进行注释 找到 #PubKeyAuthentication yes 一行，删除行头的 ‘#’ 字符，按下 ‘esc’ 键退出 ‘insert’ 模式，按下 ‘:wq’ 以保存并退出 vim 编辑器。 若要修改生效， sshd 进程需要重新读取该配置，但这会让已经通过密码登录的会话中断，并且在 public key 部署前没有任何机会重新进行远程连接，所以这一步放到最后来做。 现在，复制先准备好的 ssh public key 的值，回到登录用户的主目录并导航到 .ssh 目录下：12cd #cd .ssh 新建 authorized_keys 文件并使用 vim 编辑器编辑：12touch authorized_keys$sudo vi authorized_keys 粘贴已经复制到剪贴板中的 ssh public key 的值，’:wq’ 保存并退出。 在前文提及的 /etc/ssh/sshd_config 中有一行 AuthorizedKeyFiles，该行的默认值为 .ssh/authorized_keys，该项配置是 sshd 进程提取 public key 的依据，如果对该值进行了修改，那么这里新建的文件也必须要与之对应。 现在，重新读取 sshd 的配置文件信息1$sudo launchctl load -w /System/Library/LaunchDaemons/ssh.plist]]></content>
      <categories>
        <category>MacOS</category>
      </categories>
      <tags>
        <tag>diy</tag>
        <tag>make-the-best-of-my-macmini</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建 Hexo 轻博客]]></title>
    <url>%2FWeb%2Fhexo%2Fhexo_setup%2F</url>
    <content type="text"><![CDATA[搭建博客的第一步，就是要找到符合自己需求的博客框架。之前用 LAMP 搭过 Wordpress，但就写博客这个需求来说 Wordpress 的功能太重了，希望环境尽量越简单越好。与同事们交流得知 Hexo 是一个轻量级的基于 Markdown(.md) 的轻博客框架，自己便开始了 DIY。 环境准备 Node.js 安装 hexo npm 包 git bash 客户端 hexo 是 npm 的一个包，首先从 Node.js 官网下载对应系统的安装包。Node.js 安装完成后会自动在环境变量中加入 npm cli 的路径，接着在 cli 中使用以下命令安装 hexo 包：1npm install -g hexo-cli 确认安装已经成功：1hexo version 初始化以下两种途径初始化 hexo： 首先创建指定目录作为 hexo 的根目录，在该目录下运行命令行工具，执行 hexo init，该命令会以当前目录作为 hexo 的根 启动命令行工具，执行 hexo init &lt;folder&gt; 初始化指定目录为 hexo 的根，随后执行 cd &lt;folder&gt; 导航到该目录 hexo init &lt;folder&gt; 命令中，如果 folder 所包含的目录层级中包含不存在的层级，该命令会自动创建该层级下的目录 初始化完成后，得到以下的目录结构：12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 在初始化完成后的目录中包含了 package.json 文件，意味着该项目有其自己的 npm 包依赖，执行 npm install 解析依赖并在本地安装。 配置 _config.yml_config.yml 文件包含了对 hexo 博客站点的配置信息。 网站(site) 参数 描述 title 网站标题 subtitle 网站副标题 description 网站描述 author 作者名字 language 网站使用的语言 timezone 时区 其中，description 主要用于 SEO，为搜索引擎提供一个关于站点的简单描述，通常建议包含网站的关键词。author 参数用于主题显示文章的作者。 网址(url) 参数 描述 默认值(示例值) url 根地址 http://www.your-site.conm/blog/ root 站点根目录 /blog/ permalink 文章的永久链接格式 :year/:month/:day/:title/ permalink_defaults 永久链接中各部分的默认值 永久链接是指，当执行 hexo s 或发布到 web server 之后，其生成文件的 url 组成策略，默认值为 :year/:month/:day/:title/，这意味着 url 将以分隔的日期值来定位文章。 url 和 root 总是成对修改，例如，想要把站点的根目录放在子目录 /blog 下，那么 root 的值应该修改为 /blog/，url 的值对应修改为 http://www.your-site.com/blog/。官方文档中的网站存放于子目录的意思是，hexo 项目包含的是生成站点的源代码文件，包括 source/_posts 目录，均用于生成网站，而“网站”是指生成好之后的静态资源文件集。 更多配置详情参考官方文档 本地测试本地生成并 serve：123cd &lt;target-directory&gt;hexo ghexo server 此时在浏览器中访问 localhost 对应的端口号将看到一个新的模板页面已经生成成功，执行如下命令来创建新的文章，在 source/_posts 目录下一个对应的文件被创建1hexo new "my-first-post" 导航到该文件可以看到其模板内容 12345---title: my-first-postdate: 2018-03-01 02:51:53tags:--- 重新生成博客文章并启动 hexo server12hexo generatehexo server -o --debug -o 参数代表在成功 serve 立即打开一个浏览器窗口以访问站点的根页面，--debug 参数启用在控制台打印 debug 级别的日志信息，方便排错。hexo generate 可简写为 hexo g，hexo server 可简写为 hexo s 文章列表中已经列出刚刚创建的文章名称，进一步修改该文件，hexo server 将实时更新页面内容 部署到 Github Pages当站点准备就绪后，下一步就是要给它找个家，GitHub 为每个账号提供了站点寄宿服务——GitHub Pages，在 GitHub 中创建一个 username.github.io 的公开仓库，将 build 好的站点资源文件集 push 到该仓库，再访问唯一的 https://username.github.io/ 即可。 hexo 提供了自动部署机制，在 _config.yml 中找到 deploy 这一项：123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:username/username.github.io.git branch: master 部署的更多详情参考官方文档 GitHub Pages 同时支持自定域名解析，假设已经有了一个域名 example.com，那么在 dns 提供商后台将自定的二级域名或 www 域名指向 username.github.io 即可，具体参考 https://help.github.com/articles/using-a-custom-domain-with-github-pages/GitHub Pages 使用自定域名后无法启用 https 通信协议。]]></content>
      <categories>
        <category>Web</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为 Linux 系统配置 CSF]]></title>
    <url>%2Flinux%2Flinux-configure-csf%2F</url>
    <content type="text"><![CDATA[Config Server Firewall(CSF) 基于一般的防火墙功能(数据包过滤)进行了扩展，支持大多数 Linux 发行版本，其支持列表可在其官网找到。以下以 ubuntu 系统为例介绍 CSF 的使用。 对 CSF 的几乎所有指令操作都需要管理员权限，本篇文章仅涵盖 ipv4 的防火墙设置 - iptables。ipv6 对应的是 ip6tables。 功能认证失败检测守护进程CSF 每隔一段时间就会检查系统登录日志，对那些登录失败的请求尝试进行监控，在达到预设的失败次数后，CSF 将对发起这些请求的 ip 地址做预设的处理，失败次数和处理动作都是可自定义的。 以下程序对该功能兼容： Courier imap, Dovecot, uw-imap, Kerio openSSH cPanel, WHM, Webmail (cPanel servers only) Pure-ftpd, vsftpd, Proftpd Password protected web pages (htpasswd) Mod_security failures (v1 and v2) Suhosin failures Exim SMTP AUTH同时，可以自定义匹配 Regex 的登录文件来，对登录失败尝试的用户进行屏蔽。 进程追踪CSF 可检测异常行为的进程或异常开启端口的行为，在捕获到这些行为时可配置发送邮件给服务器管理员。 目录监控CSF 可监控 /temp 和其他相关的目录扫描恶意脚本，并在发现风险时发送邮件给服务器管理员。 消息服务启用该功能可让 CSF 在屏蔽客户端时传送一些有用的信息，但这样做可能会为黑客提供一些线索信息，继而增加服务器的风险。 端口涌流保护该设置提供端口涌流保护，比如 DDoS 攻击，可以为每个端口指定特定时间内允许最大的连接数。启用该功能可以极大降低黑客的野蛮攻击导致服务器宕机。找到一个适合的参数需要一些尝试，太过严格的流量限制会降低正常用户的体验。 Port Knocking参考 Port Knocking。 连接限制保护该功能可限制由单一 ip 地址对特定端口建立的连接数，这也是防止 DDoS 攻击的手段之一。 Port/IP 地址重定向可配置 CSF 将对特定 IP/Port 的连接重定向到另一个 IP/Port。注意，重定向之后，请求发起的客户端将变为服务器的 ip 地址，该功能与 NAT 不同。 UI 集成除了命令行工具之外，CSF 对 cPanel 和 Webmin 提供了 UI 集成。 IP 屏蔽列表CSF 可使用该功能从预设的源下载屏蔽的 ip 地址列表。 安装 ConfigServer Firewall下载从官网下载安装包到当前工作目录：1wget http://download.configserver.com/csf.tgz 解压缩下载下来的是一个经过压缩的压缩包，安装之前需要解压缩1tar -xzf csf.tgz 安装在进行安装之前，首先禁用其他防火墙脚本，例如 UFW，执行以下指令禁用 UFW：1$sudo ufw disable 导航到刚刚解压出来的文件夹 csf，执行安装脚本：1234cd csf$sudo sh install.sh...Installation Completed 安装完成后，查看指定的 iptables 是否可用：123456789101112131415$sudo perl /usr/local/csf/bin/csftest.plTesting ip_tables/iptable_filter...OKTesting ipt_LOG...OKTesting ipt_multiport/xt_multiport...OKTesting ipt_REJECT...OKTesting ipt_state/xt_state...OKTesting ipt_limit/xt_limit...OKTesting ipt_recent...OKTesting xt_connlimit...OKTesting ipt_owner/xt_owner...OKTesting iptable_nat/ipt_REDIRECT...OKTesting iptable_nat/ipt_DNAT...OKRESULT: csf should function on this server 出现以上报告内容则表明 CSF 已可在服务器上正常运行。 此时，通过登录到服务器的 ip 地址会被自动加入到白名单中，同时 SSH 占用的端口(即便是自定义的端口)会自动开启，CSF 默认使用测试模式，该模式下所有的 iptables 规则将在 5 分钟后自动被移除。一旦确认所有配置已经就绪，应切换为工作模式。 基本配置通过编辑 /etc/csf/csf.conf 文件来配置 CSF，保存更改后，执行 csf -r 来使配置重新生效。1$sudo nano /etc/csf/csf.conf 配置端口配置文件中默认开启的端口如下：1234567TCP_IN = "20,21,22,25,53,80,110,143,443,465,587,993,995"TCP_OUT = "20,21,22,25,53,80,110,113,443"UDP_IN = "20,21,53"UDP_OUT = "20,21,53,113,123" 这些端口代表的默认服务如下： Port 20: FTP 数据传输 Port 21: FTP 控制 Port 22: 安全 shell (SSH) Port 25: 简单邮件传输协议 (SMTP) Port 53: 域名系统 (DNS) Port 80: 超文本传输协议 (HTTP) Port 110: 邮局协议 v3 (POP3) Port 113: 身份协议 Port 123: 网络时间协议 (NTP) Port 143: 因特网信息访问协议 (IMAP) Port 443: 超文本安全传输协议 (HTTPS) Port 465: URL Rendesvous Directory for SSM (Cisco) Port 587: 简单邮件传输协议 (SMTP) Port 993: 因特网安全信息访问协议 (IMAPS) Port 995: 安全邮局协议 v3 (POP3S) 以下是针对常见场景开启的服务端口： 任何主机1234TCP_IN: 22,53TCP_OUT: 22,53,80,113,443UPD_IN: 53UPD_OUT: 53,113,123 Apache1TCP_IN: 80,443 FTP 服务器1234TCP_IN: 20,21TCP_OUT: 20,21UPD_IN: 20,21UPD_OUT:20,21 邮件服务器12TCP_IN: 25,110,143,587,993,995TCP_OUT: 25,110 MySQL 服务器12TCP_IN: 3306TCP_OUT: 3306 进阶配置CSF 提供了大量的可配置项，最常用的列表如下： ICMP_IN: 设置为 1 时将允许外部主机 ping，设为 0 则禁止任何请求 ICMP_IN_LIMIT: 特定时间内允许同一 ip 地址的 ping 的请求数，通常不用修改，默认值为 1/s DENY_IP_LIMIT: 设置屏蔽 ip 地址的最大数量，保留太多数量会降低服务器性能 DENY_TEMP_IP_LIMIT: 与 DENY_IP_LIMIT 类似，但仅作用于临时屏蔽的 ip 地址 PACKET_FILTER: 过滤无效的，不需要的和非法的数据包 SYNFLOOD, SUNFLOOD_RATE 和 SYNFLOOD_BURST: 这三项提供了针对 SYN flood 攻击的保护，但会降低每个连接的初始化速度，仅当明确服务器正遭受攻击时启用该项 CONNLIMIT: 限制指定端口的并发连接数 如: 22;5;443;20 - 该值允许在 22 端口上最大 5 个并发连接数，在 443 端口上最大 20 个并发连接数 PORTFLOOD: 限制指定端口上单位时间内的最大连接数 如: 22;tcp;5;250 - 该值限制如果 22 端口上已有 5 个 tcp 连接，那么第 6 个来临的 tcp 连接将等待 250 秒，之后屏蔽解除，5 个新的 tcp 连接放行 其他设置在大多数情况都无需改动，如果确实需要自定义这些配置，阅读 /etc/csf/csf.conf 各项配置上的注释来了解其用途。 应用更改在应用更改前将第一项配置 TESTING = “1” 改为 TESTING = “0” 以使 csf 切换为工作模式。再以管理员权限执行 sudo csf -r 使更改生效。 屏蔽与允许 ip 地址防火墙最基础的功能是屏蔽，允许及忽略特定的 ip 地址，csf 可通过编辑 csf.deny, csf.allow 和 csf.ignore 文件来实现。 屏蔽 ip 地址使用编辑器打开 csf.deny1$sudo nano /etc/csf/csf.deny 每一行代表一条屏蔽项，可以是单一的 ip 地址，也可以是一个网段，例如：121.2.3.42.3.0.0/16 允许 ip 地址如果希望指定的 ip 地址或网段避开屏蔽和过滤扫描，可将它们加入到白名单列表，一旦将它们加入白名单，即便它们在 csf.deny 中已经存在，也会让它们绕过防火墙。 编辑 csf.allow 文件来加入白名单：1$sudo nano /etc/csf/csf.allow 忽略 ip 地址忽略名单与白名单的区别在于，忽略名单仅仅不进行过滤检查，但依然可能被加入黑名单中。1$sudo nano /etc/csf/csf.ignore 最后，执行 sudo csf -r 重载 csf 以使配置生效。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>security</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建 Ubuntu 16.04 LTS]]></title>
    <url>%2Flinux%2Flinux-setup-a-new-ubuntu-server%2F</url>
    <content type="text"><![CDATA[近年来云计算服务器越来越流行，在适当的时机准备一台拥有公网 ip 的云服务器以备不时之需。最近租用了一台预装 ubuntu 操作系统(这里选择 ubuntu 是因为笔者对其预装的工具集比较熟悉)的服务器之后，还要为这台服务器做一些额外的配置以使其能够在互联网环境中正常运行。很多云服务提供商都提供了适配不同需求的预装环境，但为了对服务器的搭建过程有一个直观的感觉和更多的控制权，决定亲手过一遍这个过程。 本篇文章涉及的所有指令细节可参考Linux 基础 - 用户管理 通常，配置一台裸机至少要完成以下几个步骤 新建群组 新建用户，并为其分配群组 配置 ssh 配置服务器安全策略 准备工作在开始配置之前，我们需要知道该服务器的以下信息： 服务器的公网 ip 地址 确认 22 端口打开 root 用户的初始密码 在 windows 系统下启动 PuTTy，使用 root 用户远程登录到该服务器 主机命名 hostname(可选的)如果不想修改云服务提供商默认分配的主机名，可跳过此步。 执行命令 hostname 显示当前主机名12$ hostnameVM-0-4 执行以下命令进行修改，修改完成后，再次执行命令以查看效果：123$sudo hostname &lt;your-new-hostname&gt;$ hostnameyour-new-hostname 新建群组 - groupadd执行如下命令新建一个带有 &lt;gid&gt; 的群组1$sudo groupadd &lt;your-new-group-name&gt; -g &lt;gid&gt; 新建用户 - useradd1$sudo useradd -u 2500 -m -c "FrostHe" -s -g sudo -G pango pango 该命令创建一个名为 pango 的用户，uid 为 2500，要求为该用户创建 Home 目录，使用预设值设置 shell 环境，加入初始群组 sudo，同时加入次要群组 pango。由于先前已经创建了群组，在创建该用户时就不会再创建与之同名的新的群组，而是将该用户加入到该群组下。 现在，新建用户 pango 还没有密码，设置密码之前是无法登录 shell 的，执行 passwd 来为新用户指定密码：123$sudo passwd pangoEnter new Unix Password:Retype new Unix Password: passwd 指令在不接参数时表示修改当前登录用户的密码 现在，退出 PuTTy 客户端，以新建用户名和密码登录，如果登录成功，则表明新用户创建无误。 配置服务器安全策略将云服务器的 22 端口暴露于互联网并允许 root 用户及一般用户以密码进行登录是不推荐的，特别是 root 帐号，一旦被攻击者破解那么服务器上的资源可任由其修改。为了使服务器免于这些危险，我们需要让这台服务器： 禁用 root 帐号密码登录，仅启用公钥认证 开启防火墙并限定端口 设置 ip 登录策略及 禁用密码登录并启用 ssh 公钥登录以新建用户登录系统，修改 sshd_config 文件：1234$sudo nano /etc/ssh/sshd_configPermitRootLogin noPublicAuthentication yesPasswordAuthentication no 该配置对 ssh 客户端远程登录作出限制：启用公钥认证并禁用密码认证，同时禁止 root 远程登录。 若要修改生效， sshd 进程需要重新读取该配置，但这会让已经通过密码登录的会话中断，并且在 public key 部署前没有任何机会重新进行远程连接，所以这一步放到最后来做。 接下来在新用户 Home 目录下的 .ssh/authorized_keys 文件中复制 openssh 格式的公钥值。 在 /etc/ssh/sshd_config 中有一行 AuthorizedKeyFiles，该行的默认值为 .ssh/authorized_keys，该项配置是 sshd 进程提取 public key 的依据，如果对该值进行了修改，那么这里新建的文件也必须要与之对应。 现在执行 sudo service sshd reload 以使配置生效。此时重新打开一个 PuTTy 客户端，使用新用户密码登录，将收到错误对话框：在 Putty 中设置对应的私钥路径，重试即可登录成功： 至此，一个基本的云服务器配置就完成了，有的云服务提供商推出了安全组功能，即从云端配置端口进出通道。更多安全配置查阅 为 Linux 系统配置 CSF。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>diy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git Module 与嵌套 Repository]]></title>
    <url>%2FVersion-Control%2FGit%2Fgit-embeded-repository%2F</url>
    <content type="text"><![CDATA[Git 可将一个 Git repository 作为另外一个 Git repository 的子目录，这允许在你的项目中引用另一个项目，并将两个项目分开维护。假设我们希望将一个现有的 Git repository 作为一个 submodule 添加到当前工作项目上，执行 git submodule add 并跟上绝对或相对 url 作为参数来添加 submodule。 Submodules 至少有两种应用场景： 项目依赖一个外部项目，并希望将两者分开维护 将一个大项目拆分为多个小项目并将它们黏合在一起 添加一个 Submodule1$ git submodule add https://github.com/chaconinc/DbConnector 默认情况下，submodules 将使用与 Git repository 一致的名称作为 directory 添加到当前项目的根目录下，在这个例子中为 “DbConnector”。也可以在命令最后指定一个自定义的路径作为该 submodule 的目录。 执行 git status，看到以下变化：123456789$ git statusOn branch masterYour branch is up-to-date with 'origin/master'.Changes to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) new file: .gitmodules new file: DbConnector 一个新的文件 .gitmodules 被创建了，该配置文件存储了当前项目与 submodule 之间的关系映射，以下是其内容举例：123[submodule "DbConnector"] path = DbConnector url = https://github.com/chaconinc/DbConnector 如果包含多个 submodule，那么该文件会有更多的 entry，值得注意的是，该文件一起受 git 版本控制。 作为 submodule 被管理的 Git repository 将不会受到父级 Git repository 的状态追踪。因此，在当前项目执行 git push origin master 之后，从另一台机器 git clone 父级项目时，将只包含 .gitmodules 文件及对应于各个 submodules 的空的 directory。123456789101112131415161718192021222324$ git clone https://github.com/chaconinc/MainProjectCloning into 'MainProject'...remote: Counting objects: 14, done.remote: Compressing objects: 100% (13/13), done.remote: Total 14 (delta 1), reused 13 (delta 0)Unpacking objects: 100% (14/14), done.Checking connectivity... done.$ cd MainProject$ ls -latotal 16drwxr-xr-x 9 schacon staff 306 Sep 17 15:21 .drwxr-xr-x 7 schacon staff 238 Sep 17 15:21 ..drwxr-xr-x 13 schacon staff 442 Sep 17 15:21 .git-rw-r--r-- 1 schacon staff 92 Sep 17 15:21 .gitmodulesdrwxr-xr-x 2 schacon staff 68 Sep 17 15:21 DbConnector-rw-r--r-- 1 schacon staff 756 Sep 17 15:21 Makefiledrwxr-xr-x 3 schacon staff 102 Sep 17 15:21 includesdrwxr-xr-x 4 schacon staff 136 Sep 17 15:21 scriptsdrwxr-xr-x 4 schacon staff 136 Sep 17 15:21 src$ cd DbConnector/$ ls$ 要获得与提交之前的 submodules，一种方式是执行 git submodule init 指令来初始化本地配置和 git submodule update 从 submodules 对应的地址 clone 所有数据并签出对应的 commit。12$ git submodule init$ git submodule update 或者：1git submodule update --init --recursive 另外一种方式是在执行 git clone 父级项目时添加 --recurse-submodules 参数，将一次完成父级项目及所有 submodules 的克隆1$ git clone --recurse-submodules https://github.com/chaconinc/MainProject 之后，如果希望同父级项目一同获取所有 submodules 的更新，执行1git pull --recurse-submodules 获取子项目更新使用 Git Submodules 一个最典型的应用场景是，引用一个由外部维护的 Git repository，仅仅使用它而不做任何修改。 首先导航到指定 submodule 所在目录，执行 git fetch 和 git merge 获取本地更新。12345678910$ git fetchFrom https://github.com/chaconinc/DbConnector c3f01dc..d0354fc master -&gt; origin/master$ git merge origin/masterUpdating c3f01dc..d0354fcFast-forward scripts/connect.sh | 1 + src/db.c | 1 + 2 files changed, 2 insertions(+) 回到父级项目目录，执行 git diff --submodule，可以看到 submodules 已经获得更新并列出一个添加到该项目的 commit 列表。如果不想每次在执行 git diff 时都输入 --submodule 参数，可在 git config 文件中添加该命令的默认参数或执行 git config diff.submodule log，之后再执行 diff 将会将列出所有子项目更新日志。12345$ git config --global diff.submodule log$ git diffSubmodule DbConnector c3f01dc..d0354fc: &gt; more efficient db routine &gt; better connection routine 此时如果主项目提交至远程 Git repository，之后其他开发人员再获取代码时将会得到与主项目同步后的 submodule。 另外一种方式是直接在主项目目录下执行 git submodule update --remote 命令，git 将自动更新所有 submodules。12345678$ git submodule update --remote DbConnectorremote: Counting objects: 4, done.remote: Compressing objects: 100% (2/2), done.remote: Total 4 (delta 2), reused 4 (delta 2)Unpacking objects: 100% (4/4), done.From https://github.com/chaconinc/DbConnector 3f19983..d0354fc master -&gt; origin/masterSubmodule path 'DbConnector': checked out 'd0354fc054692d3906c85c3af05ddce39a1c0644' 该命令将默认以所有 submodules 的 master branch 作为更新依据，如何以另外一个 branch name 作为默认更新的依据，参考下文的Git Module 可在 git config 文件中为 status 命令添加默认参数或执行 git config status.submodulesummary 1，之后执行 git status 显示简短的摘要1234567891011121314151617$ git config status.submodulesummary 1$ git statusOn branch masterYour branch is up-to-date with 'origin/master'.Changes not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: .gitmodules modified: DbConnector (new commits)Submodules changed but not updated:* DbConnector c3f01dc...c87d55d (4): &gt; catch non-null terminated lines Git Modulesubmodule 是嵌套在另一个 repository 中的 repository，submodule 有自己的版本历史，包含子模块的 repository 称为 superproject .gitmodules 放置在一个 Git 工作树的顶级目录下，该文件是一个匹配 git-config 的文本文件。该文件的每个 subsection 代表一个 submodule 的配置项，subsection 的值为 submodule 的名称，如果不显式指定 name 选项，该名称值将取该 submodule 的路径作为名称。同时，每一个 subsection 包含以下必填值： submodule.&lt;name&gt;.path: 相对于 Git working tree 顶层目录的路径，默认迁出位置，该值不能以 / 结尾，所有 submodule 的路径必须唯一。 submodule.&lt;name&gt;.url: 克隆 submodule 的 url，该值可以是一个绝对 url，也可以 ./ 或 ../ 起头作为 superproject origin repository 的相对 url。 同时，还有以下可选参数： submodule.&lt;name&gt;.update: 定义 submodue 的默认更新行为，在 superproject 执行 git submodule update 指令时如何更新 submodule.&lt;name&gt;.branch: 提供用于检测更新的 branch 名称，如果不指定该值，默认取 master。. 作为特殊值告知 git 取与当前 repository 当前 branch 一致的名称 submodule.&lt;name&gt;.fetchRecurseSubmodules: 该用于控制对 submodule 的递归 fetch，如果在 superproject 的 .git/config 中已经设置了该值，那么该值将覆盖在 .gitmodules 中的值。两者均可被 git fetch 和 git pull 使用 --[no-]recurse-submodules 选项覆盖 submodule.&lt;name&gt;.ignore: git status 和比较器如何对已经做出修改的 submodules 进行反应，可取以下值 all: submodule 永远不会被认为已经 modified，但在 staged 后会显示出来 dirty: 所有对 submodule 工作目录下做出的修改将被忽略，只有其 Head 与 superproject 的记录状态会纳入考虑 untracked: 只有 untracked 文件会被忽略 none: 所有修改都不会被忽略 submodule.&lt;name&gt;.shallow: 当设置为 true 时，该 submodule 会执行浅 clone(只包含一层深度的历史信息) 例子：123[submodule "libfoo"] path = include/foo url = git://foo.com/git/lib.git 文件系统中，一个 submodule 通常 在 superproject 的 $GID_DIR/modules/ 有一个 Git 目录 在 superproject 工作目录下有一个对应的子目录作为其工作目录 在其工作目录中根目录下包含一个 .git 文件指向 (1) 所在的位置 假设一个 submodule 的 Git 目录位于 $GIT_DIR/modules/foo/，工作目录位于 path/to/bar/，superproject 通过一个 path/to/bar/ 目录树下的 gitlink 和 .gitmodules 文件中的一个条目 submodule.foo.path = path/to/bar 来追踪这个 submodule。 参考资料： https://git-scm.com/book/en/v2/Git-Tools-Submodules https://git-scm.com/docs/gitmodules https://git-scm.com/docs/gitsubmodules]]></content>
      <categories>
        <category>Version Control</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 基础 - 用户和群组管理]]></title>
    <url>%2Flinux%2Flinux-account-management%2F</url>
    <content type="text"><![CDATA[Linux 使用文件及配置相应的权限来存储用户帐号和群组信息，在成功创建好用户帐号之后，以下几处文件会发生相应的改变 /etc/passwd: Linux 管理用户帐号的数据库 /etc/shadow: Linux 管理用户帐号密码配置的数据库 /etc/group: Linux 管理群组的数据库 /etc/gshadow: Linux 管理群组密码配置的数据库 用户帐号管理Linux 系统用户管理相关命令主要有： useradd：新建用户 passwd：设置用户密码 chage: 变更密码策略 usermod：编辑用户 userdel：删除用户 新建用户帐号 - useraddlinux 系统以 useradd 命令来新建 Unix 用户，该命令带有一系列参数： 12345678910111213useradd [-u UID] [-g 初始群组] [-G 次要群组] [-mM] [-c 说明栏] [-d 家目录绝对路径] [- s shell] &lt;new-user-name&gt;-u ：接 UID ，一组数字，直接指定一个特定的 UID 给这个用户-g ：为该用户指定初始群组 initial group，该群组的 GID 会被放置到/etc/passwd 的第四个栏位-G ：为该用户指定次要群组，该选项与参数会修改 /etc/group 内第四栏的值-M ：不要为用户建立 Home 目录(系统帐号预设值)-m ：为用户建立 Home 目录(一般帐号预设值)-c ：用户备注，该值修改 /etc/passwd 文件的第五栏的内容-d ：指定特定目录成为该用户的 Home 目录，而不采用预设值，需指定绝对路径-r ：建立一个系统帐号，该帐号的 UID 会有限制(参考/etc/login.defs)-s ：指定 `shell` ，若不指定则预设为 /bin/bash-e ：指定该用户的过期日期，格式为『YYYY-MM-DD』此项写入 `/etc/shadow` 第八栏-f ：指定密码是否立即失效，写入 /etc/shadow 的第七栏位。0 为立刻失效，-1 为永远不失效(密码只会过期而强制于登入时重新设定而已) 例如，执行以下命令新建一个用户：1$sudo useradd pango 该命令创建一个名为 pango 的用户，由于没有使用 -r 指令，将随机分配一个 1000 以上的数值作为 uid，创建一个名为 pango 的群组并作初始群组，为该用户创建 Home 目录，使用 /bin/bash 作为工作环境。该命令对系统的以下部分做出修改： 在 /etc/passwd 里面新建一行用户值，包含 UID/GID/Home 目录等； 在 /etc/shadow 里面将此用户的密码相关参数填入，但是尚设置密码； 在 /etc/group 里面加入一个与用户名称一样的群组名称，如果已经存在与该用户名同名的群组名，则不会新建群组 在 /home 目录下新建一个与帐号同名的目录作为用户的 Home 目录，且权限为 700 注意，在 linux 系统中新增用户帐号和群组时，名称是区分大小写的 useradd 指令参考 /etc/defaults/useradd 文件中的配置作为缺省参数的预设值，使用 useradd -D 指令查看预设值：12345678$ useradd -DGROUP=100 # 预设的群组，系统内 GID = 100 的群组为 users 群组，但目前很多发行版都采用私有群组制，即为每个新建的用户帐号创建与之同名的群组来隔离权限HOME=/home # 预设的 Home 目录INACTIVE=-1 # 密码失效日期，对应 /etc/shadow 第 7 栏EXPIRE= # 用户帐号失效日，对应 /etc/shadow 第 8 栏SHELL=/bin/sh # 默认使用的 shell 程序名，如果 server 不希望任何新建的用户帐号登入系统取得 shell，那么将此项改为 /sbin/nologinSKEL=/etc/skel # Home 目录初始内容参考目录，即为新建用户创建 Home 目录时需要复制的初始内容，例如，在该目录下新增 www 目录，那么后续每个创建的新用户 Home 目录都会有 www 目录CREATE_MAIL_SPOOL=no # 是否主动帮用户建立邮件信箱，如果该项为 yes，则会新建 /var/spool/mail/&#123;username&#125; 目录作为该用户的邮箱 使用 nano 或 vim 查看 /etc/default/useradd 文件可以得到更多的详细信息：1$ nano /etc/default/useradd 登录信息参考在 /etc/login.defs 文件中定义，使用 nano 查看该文件123456789101112131415161718192021$ nano /etc/login.defsMAIL_DIR /var/spool/mail # 用户预设邮件信箱放置目录PASS_MAX_DAYS 99999 # /etc/shadow 内的第 5 栏，多久需变更密码日数 PASS_MIN_DAYS 0 # /etc/shadow 内的第 4 栏，多久不可重新设定密码日数 PASS_MIN_LEN 5 # 密码最短字符长度，已被 pam 模组取代PASS_WARN_AGE 7 # /etc/shadow 内的第 6 栏，过期前会警告的日数UID_MIN 1000 # 用户最小的 UID，意即小于 1000 的 UID 为系统保留 UID_MAX 60000 # 用户能够用的最大 UID SYS_UID_MIN 201 # 保留给用户自行设定的系统帐号最小值 UID SYS_UID_MAX 999 # 保留给用户自行设定的系统帐号最大值 UID GID_MIN 1000 # 用户自订群组的最小 GID，小于 1000 为系统保留 GID_MAX 60000 # 用户自订群组的最大 GID SYS_GID_MIN 201 # 保留给用户自行设定的系统帐号最小值 GID SYS_GID_MAX 999 # 保留给用户自行设定的系统帐号最大值 GIDCREATE_HOME yes # 在不加 -M 及 -m 时，是否主动建立用户家目录UMASK 077 # 用户 Home 目录建立的 umask ，因此权限会是 700 USERGROUPS_ENAB yes # 使用 userdel 删除时，是否删除初始群组 ENCRYPT_METHOD SHA512 # 密码加密的机制使用的是 sha512 加密算法 所以，系统在执行 useradd 命令时至少会参考： /etc/default/useradd /etc/login.defs /etc/skel/* 现在查看 /etc/passwd 档案的最后一行：1pango:x:1000:1000::/home/pango:/bin/bash 该文件是存放所有用户信息的数据库，每一行代表一个用户，每行由 6 个 : 分隔成了 7 个栏位： 用户名 密码 用户 UID：0 保留给系统管理员 root 账号；1~999 保留给系统账号，这些账号通常为执行某些系统服务所用，不能通过 shell 登录；1000~4294967295，保留给一般账号 用户初始群组 GIP 备注 Home 目录，预设值为 /home/{username} 执行 Shell 的程序目录，预设值为 /bin/bash 设置帐号密码 - passwd现在，新建的用户 pango 还没有密码，在设置密码之前是无法登录的，执行 passwd 来为新用户指定密码：12345678910111213141516$ passwd [--stdin] [帐号名称] # 所有人均可使用来改自己的密码 $ passwd [-l] [-u] [--stdin] [-S] [-n 日数] [-x 日数] [-w 日数] [-i 日数] 帐号 # root 功能选项与参数：--stdin ：可以透过来自前一个管线的资料，作为密码输入，对 shell script 有用-l ：是 Lock 的意思，会将 /etc/shadow 第 2 栏最前面加上 '!' 使密码失效；-u ：与 -l 相对，是 Unlock 的意思-S ：列出密码相关参数，亦即 shadow 档案内的大部分信息-n ：自上一次修改密码后的密码不可修改天数，shadow 的第 4 栏位-x ：自上一次修改密码后的密码有效天数，shadow 的第 5 栏位-w ：密码过期前的警告天数，shadow 的第 6 栏位-i ：密码失效缓冲天数，shadow 的第 7 栏位$sudo passwd pangoEnter new Unix Password:Retype new Unix Password: passwd 指令在不接参数时表示修改当前登录用户的密码 密码设置成功后，在 /etc/shadow 文件中发生了一些改变，定位到该文件的最后一行：1pango:$6$csIys5qj$OslSKU.3SljbHXTXJEPgWvNi1w9CGlBKO3uqJyWueQN1ypA7SuNzJWjesdSvg6KPv0X6tRmkkDBFI2cbSJ.xR/:17600:0:99999:7::: 该文件存储了所有用户的密码相关配置，每一行代表一个用户的密码信息，每行由 8 个 : 分隔为 9 个栏位： 用户名 经过加密的密码 最近修改密码日期，该值为一个代表 day 的数值，从 1970-01-01 日算起 密码不可修改天数：该值指示密码在最近一次修改后多久之后才能再次被修改 密码有效期（天）：该值指示密码再最近一次修改后的有效天数 密码需要变更前的警告天数 密码失效延迟（天）：密码过期后的缓冲时间 账号失效日期（天）：该值指示该用户的总生命周期多长，与密码有效无效无关 系统保留扩展项： 通过标准输入 --stdin 来修改密码，例如，帮助 pango 用户将其密码修改为 ‘abc543CC’ 123$ echo "abc543CC" | passwd --stdin pangoChanging password for user pango.passwd: all authentication tokens updated successfully. --stdin 选项并不存在于所有 Linux 发行版本的系统中，使用前先 man passwd 查看是否支持 管理帐号密码策略 - chage除了使用 passwd 指令，还可以使用 chage 指令来管理密码策略，其用法大致如下：123456789$ chage [-ldEImMW] 用户帐号名选项与参数：-l ：列出该帐号的详细密码参数；-d ：修改 shadow 第 3 栏位(最近一次更改密码的日期)，格式 YYYY-MM-DD-E ：修改 shadow 第 8 栏位(帐号失效日)，格式 YYYY-MM-DD-I ：修改 shadow 第 7 栏位(密码失效日期)-m ：修改 shadow 第 4 栏位(密码最短保留天数)-M ：修改 shadow 第 5 栏位(密码多久需要进行变更)-W ：修改 shadow 第 6 栏位(密码过期前警告日期) passwd -S 只是简单显示了密码详情，而 chage -l 更多为管理员提供了更强的参考信息，列出 pango 的详细密码参数 ：12345678$ chage -l pangoLast password change : Jul 20, 2015Password expires : Sep 18, 2015Password inactive : Sep 28, 2015Account expires : neverMinimum number of days between password change : 0Maximum number of days between password change : 60Number of days of warning before password expires : 7 修改用户帐号信息 - usermod当需要修改用户帐号的信息时，我们可以通过前往相应的文件例如，/etc/passwd 和 /etc/shadow 中去修改对应行的值以达到修改用户帐号信息的目的。也可以使用 usermod 指令对用户帐号进行修改：1234567891011121314$ usermod [-cdegGlsuLU] username 选项与参数：-c ：修改用户备注，对应 /etc/passwd 第 5 栏-d ：修改帐号 Home 目录，对应 /etc/passwd 的第 6 栏；-e ：修改帐号失效日期，格式是 YYYY-MM-DD，对应 /etc/shadow 内的第 8 栏-f ：修改密码失效延迟时间，对应 shadow 的第 7 栏。-g ：修改初始群组，修改 /etc/passwd 的第 4 栏-G ：修改次要群组组，修改该用户支援的群组，修改应用到 /etc/group-a ：与 -G 合用，表示 append，追求次要群组而非改变-l ：修改帐号名称， /etc/passwd 的第 1 栏-s ：修改 shell 接入程序，后面接 Shell 的实际程序，例如 /bin/bash 或 /bin/csh 等等-u ：修改 uid 对应 /etc/passwd 第 3 栏-L ：暂时锁定用户，暂时无法登入。仅修改 /etc/shadow 的密码栏。-U ：解锁用户，移除 /etc/shadow 密码栏的 '!' 删除用户帐号 - userdel当需要删除用户帐号时，执行 userdel 命令，该命令会对以下文件造成影响： 用户帐号/密码相关值：/etc/passwd，/etc/shadow 用户群组相关参数：/etc/group，/etc/gshadow 用户个人资料目录：/home/{username}，/var/spool/mail/{username} 该指令用法如下：123$ userdel [-r] username 选项与参数：-r ：连同用户的 Home 目录也一起删除 例如，删除 pango 用户帐号及其 Home 目录：1$sudo userdel -r pango 通常，在移除一个帐号时，我们可以手动修改 /etc/passwd 和 /etc/shadow 文件中该用户关联的行数据。如果该帐号只是暂时冻结，那么将 /etc/shadow 中第 8 栏（帐号失效日）设为 0 就可让该账户无法使用，但所有与该帐号相关的资料都会保留，使用 userdel 意味着真的确定该用户不会在主机上的使用任何资料了。 通常，一个用户在使用主机一段时间之后，会在更多其他的目录中产生属于他的文档，因此，在下达 userdel -r username 之前，先以 find / -user username 指令查出整个系统内属于 username 的档案，删除之后，再删除该用户帐号。 用户端指令 - id, finger, chfn, chshuseradd，usermod，userdel 都是系统管理员才能使用的命令，一般用户无法进行操作，有以下几个指令供一般用户使用： id: 该指令可以查询当前用户或其他用户的 UID/GID 值 finger: 查询用户的口令信息，将有 Login: 用户帐号信息 Name: 备注信息 Directory: Home 目录 Shell: shell 对应的程序 Never logged in: 登入信息 No mail: 查看 /var/spool/mail 中的信箱资料 No Plan: 查看 ~{username}/.plan 资料 chfn: 修改指纹信息，不常用 chsh: 修改 shell，参数如下： -l，列出所有可用的 shell，即 /etc/shells 中的内容 -s，修改为指定的 shell 群组管理群组管理涉及新增，修改和删除，群组的内容与以下两个档案有关： /etc/group /etc/gshadow 新增群组 - groupadd使用 groupadd 来新增群组，该命令使用方法如下：1234$ groupadd [-g gid] [-r] 群组名称选项与参数：-g ：指定群组 GID-r ：指定该群组为系统群组，与 /etc/login.defs 内的 GID_MIN 有关 执行命令查看新建的群组：123$ nano /etc/group...&lt;your-new-group-name&gt;:x:&lt;gid&gt;: 该命令查询 /etc/group 文件，该文件是 linux 系统保存所有群组的数据库，每一行代表一个群组，每行的值由 3 个 : 分隔为 4 栏不同的值，其具体指： 群组名称 群组密码，以 x 表示，引用 /etc/gshadow 的第 2 栏 群组 id 该群组包含的用户名称，每个用户名称由 , 分隔 x 表示该群组的密码，其在 /etc/gshadow 文件中对应第 2 栏的值，gshadow 文件保存了所有群组的详细配置，但只有拥有 root 权限的用户才能查看该文件。由于该群组刚刚创建，没有指定任何用户，故该值为空。 查看 /etc/gshadow 文件可以看到对应的行，其格式如下：1&lt;your-new-group-name&gt;:!::usernames 这个文件内的格式几乎与 /etc/group 一摸一样，第 2 栏是密码栏，如果密码栏为 ‘!’ 或空，表示该群组不具有群组管理员： 群组名称 密码栏，若为 ‘!’ 表示无合法密码，无群组管理员 群组管理员的帐号 所有加入该群组的帐号，与 /etc/group 内容相同 修改群组 - groupmod与 usermod 类似，groupmod 指令用于对已有群组的信息进行修改1234$ groupmod [-g gid] [-n group_name] 群组名选项与参数：-g ：修改既有的 GID 值；-n ：修改既有的群组名称 一个群组创建之后，为了避免引起不必要的错乱，通常不建议随意修改其 GID 删除群组 - groupdel1groupdel [groupname] 使用 groupdel 来删除已有的群组，如果有用户帐号已经关联一个群组作为其初始群组，将无法直接删除该群组，否则当用户登入系统后，系统将找不到其对应的群组。想要删除该群组，必须： 修改与之关联的用户的初始群组 删除该用户，再删除群组 群组管理员 - gpasswd1234567891011$ gpasswd groupname $ gpasswd [-A user1,...] [-M user3,...] groupname $ gpasswd [-rR] groupname 选项与参数：若没有任何参数时，表示给予 groupname 一个密码(/etc/gshadow)-A ：将 groupname 的主控权交由参数代表的多个用户管理(该群组的管理员)-M ：将某些帐号加入这个群组当中！-r ：将 groupname 的密码移除-R ：让 groupname 的密码栏失效-a ：将用户加入到 groupname 这个群组中-d ：将用户移除 groupname 这个群组中 初始群组，次要群组和有效群组在执行 useradd 命令新建用户时，使用 -g 命令指定初始群组，该群组的 GID 被写入到 /etc/passwd 对应的 GID 栏位，而 -G 指定的次要群组则将用户名写入 /etc/group 第 4 栏。 当用户登入系统进入 shell 环境后，系统总是以该用户所在的初始群组作为有效群组，即，当用户执行类似 touch 的指令创建新的文件或文件夹时，其权限会给予用户当前的有效群组。执行 groups 可查看当前登录用户所属的所有群组，排在第一位的即表示当前有效群组。 可通过执行 newgrp 指令将用户所属的另一个群组切换为当前有效群组，该动作导致用户进入另一个 shell 环境，当用户完成操作不再需要该群组支持时，应使用 exit 指令退回到之前的 shell 环境。 参考资料：http://linux.vbird.org/linux_basic/0410accountmanager.php]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于我的博客]]></title>
    <url>%2Fdiary%2Fabout%2F</url>
    <content type="text"><![CDATA[自成为程序员以来，就养成了记笔记的习惯，很多细节问题当时解决了，大多数时候是以某种 workaround 的方式解决的，如果问题的根源没有找准，那么以后遇到又会 repeat yourself。虽然记笔记一度花掉很多时间，但它能够帮助自己对遇到的问题以及寻求解决途径的过程进行梳理，在这个过程中，也能训练自己对表达和记录某件事的思路，进而加深理解并巩固印象。同时，这也为所有不同种类的信息提供了一个统一的入口进行查阅。 最近，用了两年的 WizNote 又到期了，借着这个契机，便有了自建博客的想法。 我想在这里写下所有我认为有价值的内容，其中可能包括某个技术的备忘要点，某些技术的深入探索，读书笔记，和日常工作中遇到的问题。这些内容将主要涵盖： .NET 技术生态 Web 技术生态 数据库技术栈 架构设计与模式 Linux 学习与心得 自己 diy 的一些过程 这里的内容主要是给我自己看，但又不像私人日记那么随意。大部分内容是从以往的云笔记经过重新梳理搬移过来，我保持了与当时一致的创建日期，在搬移和记录过程中我也会随时调整文件的分类和标签，以使其符合某种逻辑进行组织。 总之，我暂时想象不出这个站点日后会变成什么样子。希望今后某一天我回看这些内容的时候，会欣慰的发现原来自己已经学到了这么多东西，并且能够追寻这些文字找到来时的路。]]></content>
      <categories>
        <category>diary</category>
      </categories>
  </entry>
</search>
