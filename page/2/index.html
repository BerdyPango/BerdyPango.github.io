<!DOCTYPE html>




<html class="theme-next mist" lang="default">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="google-site-verification" content="K2S73UudyU-JTh9S0U_KnOKgOvE7aW7EpO560okLyUU" />




















<link href="/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="//main.css?v=" rel="stylesheet" type="text/css" />









  <meta name="keywords" content="Developer, Frost He" />










<meta name="description" content="Stay hungry, stay foolish">
<meta property="og:type" content="website">
<meta property="og:title" content="FrostHe.Handbook">
<meta property="og:url" content="https://berdypango.github.io/page/2/index.html">
<meta property="og:site_name" content="FrostHe.Handbook">
<meta property="og:description" content="Stay hungry, stay foolish">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="FrostHe.Handbook">
<meta name="twitter:description" content="Stay hungry, stay foolish">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '',
    sidebar: {"display":"hide"},
    fancybox: ,
    tabs: ,
    motion: {"enable":false},
    duoshuo: {
      userId: 'undefined',
      author: 'Author'
    },
    algolia: {
      applicationID: 'ZL78UP9TUE',
      apiKey: '',
      indexName: 'FrostHe.Handbook',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>







  <title>FrostHe.Handbook</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-125853342-1', 'auto');
  ga('send', 'pageview');
</script>





</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  

  <div class="container  
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">FrostHe.Handbook</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="Searching..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://berdypango.github.io/aspnetcore-filters/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Frost He">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FrostHe.Handbook">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/aspnetcore-filters/" itemprop="url">ASP.NET Core 应用 - Filters</a></h1>
        

        <div class="post-meta">
          
          <span class="post-time">
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  2,636
                </span>
              

              

              
            </div>
          

          
              <div class="post-description">
                  ASP.NET Core 过滤器的最佳实践，阅读微软官网文档的摘抄和心得
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>参考资料:</p>
<ul>
<li><a href="https://docs.microsoft.com/en-us/aspnet/core/mvc/controllers/filters?view=aspnetcore-2.1" target="_blank" rel="noopener">Filters in ASP.NET Core</a></li>
</ul>
<h2 id="过滤器类型"><a href="#过滤器类型" class="headerlink" title="过滤器类型"></a>过滤器类型</h2><p>每个过滤器类型都将在管道的不同阶段被执行:</p>
<ul>
<li>Authorization 过滤器: <strong>第一个</strong>运行的过滤器，决定执行请求的当前用户是否被授权。</li>
<li>Resource 过滤器: 紧随 Authorization 过滤器之后处理请求的过滤器，其代码在管道的其余部分之前或之后被执行，它们是实现缓存或因性能原因阻塞请求的最佳位置，它们在「Model Binding」之前运行，所以其代码可以影响模型绑定。</li>
<li>Action 过滤器: 在特定的 Action 之前或之后运行的过滤器，它们被用于操作传入 Action 的参数以及被其返回的结果。</li>
<li>Exception 过滤器: 用于将全局策略应用于在返回响应之前未被捕获的异常。</li>
<li>Result 过滤器: 在 Action 返回结果之前或之后执行代码，仅当 Action 方法成功之后才会运行，它们被用于处理必须围绕视图的逻辑。</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p><strong>过滤器通过定义不同的接口</strong>支持同步及异步实现。同步实现以 On<em>Stage</em>Executing 和 On<em>Stage</em>Executed 方法为模板，例如 <code>OnActionExecuting</code> 在方法执行之前运行，<code>OnActionExecuted</code> 在方法执行之后运行。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> FiltersSample.Helper;</span><br><span class="line"><span class="keyword">using</span> Microsoft.AspNetCore.Mvc.Filters;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">FiltersSample.Filters</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SampleActionFilter</span> : <span class="title">IActionFilter</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnActionExecuting</span>(<span class="params">ActionExecutingContext context</span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">// do something before the action executes</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnActionExecuted</span>(<span class="params">ActionExecutedContext context</span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">// do something after the action executes</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>异步过滤器定义一个 On<em>Stage</em>ExecutionAsync 方法，该方法接收一个 <code>FilterTypeExecutionDelegate</code> 委托参数 <code>next</code>，<code>next</code> 参数代表 <code>Action</code> 本身，可在其之前或之后添加扩展逻辑:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> Microsoft.AspNetCore.Mvc.Filters;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">FiltersSample.Filters</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SampleAsyncActionFilter</span> : <span class="title">IAsyncActionFilter</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">OnActionExecutionAsync</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">            ActionExecutingContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">            ActionExecutionDelegate next</span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">// do something before the action executes</span></span><br><span class="line">            <span class="keyword">var</span> resultContext = <span class="keyword">await</span> next();</span><br><span class="line">            <span class="comment">// do something after the action executes; resultContext.Result will be set</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>过滤器的同步和异步接口版本只要实现一个就够了，框架会首先检查过滤器类型是否实现了异步接口，如果是，则执行异步版本。否则，才会执行同步版本。如果同时实现了两个接口，则同步接口会被忽略。</p>
</blockquote>
<h3 id="IFilterFactory"><a href="#IFilterFactory" class="headerlink" title="IFilterFactory"></a>IFilterFactory</h3><p><code>IFilterFactory</code> 实现了 <code>IFilterMetaData</code> 接口，所以 <code>IFilterFactory</code> 可以当作 <code>IFilterMetaData</code> 接口的实例在管道的任何地方使用。当框架准备调用 <code>Filter</code> 时，首先尝试将其转换成 <code>IFilterFactory</code> 接口，如果转换成功，接下来调用接口的 <code>CreateInstance</code> 方法以构造 <code>IFilterMetaData</code> 实例，这种设计更加灵活，因为不必在应用程序启动时显式指定具体的 <code>Filter</code> 类型。可以在自定义的 <code>Attribute</code> 上实现 <code>IFilterFactory</code> 接口以另一种方式创建 <code>Filter</code>:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class AddHeaderWithFactoryAttribute : Attribute, IFilterFactory</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Implement IFilterFactory</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IFilterMetadata <span class="title">CreateInstance</span>(<span class="params">IServiceProvider serviceProvider</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> InternalAddHeaderFilter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title">InternalAddHeaderFilter</span> : <span class="title">IResultFilter</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnResultExecuting</span>(<span class="params">ResultExecutingContext context</span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            context.HttpContext.Response.Headers.Add(</span><br><span class="line">                <span class="string">"Internal"</span>, <span class="keyword">new</span> <span class="keyword">string</span>[] &#123; <span class="string">"Header Added"</span> &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnResultExecuted</span>(<span class="params">ResultExecutedContext context</span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">bool</span> IsReusable</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="框架内置过滤器特性-Filter-Attribute"><a href="#框架内置过滤器特性-Filter-Attribute" class="headerlink" title="框架内置过滤器特性 Filter Attribute"></a>框架内置过滤器特性 Filter Attribute</h3><p>框架包含了可继承或自定义的内置 <code>attribute-based</code> 形式的 <code>Filter</code>。例如以下 <code>ResultFilter</code> 在响应头添加了一个 <code>Header</code>。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Microsoft.AspNetCore.Mvc.Filters;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">FiltersSample.Filters</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AddHeaderAttribute</span> : <span class="title">ResultFilterAttribute</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="keyword">string</span> _name;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="keyword">string</span> _value;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">AddHeaderAttribute</span>(<span class="params"><span class="keyword">string</span> name, <span class="keyword">string</span> <span class="keyword">value</span></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            _name = name;</span><br><span class="line">            _value = <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnResultExecuting</span>(<span class="params">ResultExecutingContext context</span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            context.HttpContext.Response.Headers.Add(</span><br><span class="line">                _name, <span class="keyword">new</span> <span class="keyword">string</span>[] &#123; _value &#125;);</span><br><span class="line">            <span class="keyword">base</span>.OnResultExecuting(context);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>特性允许 <code>Filter</code> 接收参数，在上面的例子中，可以用该 <code>Attribute</code> 修饰一个 <code>Controller</code> 或 <code>Action</code> 方法并指定 <code>Http Header</code> 的名称。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">AddHeader(<span class="meta-string">"Author"</span>, <span class="meta-string">"Steve Smith @ardalis"</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SampleController</span> : <span class="title">Controller</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IActionResult <span class="title">Index</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Content(<span class="string">"Examine the headers using developer tools."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">ShortCircuitingResourceFilter</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IActionResult <span class="title">SomeResource</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Content(<span class="string">"Successful access to resource - header should be set."</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br><code>Index</code> Action 的结果如下:<br><img src="/aspnetcore-filters/01.png" title="响应头中添加了 Header"></p>
<p>Filter 特性:</p>
<ul>
<li>ActionFilterAttribute</li>
<li>ExceptionFilterAttribute</li>
<li>ResultFilterAttribute</li>
<li>FormatFilterAttribute</li>
<li>ServiceFilterAttribute</li>
<li>TypeFilterAttribute</li>
</ul>
<p><code>TypeFilterAttribute</code> 和 <code>ServiceFilterAttribute</code> 将在后文介绍。</p>
<h2 id="Filter-应用级别和执行顺序"><a href="#Filter-应用级别和执行顺序" class="headerlink" title="Filter 应用级别和执行顺序"></a>Filter 应用级别和执行顺序</h2><p>过滤器可以以三种级别应用 - 以 Attribute 的形式应用在特定的 <code>Action</code> 或 <code>Controller</code> 类上。或者在 <code>ConfigureServices</code> 方法中配置 <code>MvcOptions.Filters</code> 以全局方式应用到所有 <code>Action</code> 和 <code>Controller</code> 上。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    services.AddMvc(options =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        options.Filters.Add(<span class="keyword">new</span> AddHeaderAttribute(<span class="string">"GlobalAddHeader"</span>, </span><br><span class="line">            <span class="string">"Result filter added to MvcOptions.Filters"</span>)); <span class="comment">// an instance</span></span><br><span class="line">        options.Filters.Add(<span class="keyword">typeof</span>(SampleActionFilter)); <span class="comment">// by type</span></span><br><span class="line">        options.Filters.Add(<span class="keyword">new</span> SampleGlobalActionFilter()); <span class="comment">// an instance</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    services.AddScoped&lt;AddHeaderFilterWithDi&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>多个内置的 <code>Filter</code> 接口都实现了对应的 Attribute 用于继承以支持自定义实现。</p>
<h3 id="过滤器的默认执行顺序"><a href="#过滤器的默认执行顺序" class="headerlink" title="过滤器的默认执行顺序"></a>过滤器的默认执行顺序</h3><p>当管道中多处都应用了过滤器，scope 决定了过滤器的默认执行顺序。该序列看来如下:</p>
<ul>
<li>全局过滤器的 before 部分<ul>
<li>Controller 级别过滤器的 before 部分<ul>
<li>Action 方法级别过滤器的 before 部分</li>
<li>Action 方法级别过滤器的 after 部分</li>
</ul>
</li>
<li>Controller 级别过滤器的 after 部分</li>
</ul>
</li>
<li>全局过滤器的 after 部分</li>
</ul>
<blockquote>
<p>所有继承自 <code>Controller</code> 类型的控制器都包含 <code>OnActionExecuting</code> 和 <code>OnActionExecuted</code> 方法。这些方法先于任何应用其上的过滤器的 <code>OnActionExecuting</code> 方法并且后于 <code>OnActionExecuted</code> 方法。</p>
</blockquote>
<h3 id="重写默认顺序"><a href="#重写默认顺序" class="headerlink" title="重写默认顺序"></a>重写默认顺序</h3><p>可以通过实现 <code>IOrderedFilter</code> 接口来重写过滤器的默认执行顺序。该接口暴露一个 <code>Order</code> 属性先与过滤器的应用级别来影响执行顺序。<code>Order</code> 的属性值越低，其 before 部分代码先执行，after 部分后执行。</p>
<h2 id="取消和短路"><a href="#取消和短路" class="headerlink" title="取消和短路"></a>取消和短路</h2><p>通过在 <code>context</code> 上设置 <code>Result</code> 属性可以在任何点上短路管道。</p>
<h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><p>过滤器以服务的形式注册到 IoC，但实现为 <code>Attribute</code> 的过滤器无法通过依赖注入的方式获取构造器参数，这是因为 <code>Attribute</code> 类型的构造器参数必须在使用时指定，这是 <code>Attribute</code> 的一个限制。</p>
<p>如果过滤器在其创建过程种依赖 DI，可以通过以下方式之一解决该问题:</p>
<ul>
<li>ServiceFilterAttribute</li>
<li>TypeFilterAttribute</li>
<li>IFilterFactory</li>
</ul>
<blockquote>
<p>你可能想要在过滤器中从 DI 获取 logger。应该避免将过滤器仅用作日志目的，因为框架内置的<a href="/aspnetcore-fundamentals-logging">日志系统</a>介绍了更科学的记录日志的方法，如果一定要将日志功能加入过滤器逻辑中，那么该日志应该侧重于记录该过滤器与业务领域逻辑相关的内容，而不是 <code>MVC Action</code> 或其他框架事件。</p>
</blockquote>
<h3 id="ServiceFilterAttribute"><a href="#ServiceFilterAttribute" class="headerlink" title="ServiceFilterAttribute"></a>ServiceFilterAttribute</h3><p><code>ServiceFilterAttribute</code> 从 DI 中请求一个特定过滤器的实例，你应该在 <code>ConfigureServices</code> 方法中注册该过滤器类型，并在 <code>ServiceFilter</code> 引用它。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    services.AddScoped&lt;AddHeaderFilterWithDi&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">ServiceFilter(typeof(AddHeaderFilterWithDi))</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> IActionResult <span class="title">Index</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> View();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="TypeFilterAttribute"><a href="#TypeFilterAttribute" class="headerlink" title="TypeFilterAttribute"></a>TypeFilterAttribute</h3><p><code>TypeFilterAttribute</code> 与 <code>ServiceFilterAttribute</code> 非常相似，但它并不是从 DI 中解析过滤器类型的实例，而是通过 <code>Microsoft.Extensions.DependencyInjection.ObjectFactory</code> 创建过滤器类型的实例。因此:</p>
<ul>
<li>被 <code>TypeFilterAttribute</code> 类型引用的过滤器类型无需在 IoC 中注册。</li>
<li><code>TypeFilterAttribute</code> 可以有选择地传递过滤器类型的构造函数参数。</li>
</ul>
<p>以下示例演示了如何将构造函数参数传递给 <code>TypeFilterAttribute</code>:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">TypeFilter(typeof(AddHeaderAttribute),</span></span><br><span class="line"><span class="meta">    Arguments = new object[</span>] &#123; <span class="string">"Author"</span>, <span class="string">"Steve Smith (@ardalis)"</span> &#125;)]</span><br><span class="line"><span class="function"><span class="keyword">public</span> IActionResult <span class="title">Hi</span>(<span class="params"><span class="keyword">string</span> name</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Content(<span class="string">$"Hi <span class="subst">&#123;name&#125;</span>"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Authorization-过滤器"><a href="#Authorization-过滤器" class="headerlink" title="Authorization 过滤器"></a>Authorization 过滤器</h2><ul>
<li>管道中第一批被执行的过滤器</li>
<li>有 before 方法，没有 after 方法</li>
<li>不要在该过滤器中的抛出异常</li>
</ul>
<h2 id="Resource-过滤器"><a href="#Resource-过滤器" class="headerlink" title="Resource 过滤器"></a>Resource 过滤器</h2><ul>
<li>实现 <code>IResourceFilter</code> 或 <code>IAsyncResourceFilter</code> 之一</li>
<li>包围大多数管理过滤器</li>
<li>只有 <code>Authorization</code> 过滤器先于它执行</li>
</ul>
<p>Resource 过滤器用于短路请求的大多数工作，例如，缓存过滤器如果检查到响应位于缓存中，则跳过管道中的其余逻辑</p>
<h2 id="Action-过滤器"><a href="#Action-过滤器" class="headerlink" title="Action 过滤器"></a>Action 过滤器</h2><p>实现 <code>IActionFilter</code> 或 <code>IAsyncActionFilter</code> 接口之一，以下是一个示例 <code>Action</code> 过滤器:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SampleActionFilter</span> : <span class="title">IActionFilter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnActionExecuting</span>(<span class="params">ActionExecutingContext context</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// do something before the action executes</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnActionExecuted</span>(<span class="params">ActionExecutedContext context</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// do something after the action executes</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>ActionExecutingContext</code> 提供了以下属性:</p>
<ul>
<li><code>ActionArguments</code>: 操作提供给方法的输入参数</li>
<li><code>Controller</code>: 操作控制器实例</li>
<li><code>Result</code>: 设置该值以短路该 Action 方法及其后的过滤器，抛出异常亦然，但会被认为是一个失败请求。</li>
</ul>
<p><code>ActionExecutedContext</code> 提供了以下属性:</p>
<ul>
<li><code>Canceled</code>: 当 Action 执行短路时为 true</li>
<li><code>Exception</code>: 抛出异常时该值不为空，将该值显式设置为 <code>null</code> 则被认为异常已经过处理，之后 <code>Result</code> 属性将被处理。</li>
</ul>
<p>对于 <code>IAsyncActionFilter</code>，执行 <code>ActionExecutionDelegate</code> 将:</p>
<ul>
<li>同时执行所有后续的过滤器和 Action 方法本身</li>
<li>返回 <code>ActionExecutedContext</code></li>
</ul>
<p>要短路，则设置 <code>ActionExecutingContext.Result</code> 并且不要调用 <code>ActionExecutionDelegate</code>。</p>
<h2 id="Exception-过滤器"><a href="#Exception-过滤器" class="headerlink" title="Exception 过滤器"></a>Exception 过滤器</h2><p>Exception 实现 <code>IExceptionFilter</code> 或 <code>IAsyncExceptionFilter</code> 接口之一。其用于实现通用错误处理策略。<code>Exception</code> 过滤器:</p>
<ul>
<li>没有 before 和 after 事件</li>
<li>实现 <code>OnException</code> 或 <code>OnExceptionAsync</code></li>
<li>处理发生在创建控制器，模型绑定，<code>Action</code> 过滤器或 <code>Action</code> 方法中未捕获的异常</li>
<li>不要在 <code>Resource</code> 过滤器，<code>Result</code> 过滤器或 MVC Result 执行过程中捕获异常</li>
</ul>
<p>设置 <code>ExceptionContext.ExceptionHandled</code> 为 true 并返回一个请求响应以指示异常被处理。<code>Exception</code> 过滤器:</p>
<ul>
<li>对于处理 MVC Action 中抛出的异常是最佳位置</li>
<li>不如错误处理中间件来得灵活</li>
</ul>
<p>「仅当需要针对性对某个 MVC Action 进行特殊处理时采用 <code>Exception</code> 过滤器。」</p>
<h2 id="在管道中使用过滤器中间件"><a href="#在管道中使用过滤器中间件" class="headerlink" title="在管道中使用过滤器中间件"></a>在管道中使用过滤器中间件</h2><p><code>Resource</code> 过滤器由于其包围了管道其后的所有执行过程，所以其职责非常类似于一个过滤器中间件。然而其与中间件最大的区别在于，<code>Resource</code> 过滤器是 MVC 的一部分，这意味着它们可以访问 MVC 的 context 和构造。</p>
<p>当使用中间件时同时也希望能够访问 MVC 的路由数据或仅仅为某个特定的 <code>Controller</code> 或 <code>Action</code> 服务。定义一个包含 <code>Configure</code> 方法的类型，以下示例展示了一个使用本地化中间件为请求建立当前文化:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LocalizationPipeline</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">IApplicationBuilder applicationBuilder</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> supportedCultures = <span class="keyword">new</span>[]</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">new</span> CultureInfo(<span class="string">"en-US"</span>),</span><br><span class="line">            <span class="keyword">new</span> CultureInfo(<span class="string">"fr"</span>)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> options = <span class="keyword">new</span> RequestLocalizationOptions</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            DefaultRequestCulture = <span class="keyword">new</span> RequestCulture(culture: <span class="string">"en-US"</span>, uiCulture: <span class="string">"en-US"</span>),</span><br><span class="line">            SupportedCultures = supportedCultures,</span><br><span class="line">            SupportedUICultures = supportedCultures</span><br><span class="line">        &#125;;</span><br><span class="line">        options.RequestCultureProviders = <span class="keyword">new</span>[] </span><br><span class="line">            &#123; <span class="keyword">new</span> RouteDataRequestCultureProvider() &#123; Options = options &#125; &#125;;</span><br><span class="line"></span><br><span class="line">        applicationBuilder.UseRequestLocalization(options);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>之后，可以在 <code>Controller</code> 上或 <code>Action</code> 上或全局地通过 <code>MiddlewareFilterAttribute</code> 应用该中间件:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Route(<span class="meta-string">"&#123;culture&#125;/[controller]/[action]"</span>)</span>]</span><br><span class="line">[<span class="meta">MiddlewareFilter(typeof(LocalizationPipeline))</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> IActionResult <span class="title">CultureFromRouteData</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Content(<span class="string">$"CurrentCulture:<span class="subst">&#123;CultureInfo.CurrentCulture.Name&#125;</span>,"</span></span><br><span class="line">        + <span class="string">$"CurrentUICulture:<span class="subst">&#123;CultureInfo.CurrentUICulture.Name&#125;</span>"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>中间件过滤器与 <code>Resource</code> 过滤器运行在同一阶段。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://berdypango.github.io/aspnetcore-fundamentals-pipelines/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Frost He">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FrostHe.Handbook">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/aspnetcore-fundamentals-pipelines/" itemprop="url">ASP.NET Core 框架基础 - 管道与中间件</a></h1>
        

        <div class="post-meta">
          
          <span class="post-time">
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  9,847
                </span>
              

              

              
            </div>
          

          
              <div class="post-description">
                  管道由一个服务器和一个 HttpApplication 构成，服务器负责监听请求并将接收到的请求传递给给 HttpApplication 对象处理，HttpApplication 则将请求处理任务委托给注册的中间件来完成。
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>参考资料: </p>
<ul>
<li><a href="http://www.cnblogs.com/artech/p/rebuild-pipeline-01.html" target="_blank" rel="noopener">采用管道处理请求</a></li>
<li><a href="http://www.cnblogs.com/artech/p/rebuild-pipeline-02.html" target="_blank" rel="noopener">管道如何处理请求</a></li>
<li><a href="http://www.cnblogs.com/artech/p/rebuild-pipeline-03.html" target="_blank" rel="noopener">管道如何创建</a></li>
<li><a href="http://www.cnblogs.com/artech/p/asp-net-core-real-pipeline-01.html" target="_blank" rel="noopener">中间件究竟是什么</a></li>
</ul>
<p>本文大纲:<br><!-- TOC --></p>
<ul>
<li><a href="#%E6%A6%82%E8%BF%B0">概述</a><ul>
<li><a href="#%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84-hello-world-%E5%BA%94%E7%94%A8">一个简单的 Hello World 应用</a></li>
<li><a href="#%E7%AE%A1%E9%81%93%E7%9A%84%E6%9E%84%E6%88%90">管道的构成</a></li>
<li><a href="#%E5%AE%9A%E5%88%B6%E7%AE%A1%E9%81%93">定制管道</a></li>
</ul>
</li>
<li><a href="#%E6%9C%8D%E5%8A%A1%E5%99%A8">服务器</a><ul>
<li><a href="#httpapplication">HttpApplication</a></li>
<li><a href="#hostingapplication">HostingApplication</a></li>
<li><a href="#kestrelserver">KestrelServer</a></li>
<li><a href="#serveraddressesfeature">ServerAddressesFeature</a></li>
</ul>
</li>
<li><a href="#webhost">WebHost</a><ul>
<li><a href="#webhostoptions">WebHostOptions</a></li>
<li><a href="#%E6%9E%84%E5%BB%BA%E7%AE%A1%E9%81%93">构建管道</a></li>
</ul>
</li>
<li><a href="#webhostbuilder">WebHostBuilder</a><ul>
<li><a href="#%E5%87%A0%E4%B8%AA%E5%B8%B8%E7%94%A8%E7%9A%84%E6%89%A9%E5%B1%95%E6%96%B9%E6%B3%95">几个常用的扩展方法</a></li>
</ul>
</li>
<li><a href="#httpcontext">HttpContext</a><ul>
<li><a href="#featurecollection">FeatureCollection</a></li>
<li><a href="#defaulthttpcontext">DefaultHttpContext</a></li>
<li><a href="#httpcontextfactory">HttpContextFactory</a></li>
</ul>
</li>
<li><a href="#applicationbulder">ApplicationBulder</a><ul>
<li><a href="#applicationbuilderfactory">ApplicationBuilderFactory</a></li>
</ul>
</li>
<li><a href="#%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%B1%BB%E5%9E%8B">中间件类型</a><ul>
<li><a href="#%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%B1%BB%E5%9E%8B%E6%B3%A8%E5%86%8C">中间件类型注册</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>HTTP 协议自身的特性决定了任何一个 Web 应用的工作方式都是监听、接收并处理 HTTP 请求，并最终对请求予以响应。HTTP 请求处理是管道式设计典型的应用场景，ASP.NET Core 根据一个具体的 HTTP 请求构建一个管道，接收到的 HTTP 请求消息像水一样流入这个管道，组成这个管道的各个环节依次对它作相应的处理。整个请求处理完成后的结果同样转变成消息逆向流入这个管道进行处理，并最终变成回复给客户端的 HTTP 响应。</p>
<h2 id="一个简单的-Hello-World-应用"><a href="#一个简单的-Hello-World-应用" class="headerlink" title="一个简单的 Hello World 应用"></a>一个简单的 Hello World 应用</h2><p>首先来看一个简单的 .NET Core 应用程序:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> WebHostBuilder()</span><br><span class="line">            .UseKestrel()</span><br><span class="line">            .Configure(app =&gt; app.Run(<span class="keyword">async</span> context=&gt; <span class="keyword">await</span> context.Response.WriteAsync(<span class="string">"Hello World"</span>)))            </span><br><span class="line">            .Build()</span><br><span class="line">            .Run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>WebHost</code> 对象可以看成是 Web 应用的宿主，启动 Web 应用本质上就是启动 <code>WebHost</code> 宿主对象。<code>WebHostBuilder</code> 负责创建 <code>WebHost</code> 对象，它的 <code>Build</code> 方法创建并返回相应的 <code>WebHost</code>。</p>
<p><code>Configure</code> 方法注册到 <code>WebHostBuilder</code> 上的委托对象(委托类型为 <code>Action&lt;IApplicationBuilder&gt;</code>)用于定制管道的逻辑。调用 <code>WebHost</code> 的扩展方法 <code>Run</code> 启动应用程序时，用于监听，接收，处理和响应 HTTP 请求的管道也随之被建立。<br><img src="/aspnetcore-fundamentals-pipelines/pipes_01.png" title="对象关系示意图"></p>
<h2 id="管道的构成"><a href="#管道的构成" class="headerlink" title="管道的构成"></a>管道的构成</h2><p>HTTP 请求处理流程始于对请求的监听，终于对请求的响应，这两项工作均由同一个对象来完成，我们称之为 <strong>「服务器(Server)」</strong> 。尽管 ASP.NET Core 的请求处理管道可以任意定制，但是该管道必须有一个 Server，Server 是整个管道的<strong>「水龙头」</strong>。在上述的 Hello World 应用中，在 <code>Build</code> 一个 <code>WebHost</code> 之前，首先调用了扩展方法 <code>UseKestrel</code>，该方法就是为后续构建的管道注册一个名为 <code>KestrelServer</code> 的<strong>「服务器」</strong>。</p>
<p>调用 <code>WebHost</code> 的 <code>Start</code> 方法(调用 <code>WebHost</code> 的扩展方法 <code>Run</code> 时，它的 <code>Start</code> 方法会被自动调用)之后，定制的管道会被构建出来，管道的服务器将绑定到一个预设的端口(<code>KestrelServer</code> 默认采用 5000 作为监听端口)开始监听请求。HTTP 请求一旦抵达，服务器将其标准化并分发给管道后续的节点。管道中位于服务器之后的节点称为<strong>「中间件(Middleware)」</strong>。每个中间件都具有各自独立的功能，例如有专门实现路由功能的中间件，有专门实施用户认证的中间件。<strong>所谓的管道定制体现在根据具体的需求选择对应的中间件组成最终的请求处理管道</strong>。下图揭示了由一个服务器和一组中间件构成的请求处理管道:<br><img src="/aspnetcore-fundamentals-pipelines/pipes_02.png" title="管道示意图"><br>一个基于 ASP.NET Core 的应用程序通常是根据某个框架开发的，而框架本身就是通过某个或多个<strong>「中间件」</strong>构建出来的。ASP.NET Core MVC 就是典型的基于 ASP.NET Core 的开发框架，它定义了一个叫做<strong>「路由」</strong>的中间件实现了请求地址与 <code>Controller/Action</code> 之间的映射，并在此基础实现了激活 <code>Controller</code>，执行 <code>Action</code> 以及呈现 <code>View</code> 等一系列的功能。所以应用程序可以视为某个中间件的一部分，如果一定要将它独立出来，整个请求处理管道将呈现出如下图所示的结构:<br><img src="/aspnetcore-fundamentals-pipelines/pipes_03.png" title="应用程序位于框架中的位置"></p>
<h2 id="定制管道"><a href="#定制管道" class="headerlink" title="定制管道"></a>定制管道</h2><p>在上述的 Hello World 程序中，调用扩展方法 <code>UseKestrel</code> 注册 <code>KestrelServer</code> 服务器之后，还调用 <code>WebHostBuilder</code> 的 <code>Configure</code> 的扩展方法注册了一个类型为 <code>Action&lt;IApplicationBuilder&gt;</code> 的委托对象。注册这个委托对象的目的在于对构建的管道定制请求处理逻辑，即为管道注册中间件。这个委托对象调用 <code>ApplicationBuilder</code> 的 <code>Run</code> 扩展方法注册了一个中间件来为每个请求响应一个「Hello World」字符串。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IWebHostBuilder <span class="title">Configure</span>(<span class="params"><span class="keyword">this</span> IWebHostBuilder hostBuilder, Action&lt;IApplicationBuilder&gt; configureApp</span>) </span></span><br></pre></td></tr></table></figure><br>除了调用 <code>WebHostBuilder</code> 的 <code>Configure</code> 方法来注册一个 <code>Action&lt;IApplicationBuilder&gt;</code> 类型的委托，注册中间件定义管道的逻辑更多地还是定义在一个单独的类型中。由于管道的定制总是在应用程序启动(<strong>Startup</strong>)的时候进行，一般称这个用于定制管道的类型为<strong>「启动类型」</strong>，并在大部分情况下会直接命名为 <code>Startup</code>。<strong>按照约定，通过注册中间件定制管道的操作会实现在名为 <code>Configure</code> 的方法中，方法的第一个参数必须是一个 <code>IApplicationBuilder</code> 接口的实例</strong>，后续可定义任意数量和类型的参数，当 ASP.NET Core 框架调用该方法的时候，会以依赖注入的方式提供这些参数的值。启动类型可以通过调用 <code>WebHostBuilder</code> 的扩展方法 <code>UseStartup&lt;T&gt;</code> 来指定，如下面的代码与前面演示的示例是完全等效的。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Startup</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">IApplicationBuilder app</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        app.Run(<span class="keyword">async</span> context =&gt; <span class="keyword">await</span> context.Response.WriteAsync(<span class="string">"Hello World"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> WebHostBuilder()</span><br><span class="line">            .UseKestrel()</span><br><span class="line">            .UseStartup&lt;Startup&gt;()         </span><br><span class="line">            .Build()</span><br><span class="line">            .Run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在真正的项目开发中，我们会利用 <code>ApplicationBuilder</code> 注册相应的中间件进而构建一个符合需求的请求处理管道。如下所示，我们除了按照上面的方式调用扩展方法 <code>UseMvc</code> 注册了支撑 MVC 框架的中间件(实际上是一个实现路由的中间件)之外，还调用了其它的扩展方法注册了相应的中间件实现了对静态文件的访问(<code>UseStaticFiles</code>)，错误页面的呈现(<code>UseExceptionHandler</code>)以及基于 ASP.NET Identity Framework 的认证(<code>UseIdentity</code>):<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Startup</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">IApplicationBuilder app</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        app.UseExceptionHandler(<span class="string">"/Home/Error"</span>);</span><br><span class="line">        app.UseStaticFiles();</span><br><span class="line">        app.UseIdentity();           </span><br><span class="line"> </span><br><span class="line">        app.UseMvc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h1><p>服务器是 ASP.NET Core 管道的第一个节点，它负责请求的监听和接收，并最终完成对请求的响应。服务器是所有实现了 <code>IServer</code> 接口的类型及其对象的统称。<code>IServer</code> 接口定义了一个只读属性 <code>Features</code> 返回描述自身特性集合的 <code>IFeatureCollection</code> 对象，<code>Start</code> 方法用于启动服务器。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IServer</span></span><br><span class="line">&#123;</span><br><span class="line">    IFeatureCollection Features &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">void</span> Start&lt;TContext&gt;(IHttpApplication&lt;TContext&gt; application);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>Start</code> 方法一旦执行，服务会马上开始监听工作。任何 HTTP 请求抵达，该方法接收一个 <code>HttpApplication</code> 对象创建一个上下文，并在此上下文中完成对请求的所有处理操作。当完成了对请求的处理任务之后，<code>HttpApplication</code> 对象会自行负责回收释放由它创建的上下文。</p>
<h2 id="HttpApplication"><a href="#HttpApplication" class="headerlink" title="HttpApplication"></a>HttpApplication</h2><p>ASP.NET Core 请求处理管道由一个服务器和一组有序排列的中间件组合而成。如果在此之上作进一步抽象，将后者抽象成一个 <code>HttpApplication</code> 对象，该管道就成了一个 <code>Server</code> 和 <code>HttpApplication</code> 的组合。<code>Server</code> 将接收到的 HTTP 请求转发给 <code>HttpApplication</code> 对象，后续的请求完全由它来负责。<br><code>HttpApplication</code> 从服务器获得请求之后，会使用注册的中间件对请求进行处理，并最终将请求递交给应用程序。<code>HttpApplication</code> 针对请求的处理在一个执行上下文中完成，这个上下文为对单一请求的整个处理过程定义了一个边界。描述 HTTP 请求的 <code>HttpContext</code> 是这个执行上下文中最核心的部分，除此之外，我们还可以根据需要将其他相关的信息定义其中，所以 <code>IHttpApplication&lt;TContext&gt;</code> 接口采用泛型来表示定义这个上下文的类型。<br><img src="/aspnetcore-fundamentals-pipelines/pipes_04.png" title="HttpApplication"><br>一个 <code>HttpApplication</code> 对象在接收到 <code>Server</code> 转发的请求之后完成三项基本的操作，即<strong>「创建上下文」</strong>，<strong>「在上下文中处理请求」</strong>以及<strong>「请求处理完成之后释放上下文」</strong>，这些操作通过三个方法来完成。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface IHttpApplication&lt;TContext&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">TContext <span class="title">CreateContext</span>(<span class="params">IFeatureCollection contextFeatures</span>)</span>; </span><br><span class="line">    <span class="function">Task <span class="title">ProcessRequestAsync</span>(<span class="params">TContext context</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DisposeContext</span>(<span class="params">TContext context, Exception exception</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>CreateContext</code> 和 <code>DisposeContext</code> 方法分别体现了执行上下文的创建和释放，<code>CreateContext</code> 方法的参数 <code>contextFeatures</code> 表示描述原始上下文的特性集合。在此上下文中针对请求的处理实现在另一个方法 <code>ProcessRequestAsync</code> 中。</p>
<h2 id="HostingApplication"><a href="#HostingApplication" class="headerlink" title="HostingApplication"></a>HostingApplication</h2><p>在 ASP.NET Core 中，<code>HostingApplication</code> 类型是 <code>IHttpApplication&lt;Context&gt;</code> 默认实现类，它创建的执行上下文有如下定义:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> Context</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> HttpContext HttpContext &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> IDisposable Scope &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> StartTimestamp &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该类型封装了一个 <code>HttpContext</code> 对象，后者是真正描述当前 HTTP 请求的上下文，承载着核心的上下文信息。除此之外，<code>Context</code> 还定义了 <code>Scope</code> 和 <code>StartTimestamp</code> 两个属性，两者与日志记录和事件追踪有关，前者用来将针对同一请求的多次日志记录关联到同一个上下文区限(见<a href="/Web/ASP-NET-Core/aspnetcore-fundamentals-logging/#日志类别Category">日志区限</a>；后者表示请求开始处理的时间戳，如果在完成请求处理的时候记录下当时的时间戳，就可以计算出整个请求处理所花费的时间。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class HostingApplication : IHttpApplication&lt;HostingApplication.Context&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HostingApplication</span>(<span class="params">RequestDelegate application, ILogger logger, DiagnosticSource diagnosticSource, IHttpContextFactory httpContextFactory</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Context <span class="title">CreateContext</span>(<span class="params">IFeatureCollection contextFeatures</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DisposeContext</span>(<span class="params">Context context, Exception exception</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Task <span class="title">ProcessRequestAsync</span>(<span class="params">Context context</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>HostingApplication</code> 的构造函数依赖一个 <code>RequestDelegate</code> 的委托对象，该对象由 <code>IApplicationBuilder</code> 注册的中间件生成，<code>HttpContextFactory</code> 用以创建 <code>HttpContext</code> 对象:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class HostingApplication : IHttpApplication&lt;HostingApplication.Context&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> RequestDelegate         _application;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> DiagnosticSource        _diagnosticSource;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IHttpContextFactory     _httpContextFactory;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ILogger                 _logger;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HostingApplication</span>(<span class="params">RequestDelegate application, ILogger logger, DiagnosticSource diagnosticSource, IHttpContextFactory httpContextFactory</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _application          = application;</span><br><span class="line">        _logger               = logger;</span><br><span class="line">        _diagnosticSource     = diagnosticSource;</span><br><span class="line">        _httpContextFactory   = httpContextFactory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>logger</code> 和 <code>diagnosticSource</code> 是与日志记录有关的参数。<code>HostingApplication</code> 对 <code>CreateContext</code>，<code>ProcessRequestAsync</code> 和 <code>DisposeContext</code> 有如下实现:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Context <span class="title">CreateContext</span>(<span class="params">IFeatureCollection contextFeatures</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//省略其他实现代码</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Context</span><br><span class="line">    &#123;</span><br><span class="line">           HttpContext      = _httpContextFactory.Create(contextFeatures),</span><br><span class="line">           Scope            = ...,</span><br><span class="line">           StartTimestamp   = ...</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> Task <span class="title">ProcessRequestAsync</span>(<span class="params">Context context</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Return _application(context.HttpContext);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DisposeContext</span>(<span class="params">Context context, Exception exception</span>)</span></span><br><span class="line"><span class="function"></span>&#123;        </span><br><span class="line">    <span class="comment">//省略其他实现代码</span></span><br><span class="line">    context.Scope.Dispose();</span><br><span class="line">    _httpContextFactory.Dispose(context.HttpContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>CreateContext</code> 直接利用私有字段 <code>_httpContextFactory</code> 创建一个 <code>HttpContext</code> 对象并将其赋值给 <code>Context</code> 的同名属性。</li>
<li><code>ProcessRequestAsync</code> 方法则使用 <code>HttpContext</code> 传入 <code>RequestDelegate</code> 委托。</li>
<li><code>DisposeContext</code> 方法执行时 <code>Context</code> 属性的 <code>Scope</code> 会率先被释放，此后 调用 <code>IHttpContextFactory.Dispose</code> 方法释放 <code>HttpContext</code> 对象。</li>
</ul>
<h2 id="KestrelServer"><a href="#KestrelServer" class="headerlink" title="KestrelServer"></a>KestrelServer</h2><p>跨平台是 ASP.NET Core 一个显著的特性，而 <code>KestrelServer</code> 是目前微软推出的唯一一个能够真正跨平台的服务器。<code>KestrelServer</code> 基于 <code>KestrelEngine</code> 的网络引擎实现对请求的监听，接收和响应。<code>KetrelServer</code> 之所以可以跨平台，在于 <code>KestrelEngine</code> 是在 <code>libuv</code> 跨平台网络库上开发的。</p>
<blockquote>
<p><code>libuv</code> 是基于 Unix 系统针对事件循环和事件模型的网络库 <code>libev</code> 开发的。<code>libev</code> 不支持 Windows，有人在 <code>libev</code> 之上创建了一个抽象层以屏蔽平台之间的差异，这个抽象层就是 <code>libuv</code>。<code>libuv</code> 在 Windows 平台上使用 IOCP 的形式实现，到目前为止，<code>libuv</code> 已经支持更多除 Unix 和 Windows 以外的平台了，如 Linux(2.6)、MacOS 和 Solaris (121以及之后的版本)。下图揭示了 <code>libuv</code> 针对 Unix 和 Windows 的跨平台实现原理。<br><img src="/aspnetcore-fundamentals-pipelines/pipes_10.png"></p>
</blockquote>
<p>以下是 <code>KestrelServer</code> 类型的定义:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">KestrelServer</span> : <span class="title">IServer</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="keyword">public</span> IFeatureCollection     Features &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> KestrelServerOptions   Options &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">KestrelServer</span>(<span class="params">IOptions&lt;KestrelServerOptions&gt; options, IApplicationLifetime applicationLifetime, ILoggerFactory loggerFactory</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> Start&lt;TContext&gt;(IHttpApplication&lt;TContext&gt; application);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>除了实现接口 <code>IServer</code> 定义的 <code>Features</code> 属性之外，<code>KestrelServer</code> 还包含一个类型为 <code>KestrelServerOptions</code> 的只读属性 Options。这个属性表示 <code>KestrelServer</code> 的配置信息，构造函数通过输入参数 <code>IOptions&lt;KestrelServerOptions&gt;</code> 对其进行初始化，这里同样采用 <a href="/Web/ASP-NET-Core/aspnetcore-fundamentals-configuration/#options-模式">Options 模式</a>。例如可以通过一个 JSON 文件来配置 <code>KestrelServer</code>:<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"noDelay"</span>            : <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"shutdownTimeout"</span>    : <span class="string">"00:00:10"</span>,</span><br><span class="line">  <span class="attr">"threadCount"</span>        :  <span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>构造函数的另外两个参数 - <code>IApplicationLifetime</code> 与与应用的生命周期管理有关， <code>ILoggerFactory</code> 则用于创建记录日志的 <code>Logger</code>。</p>
<p>通常，通过调用 <code>WebHostBuilder</code> 的 <code>UseKestrel</code> 扩展方法来注册 <code>KestrelServer</code>。<code>UseKestrel</code> 方法有两个重载，其中一个接收一个类型为 <code>Action&lt;KestrelServerOptions&gt;</code> 的参数，通过赋值该参数直接完成对 <code>KestrelServer</code> 的配置。代码如下:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">WebHostBuilderKestrelExtensions</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IWebHostBuilder <span class="title">UseKestrel</span>(<span class="params"><span class="keyword">this</span> IWebHostBuilder hostBuilder</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IWebHostBuilder <span class="title">UseKestrel</span>(<span class="params"><span class="keyword">this</span> IWebHostBuilder hostBuilder, Action&lt;KestrelServerOptions&gt; options</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>由于服务器负责监听，接收和响应请求，它是影响整个 Web 应用响应能力和吞吐量最大的因素之一，为了更加有效地使用服务器，可以根据具体的网络负载状况对其作针对性的设置。现在来看看 <code>KestrelServerOptions</code> 类型的定义:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">KestrelServerOptions</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="comment">//省略其他成员</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>          MaxPooledHeaders &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>          MaxPooledStreams &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">bool</span>         NoDelay &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> TimeSpan     ShutdownTimeout &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>          ThreadCount &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="ServerAddressesFeature"><a href="#ServerAddressesFeature" class="headerlink" title="ServerAddressesFeature"></a>ServerAddressesFeature</h2><p><code>KestrelServer</code> 默认采用 <code>http://localhost:5000</code> 作为监听地址，服务器的监听地址可以显式指定，其通过 <code>IServerAddressesFeature</code> 提供支持。服务器接口 <code>IServer</code> 中定义了一个类型为 <code>IFeatureCollection</code> 的只读属性 <code>Features</code>，它表示当前服务器的特性集合，<code>ServerAddressesFeature</code> 作为一个重要的特性，就包含在这个集合中。该接口只有一个唯一的只读属性返回服务器的监听地址列表。ASP.NET Core 默认使用 <code>ServerAddressesFeature</code> 类型实现 <code>IServerAddressesFeature</code> 接口，定义如下:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IServerAddressesFeature</span></span><br><span class="line">&#123;</span><br><span class="line">    ICollection&lt;<span class="keyword">string</span>&gt; Addresses &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ServerAddressesFeature</span> : <span class="title">IServerAddressesFeature</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> ICollection&lt;<span class="keyword">string</span>&gt; Addresses &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>WebHost</code> 通过依赖注入创建的服务器的 <code>Features</code> 属性中会默认包含一个 <code>ServerAddressesFeature</code> 对象。<code>WebHost</code> 会将显式指定的地址(一个或者多个)添加到该对象的监听地址列表中。地址列表其作为配置项保存在一个 <code>Configuration</code> 对象上，配置项对应的 Key 为 <code>urls</code>，可以通过 <code>WebHostDefaults</code> 的静态只读属性 <code>ServerUrlsKey</code> 返回这个 Key。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> WebHostBuilder()</span><br><span class="line">    .UseSetting(WebHostDefaults.ServerUrlsKey, <span class="string">"http://localhost:3721/"</span>)</span><br><span class="line">    .UseKestrel()</span><br><span class="line">    .UseStartup&lt;Startup&gt;()</span><br><span class="line">    .Build()</span><br><span class="line">    .Run();</span><br></pre></td></tr></table></figure></p>
<p>WebHost 的配置最初来源于创建它的 <code>WebHostBuilder</code>，<code>WebHostBuilder</code> 提供了一个 <code>UseSettings</code> 方法来设置某个配置项的值。对监听地址的显式设置，最直接的编程方式是调用 <code>WebHostBuilder</code> 的扩展方法 <code>UseUrls</code>，该方法的实现逻辑与上面完全一致:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">WebHostBuilderExtensions</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IWebHostBuilder <span class="title">UseUrls</span>(<span class="params"><span class="keyword">this</span> IWebHostBuilder hostBuilder, <span class="keyword">params</span> <span class="keyword">string</span>[] urls</span>) </span></span><br><span class="line"><span class="function">    </span>=&gt;hostBuilder.UseSetting(WebHostDefaults.ServerUrlsKey, <span class="keyword">string</span>.Join(ServerUrlsSeparator, urls)) ;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="WebHost"><a href="#WebHost" class="headerlink" title="WebHost"></a>WebHost</h1><p>ASP.NET Core 管道是由作为应用程序宿主的 <code>WebHost</code> 对象创建出来的。应用的启动和关闭是通过启动或者关闭对应 <code>WebHost</code> 的方式实现的。<code>IWebHost</code> 接口定义了如下三个基本成员:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IWebHost</span> : <span class="title">IDisposable</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span>;</span><br><span class="line">    IFeatureCollection     ServerFeatures &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    IServiceProvider       Services &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>Start</code> 方法用于启动宿主程序。编程中通常会调用它的一个扩展方法 <code>Run</code> 来启动 <code>WebHost</code>，<code>Run</code> 方法会在内部调用 <code>Start</code> 方法。当 WebHost 启动后，服务器立即开始监听请求。<code>IWebHost</code> 接口的默认实现类是 <code>WebHost</code>，它总是由一个 <code>WebHostBuilder</code> 对象创建，<code>WebHost</code> 的构造函数依赖 4 个参数:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WebHost</span> : <span class="title">IWebHost</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> IServiceCollection   _appServices;</span><br><span class="line">    <span class="keyword">private</span> IServiceProvider     _hostingServiceProvider;</span><br><span class="line">    <span class="keyword">private</span> WebHostOptions       _options;</span><br><span class="line">    <span class="keyword">private</span> IConfiguration       _config;</span><br><span class="line">    <span class="keyword">private</span> ApplicationLifetime  _applicationLifetime;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> IServiceProvider       Services &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> IFeatureCollection     ServerFeatures </span><br><span class="line">    &#123;</span><br><span class="line">         <span class="keyword">get</span> &#123; <span class="keyword">return</span> <span class="keyword">this</span>.Services.GetRequiredService&lt;IServer&gt;()?.Features; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WebHost</span>(<span class="params">IServiceCollection appServices, IServiceProvider hostingServiceProvider, WebHostOptions options, IConfiguration config</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _appServices                 = appServices;</span><br><span class="line">        _hostingServiceProvider      = hostingServiceProvider;</span><br><span class="line">        _options                     = options;</span><br><span class="line">        _config                      = config;</span><br><span class="line">        </span><br><span class="line">        _applicationLifetime         = <span class="keyword">new</span> ApplicationLifetime();</span><br><span class="line">        appServices.AddSingleton&lt;IApplicationLifetime&gt;(_applicationLifetime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _applicationLifetime.StopApplication();</span><br><span class="line">        (<span class="keyword">this</span>.Services <span class="keyword">as</span> IDisposable)?.Dispose();</span><br><span class="line">        _applicationLifetime.NotifyStopped();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>appServices 从直接注册到 <code>WebHostBuilder</code> 上的服务而来</li>
<li>hostingServiceProvider 是由 appServices 创建的<code>IServiceProvider</code>。</li>
<li>只读属性 <code>Services</code> 返回一个 <code>ServiceProvider</code> 对象，其利用构造函数传入的 <code>ServiceCollection</code> 对象创建。</li>
<li>只读属性 <code>ServerFeatures</code> 返回服务器的特性集合，而服务器本身使用 <code>ServiceProvider</code> 获得</li>
<li><code>Dispose</code> 方法释放服务器对象，并利用 <code>ApplicationLifetime</code> 发送相应的信号。</li>
</ul>
<h2 id="WebHostOptions"><a href="#WebHostOptions" class="headerlink" title="WebHostOptions"></a>WebHostOptions</h2><p>一个 <code>WebHostOptions</code> 对象为构建的 <code>WebHost</code> 对象提供一些预定义的选项，这些选项很重要，它们决定了由 <code>WebHost</code> 构建的管道进行内容加载以及异常处理等方面的行为。以下是其类型定义:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WebHostOptions</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span>     ApplicationName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">bool</span>       DetailedErrors &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">bool</span>       CaptureStartupErrors &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span>     Environment &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;        </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span>     StartupAssembly &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span>     WebRoot &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span>     ContentRootPath &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WebHostOptions</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="title">WebHostOptions</span>(<span class="params">IConfiguration configuration</span>) </span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><br>可以将这些选项定义在配置中，并利用 Options 模式创建一个 <code>WebHostOptions</code> 对象。 </p>
<h2 id="构建管道"><a href="#构建管道" class="headerlink" title="构建管道"></a>构建管道</h2><p><code>Start</code> 方法真正启动 <code>WebHost</code>:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//注册服务</span></span><br><span class="line">    IStartup startup = _hostingServiceProvider.GetRequiredService&lt;IStartup&gt;();</span><br><span class="line">    <span class="keyword">this</span>.Services = startup.ConfigureServices(_appServices);</span><br><span class="line">       </span><br><span class="line">    <span class="comment">//注册中间件</span></span><br><span class="line">    Action&lt;IApplicationBuilder&gt; configure = startup.Configure;</span><br><span class="line">    configure = <span class="keyword">this</span>.Services.GetServices&lt;IStartupFilter&gt;().Reverse().Aggregate(configure, (next, current) =&gt; current.Configure(next));</span><br><span class="line">    IApplicationBuilder appBuilder = <span class="keyword">this</span>.Services.GetRequiredService&lt;IApplicationBuilder&gt;();</span><br><span class="line">    configure(appBuilder);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//为服务器设置监听地址</span></span><br><span class="line">    IServer server = <span class="keyword">this</span>.Services.GetRequiredService&lt;IServer&gt;();</span><br><span class="line">    IServerAddressesFeature addressesFeature = server.Features.Get&lt;IServerAddressesFeature&gt;();</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> != addressesFeature &amp;&amp; !addressesFeature.Addresses.Any())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">string</span> addresses = _config[<span class="string">"urls"</span>] ?? <span class="string">"http://localhost:5000"</span>;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">string</span> address <span class="keyword">in</span> addresses.Split(<span class="string">';'</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            addressesFeature.Addresses.Add(address);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//启动服务器</span></span><br><span class="line">    RequestDelegate application = appBuilder.Build();</span><br><span class="line">    ILogger logger = <span class="keyword">this</span>.Services.GetRequiredService &lt;ILogger&lt;MyWebHost&gt;&gt;();</span><br><span class="line">    DiagnosticSource diagnosticSource = <span class="keyword">this</span>.Services.GetRequiredService&lt;DiagnosticSource&gt;();</span><br><span class="line">    IHttpContextFactory httpContextFactory = <span class="keyword">this</span>.Services.GetRequiredService&lt;IHttpContextFactory&gt;();</span><br><span class="line">    server.Start(<span class="keyword">new</span> HostingApplication(application, logger, diagnosticSource, httpContextFactory));</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//对外发送通知</span></span><br><span class="line">    _applicationLifetime.NotifyStarted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>注册服务: <code>Start</code> 方法首先通过 <code>ServiceProvider</code> 获取 <code>Startup</code> 的实例，并调用 ConfigureServices 注册所有服务。</li>
<li>注册中间件: 使用 <code>ServiceProvider</code> 获取所有注册的 <code>StartupFilter</code>，并结合之前提取的 <code>Startup</code> 对象创建一个注册中间件的委托(<code>Action&lt;IApplicationBuilder&gt;</code>)。从 <code>ServiceProvider</code> 获取 <code>ApplicationBuilder</code> 对象作为参数传入该委托，完成中间件的注册。</li>
<li>设置服务器监听地址: 使用 <code>ServiceProvider</code> 提取注册在 <code>WebHostBuilder</code> 上的服务器对象，从该对象的 <code>Features</code> 属性中提取 <code>IServerAddressesFeature</code> 对象，从配置中提取显式指定的监听地址，将其逐个加入到 <code>IServerAddressesFeature</code> 的 <code>Addresses</code> 集合中。如果没有任何显式指定的监听地址，那么默认值为 <code>http://localhost:5000</code>。</li>
<li>启动服务器: 准备就绪的服务器由 <code>IServer.Start</code> 方法启动，该方法接收一个 <code>HttpApplication&lt;TContext&gt;</code> 作为参数，创建该接口的默认实现者 <code>HostingApplication</code> 需要 4 个参数: <ol>
<li><code>RequestDelegate</code>: 中间件链表，通过 <code>IApplicationBuilder.Build</code> 获取。</li>
<li><code>Logger</code>: 日志记录器，通过 <code>ServiceProvider</code> 获取。</li>
<li><code>DiagnosticSource</code>: 通过 <code>ServiceProvider</code> 获取。</li>
<li><code>HttpContextFactory</code>: Http 上下文工厂，通过 <code>ServiceProvider</code> 获取。</li>
</ol>
</li>
<li>发布通知: 服务器成功启动之后，向外发送通知</li>
</ol>
<h1 id="WebHostBuilder"><a href="#WebHostBuilder" class="headerlink" title="WebHostBuilder"></a>WebHostBuilder</h1><p><code>WebHostBuilder</code> 是 <code>WebHost</code> 的创建者，<code>IWebHostBuilder</code> 接口除了定义用来创建 <code>WebHost</code> 的核心方法 <code>Build</code> 之外，还定义了其他一些方法:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IWebHostBuilder</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">IWebHost <span class="title">Build</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function">IWebHostBuilder <span class="title">ConfigureServices</span>(<span class="params">Action&lt;IServiceCollection&gt; configureServices</span>)</span>;</span><br><span class="line">    <span class="function">IWebHostBuilder <span class="title">UseLoggerFactory</span>(<span class="params">ILoggerFactory loggerFactory</span>)</span>;</span><br><span class="line">    <span class="function">IWebHostBuilder <span class="title">ConfigureLogging</span>(<span class="params">Action&lt;ILoggerFactory&gt; configureLogging</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">string</span> <span class="title">GetSetting</span>(<span class="params"><span class="keyword">string</span> key</span>)</span>;    </span><br><span class="line">    <span class="function">IWebHostBuilder <span class="title">UseSetting</span>(<span class="params"><span class="keyword">string</span> key, <span class="keyword">string</span> <span class="keyword">value</span></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>ASP.NET Core 有两种注册服务的途径，一种是将服务注册实现在启动类的 <code>ConfigureServices</code> 方法中，另一种就是调用 <code>IWebHostBuilder</code> 的 <code>ConfigureServices</code> 方法。前者实际上是在 <code>WebHost</code> 启动时提取 <code>Startup</code> 对象调用其 <code>ConfigureServices</code> 进行注册，而 <code>IWebHostBuilder.ConfigureServices</code> 直接将服务提供给创建的 <code>WebHost</code>。</p>
<p><code>UseLoggerFactory</code> 设置一个默认的 <code>ILoggerFactory</code> 对象，<code>ConfigureLogging</code> 则对 <code>ILoggerFactory</code> 进行配置，具体参见<a href="/Web/ASP-NET-Core/aspnetcore-fundamentals-logging/">日志系统</a>。</p>
<p><code>IWebHostBuilder</code> 的默认实现类型时 <code>WebHostBuilder</code>，以下代码展示了除 Build 方法以外的其他成员的实现:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IWebHostBuilder</span></span><br><span class="line"><span class="title">public</span> <span class="title">class</span> <span class="title">WebHostBuilder</span> : <span class="title">IWebHostBuilder</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Action&lt;ILoggerFactory&gt;&gt; _configureLoggingDelegates = <span class="keyword">new</span> List&lt;Action&lt;ILoggerFactory&gt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> List&lt;Action&lt;IServiceCollection&gt;&gt; _configureServicesDelegates = <span class="keyword">new</span> List&lt;Action&lt;IServiceCollection&gt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> ILoggerFactory _loggerFactory = <span class="keyword">new</span> LoggerFactory();</span><br><span class="line">    <span class="keyword">private</span> IConfiguration _config = <span class="keyword">new</span> ConfigurationBuilder().AddEnvironmentVariables(<span class="string">"ASPNETCORE_"</span>).Build();</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> IWebHostBuilder <span class="title">ConfigureLogging</span>(<span class="params">Action&lt;ILoggerFactory&gt; configureLogging</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _configureLoggingDelegates.Add(configureLogging);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> IWebHostBuilder <span class="title">ConfigureServices</span>(<span class="params">Action&lt;IServiceCollection&gt; configureServices</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _configureServicesDelegates.Add(configureServices);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">GetSetting</span>(<span class="params"><span class="keyword">string</span> key</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _config[key];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> IWebHostBuilder <span class="title">UseLoggerFactory</span>(<span class="params">ILoggerFactory loggerFactory</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _loggerFactory = loggerFactory;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> IWebHostBuilder <span class="title">UseSetting</span>(<span class="params"><span class="keyword">string</span> key, <span class="keyword">string</span> <span class="keyword">value</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _config[key] = <span class="keyword">value</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>默认创建了一个 <code>Configuration</code> 类型的字段 <code>_config</code> 表示应用使用的配置，它默认采用环境变量(用于筛选环境变量的前缀为<code>ASPNETCORE_</code>)作为配置源，<code>GetSetting</code> 和 <code>UseSetting</code> 方法都在内部操作这个字段。另一个字段 <code>_loggerFactory</code> 表示默认使用的 <code>ILoggerFactory</code>，<code>UseLoggerFactory</code> 方法指定的 <code>LoggerFactory</code> 用来对这个字段进行赋值。<code>ConfigureLogging</code> 和 <code>ConfigureServices</code> 仅仅将传入的委托对象保存在一个集合中。</p>
<p><code>Build</code> 方法实现创建 <code>WebHost</code> 对象并注册必要的服务，以下列出这些服务的不完全列表:</p>
<ul>
<li>用于注册服务和中间件的 <code>Startup</code> 对象。</li>
<li>用来创建 <code>Logger</code> 的 <code>LoggerFactory</code> 对象</li>
<li>构建中间件链表的 <code>ApplicationBuilder</code> 对象</li>
<li>创建 HTTP 上下文的 <code>HttpContextFactory</code> 对象</li>
<li>用户实现诊断功能的 <code>DiagnosticSource</code> 对象</li>
<li>用来保存承载环境的 <code>HostingEnvironment</code> 对象</li>
</ul>
<p>以下代码展示了 <code>Build</code> 方法的实现:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WebHostBuilder</span> : <span class="title">IWebHostBuilder</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Action&lt;ILoggerFactory&gt;&gt; _configureLoggingDelegates = <span class="keyword">new</span> List&lt;Action&lt;ILoggerFactory&gt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> List&lt;Action&lt;IServiceCollection&gt;&gt; _configureServicesDelegates = <span class="keyword">new</span> List&lt;Action&lt;IServiceCollection&gt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> ILoggerFactory _loggerFactory = <span class="keyword">new</span> LoggerFactory();</span><br><span class="line">    <span class="keyword">private</span> IConfiguration _config = <span class="keyword">new</span> ConfigurationBuilder().AddInMemoryCollection().Build();</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> IWebHost <span class="title">Build</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//根据配置创建WebHostOptions</span></span><br><span class="line">        WebHostOptions options = <span class="keyword">new</span> WebHostOptions(_config);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//注册服务IStartup</span></span><br><span class="line">        IServiceCollection services = <span class="keyword">new</span> ServiceCollection();</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">string</span>.IsNullOrEmpty(options.StartupAssembly))</span><br><span class="line">        &#123;</span><br><span class="line">            Type startupType = StartupLoader.FindStartupType(options.StartupAssembly, options.Environment);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span>(IStartup).GetTypeInfo().IsAssignableFrom(startupType))</span><br><span class="line">            &#123;</span><br><span class="line">               services.AddSingleton(<span class="keyword">typeof</span>(IStartup), startupType);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                services.AddSingleton&lt;IStartup&gt;(_ =&gt; <span class="keyword">new</span> ConventionBasedStartup(StartupLoader.LoadMethods(_, startupType, options.Environment)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//注册ILoggerFactory</span></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> configureLogging <span class="keyword">in</span> _configureLoggingDelegates)</span><br><span class="line">        &#123;</span><br><span class="line">            configureLogging(_loggerFactory);</span><br><span class="line">        &#125;</span><br><span class="line">        services.AddSingleton&lt;ILoggerFactory&gt;(_loggerFactory);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//注册服务IApplicationBuilder，DiagnosticSource和IHttpContextFactory</span></span><br><span class="line">        services</span><br><span class="line">            .AddSingleton&lt;IApplicationBuilder&gt;(_ =&gt; <span class="keyword">new</span> ApplicationBuilder(_))</span><br><span class="line">            .AddSingleton&lt;DiagnosticSource&gt;(<span class="keyword">new</span> DiagnosticListener(<span class="string">"Microsoft.AspNetCore"</span>))</span><br><span class="line">            .AddSingleton&lt;IHttpContextFactory, HttpContextFactory&gt;()</span><br><span class="line">            .AddOptions()</span><br><span class="line">            .AddLogging()</span><br><span class="line">            .AddSingleton&lt;IHostingEnvironment, HostingEnvironment&gt;()</span><br><span class="line">            .AddSingleton&lt;ObjectPoolProvider, DefaultObjectPoolProvider&gt;();          </span><br><span class="line">                      </span><br><span class="line">        <span class="comment">//注册用户调用ConfigureServices方法设置的服务</span></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> configureServices <span class="keyword">in</span> _configureServicesDelegates)</span><br><span class="line">        &#123;</span><br><span class="line">            configureServices(services);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//创建MyWebHost</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WebHost(services, services.BuildServiceProvider(), options, _config);</span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></p>
<h2 id="几个常用的扩展方法"><a href="#几个常用的扩展方法" class="headerlink" title="几个常用的扩展方法"></a>几个常用的扩展方法</h2><p>除了使用 <code>GetSetting</code> 和 <code>UseSetting</code> 方法来以键值对的形式来获取和设置配置项，还可以通过 <code>UseConfiguration</code> 扩展方法直接指定一个 <code>IConfiguration</code> 对象作为参数，该对象会原封不动的拷贝至内部的配置项中，其内部依旧是调用了 <code>UseSettings</code> 方法来实现的。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">HostingAbstractionsWebHostBuilderExtensions</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IWebHostBuilder <span class="title">UseConfiguration</span>(<span class="params"><span class="keyword">this</span> IWebHostBuilder hostBuilder, IConfiguration configuration</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>WebHostBuilder</code> 在创建 <code>WebHost</code> 的时候需要一个 <code>WebHostOptions</code> 对象，为了方便设置 <code>WebHostOptions</code> 的配置项，ASP.NET Core 定义了一系列扩展方法，这些方法最终也是通过 <code>UseSettings</code> 方法。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">HostingAbstractionsWebHostBuilderExtensions</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IWebHostBuilder <span class="title">CaptureStartupErrors</span>(<span class="params"><span class="keyword">this</span> IWebHostBuilder hostBuilder, <span class="keyword">bool</span> captureStartupErrors</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IWebHostBuilder <span class="title">UseContentRoot</span>(<span class="params"><span class="keyword">this</span> IWebHostBuilder hostBuilder, <span class="keyword">string</span> contentRoot</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IWebHostBuilder <span class="title">UseEnvironment</span>(<span class="params"><span class="keyword">this</span> IWebHostBuilder hostBuilder, <span class="keyword">string</span> environment</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IWebHostBuilder <span class="title">UseStartup</span>(<span class="params"><span class="keyword">this</span> IWebHostBuilder hostBuilder, <span class="keyword">string</span> startupAssemblyName</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IWebHostBuilder <span class="title">UseWebRoot</span>(<span class="params"><span class="keyword">this</span> IWebHostBuilder hostBuilder, <span class="keyword">string</span> webRoot</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IWebHostBuilder <span class="title">UseUrls</span>(<span class="params"><span class="keyword">this</span> IWebHostBuilder hostBuilder, <span class="keyword">params</span> <span class="keyword">string</span>[] urls</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IWebHostBuilder <span class="title">UseServer</span>(<span class="params"><span class="keyword">this</span> IWebHostBuilder hostBuilder, IServer server</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IWebHostBuilder <span class="title">UseUrls</span>(<span class="params"><span class="keyword">this</span> IWebHostBuilder hostBuilder, <span class="keyword">params</span> <span class="keyword">string</span>[] urls</span>)</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="HttpContext"><a href="#HttpContext" class="headerlink" title="HttpContext"></a>HttpContext</h1><p>对于管道来说，<strong>请求的接收者和最终响应者都是服务器，服务器接收到请求之后会创建与之对应的「原始上下文」，请求的响应也通过这个「原始上下文」来完成。</strong></p>
<p>但对于建立在管道上的应用程序来说，它们不需要关注管道究竟采用了何种类型的服务器，更不会关注由这个服务器创建的<strong>「原始上下文」</strong>。ASP.NET Core 定义了 <code>HttpContext</code> 抽象类来描述当前请求的上下文，<strong>对当前上下文的抽象解除了管道对具体服务器类型的依赖</strong>，这使得可以为 ASP.NET Core 应用程序自由地选择寄宿(<code>Hosting</code>)方式，而不是像传统的 ASP.NET 应用一样只能寄宿在 IIS 中。抽象的 <code>HttpContext</code> 为请求处理提供了标准化的方式，这使得位于管道中的中间件与具体的服务器类型进行了解耦，中间件只要遵循标准来实现其自身的逻辑即可。<code>HttpContext</code> 包含了当前请求的所有细节，可以直接利用它完成对请求的响应:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">HttpContext</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> IFeatureCollection Features &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> HttpRequest Request &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> HttpResponse Response &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> ConnectionInfo Connection &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> WebSocketManager WebSockets &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> AuthenticationManager Authentication &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> ClaimsPrincipal User &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> IDictionary&lt;<span class="keyword">object</span>, <span class="keyword">object</span>&gt; Items &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> IServiceProvider RequestServices &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> CancellationToken RequestAborted &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">string</span> TraceIdentifier &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> ISession Session &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Abort</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当需要中止对请求的处理时，可通过为 <code>RequestAborted</code> 属性设置一个 <code>CancellationToken</code> 对象将终止通知发送给管道。如果需要对整个管道共享一些与当前上下文相关的数据，可以将它保存在 <code>Items</code> 属性表示的字典中。<code>RequestServices</code> 属性返回一个 <code>IServiceProvider</code> 对象，该对象为中间件提供注册的服务实例，只要相应的服务事先注册到指定的服务接口上，就可以利用这个 <code>IServiceProvider</code> 来获取对应的服务对象。</p>
<p>表示请求和响应的 <code>HttpRequest</code> 和 <code>HttpResponse</code> 同样是抽象类:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">HttpRequest</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">abstract</span> QueryString QueryString &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">abstract</span> Stream Body &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">string</span> ContentType &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span>? ContentLength &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">abstract</span> IRequestCookieCollection Cookies &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">abstract</span> IHeaderDictionary Headers &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">string</span> Protocol &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">abstract</span> IQueryCollection Query &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">abstract</span> IFormCollection Form &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">abstract</span> PathString Path &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">abstract</span> PathString PathBase &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">abstract</span> HostString Host &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">bool</span> IsHttps &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">string</span> Scheme &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">string</span> Method &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">abstract</span> HttpContext HttpContext &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">bool</span> HasFormContentType &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Task&lt;IFormCollection&gt; <span class="title">ReadFormAsync</span>(<span class="params">CancellationToken cancellationToken = <span class="keyword">default</span>(CancellationToken</span>))</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">HttpResponse</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">abstract</span> HttpContext HttpContext &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> StatusCode &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">abstract</span> IHeaderDictionary Headers &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">abstract</span> Stream Body &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span>? ContentLength &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">string</span> ContentType &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">abstract</span> IResponseCookies Cookies &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">bool</span> HasStarted &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">OnCompleted</span>(<span class="params">Func&lt;<span class="keyword">object</span>, Task&gt; callback, <span class="keyword">object</span> state</span>)</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnCompleted</span>(<span class="params">Func&lt;Task&gt; callback</span>)</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">OnStarting</span>(<span class="params">Func&lt;<span class="keyword">object</span>, Task&gt; callback, <span class="keyword">object</span> state</span>)</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnStarting</span>(<span class="params">Func&lt;Task&gt; callback</span>)</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Redirect</span>(<span class="params"><span class="keyword">string</span> location</span>)</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Redirect</span>(<span class="params"><span class="keyword">string</span> location, <span class="keyword">bool</span> permanent</span>)</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">RegisterForDispose</span>(<span class="params">IDisposable disposable</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="FeatureCollection"><a href="#FeatureCollection" class="headerlink" title="FeatureCollection"></a>FeatureCollection</h2><p>在 ASP.NET Core 管道式处理设计中，特性是一个非常重要的概念，它是实现抽象化的 <code>HttpContext</code> 的途径，不同类型的服务器在接收到请求时会创建一个<strong>「原始上下文」</strong>，接下来服务器将<strong>「原始上下文」</strong>的操作封装成一系列标准的特性对象(<code>IFeature</code>)，进而封装成一个 <code>FeatureCollection</code> 对象，当调用 <code>DefaultHttpContext</code> 相应的属性和方法时，其内部又借助封装的特性对象去操作<strong>「原始上下文」</strong>。</p>
<p>当原始上下文被创建出来之后，服务器会将它封装成一系列标准的特性对象，<code>HttpContext</code> 正是对这些特性对象的封装。这些特性对象对应的类型均实现了某个预定义的标准接口，接口定义了相应的属性来读写原始上下文中描述的信息，还定义了相应的方法来操作原始上下文。<code>HttpContext</code> 的 <code>Features</code> 属性返回这组特性对象的集合，类型为 <code>IFeatureCollection</code>，该接口用于描述某个对象所具有的一组特性，我们可以将其视为一个 <code>Dictionary&lt;Type, object&gt;</code> 对象，字典的 Value 代表特性对象，Key 则表示该对象的注册类型(特性描述对象的具体类型，具体类型的基类或者接口)。调用 <code>Set</code> 方法来注册特性对象，而 <code>Get</code> 方法则根据指定的注册类型得到对应的特性对象。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface IFeatureCollection : IEnumerable&lt;KeyValuePair&lt;Type, object&gt;&gt;, IEnumerable</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">object</span> <span class="keyword">this</span>[Type key] &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">bool</span> IsReadOnly &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">int</span> Revision &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    TFeature Get&lt;TFeature&gt;();</span><br><span class="line">    <span class="keyword">void</span> Set&lt;TFeature&gt;(TFeature instance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>特性对象的注册和获取也可以通过的索引器来完成。如果 <code>IsReadOnly</code> 属性返回 True，便不能注册新的特性或修改已经注册的特性。只读属性 <code>Revision</code> 可视为 <code>IFeatureCollection</code> 对象的版本，注册新特性或修改现有的特性都将改变这个属性的值。</p>
<p><code>IFeatureCollection</code> 的默认实现类型是 <code>FeatureCollection</code>:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FeatureCollection</span> : <span class="title">IFeatureCollection</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="comment">//其他成员</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FeatureCollection</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FeatureCollection</span>(<span class="params">IFeatureCollection defaults</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>FeatureCollection</code> 类型的 <code>IsReadOnly</code> 总是返回 False，如果调用无参构造函数，它的 <code>Revision</code> 默认返回 0。如果调用第二个构造函数，其 <code>Revision</code> 属性将延续传入参数的 <code>IFeatureCollection.Revision</code> 的值，并采用递增来修改其值。</p>
<h2 id="DefaultHttpContext"><a href="#DefaultHttpContext" class="headerlink" title="DefaultHttpContext"></a>DefaultHttpContext</h2><p>ASP.NET Core 使用 <code>DefaultHttpContext</code> 类型作为 <code>HttpContext</code> 的默认实现，原始上下文由「特性集合」来创建 <code>HttpContext</code> 的策略就体现在该类型上。<br><img src="/aspnetcore-fundamentals-pipelines/pipes_06.png" title="原始上下文与 DefaultHttpContext 的关系"><br><code>DefaultHttpContext</code> 的构造函数如下:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DefaultHttpContext</span> : <span class="title">HttpContext</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultHttpContext</span>(<span class="params">IFeatureCollection features</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>无论是组成管道的中间件还是建立在管道上的应用程序，都统一采用 <code>DefaultHttpContext</code> 对象来获取请求信息，并利用它完成对请求的响应。针对 <code>DefaultHttpContext</code> 的调用(属性或方法)最终都转发给具体服务器创建的<strong>「原始上下文」</strong>，构造函数接收的 <code>FeatureCollection</code> 对象所代表的特性集合是这两个上下文对象进行沟通的唯一渠道。定义在 <code>DefaultHttpContext</code> 中的所有属性几乎都具有一个对应的特性，这些特性又都对应一个接口。下表列出了部分特性接口以及 <code>DefaultHttpContext</code> 对应的属性:</p>
<table>
<thead>
<tr>
<th>接口</th>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>IHttpRequestFeature</td>
<td>Request</td>
<td>获取描述请求的基本信息</td>
</tr>
<tr>
<td>IHttpResponsetFeature</td>
<td>Response</td>
<td>控制对请求的响应</td>
</tr>
<tr>
<td>IHttpAuthenticationFeature</td>
<td>AuthenticationManger/User</td>
<td>提供用户认证的 AuthenticationHandler 对象和表示当前用户的 ClaimsPrincipal 对象</td>
</tr>
<tr>
<td>IHttpConnectionFeature</td>
<td>Connection</td>
<td>提供描述当前 HTTP 连接的基本信息。</td>
</tr>
<tr>
<td>IItemsFeature</td>
<td>Items</td>
<td>提供客户代码存放关于当前请求的对象容器。</td>
</tr>
<tr>
<td>IHttpRequestLifetimeFeature</td>
<td>RequestAborted</td>
<td>传递请求处理取消通知和中止当前请求处理。</td>
</tr>
<tr>
<td>IServiceProvidersFeature</td>
<td>RequestServices</td>
<td>提供根据服务注册创建的 ServiceProvider。</td>
</tr>
<tr>
<td>ISessionFeature</td>
<td>Session</td>
<td>提供描述当前会话的 Session 对象。</td>
</tr>
<tr>
<td>IHttpRequestIdentifierFeature</td>
<td>TraceIdentifier</td>
<td>为追踪日志(Trace)提供针对当前请求的唯一标识。</td>
</tr>
<tr>
<td>IHttpWebSocketFeature</td>
<td>WebSockets</td>
<td>管理 WebSocket</td>
</tr>
</tbody>
</table>
<p>其中最重要的两个接口为表示请求和响应的 <code>IHttpRequestFeature</code> 和 <code>IHttpResponseFeature</code>。这两个接口分别与抽象类 <code>HttpRequest</code> 和 <code>HttpResponse</code> 具有一致的定义。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IHttpRequestFeature</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">string</span> Protocol &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">string</span> Scheme &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">string</span> Method &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">string</span> PathBase &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">string</span> Path &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">string</span> QueryString &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">string</span> RawTarget &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        IHeaderDictionary Headers &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        Stream Body &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IHttpResponseFeature</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">int</span> StatusCode &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">string</span> ReasonPhrase &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        IHeaderDictionary Headers &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        Stream Body &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">bool</span> HasStarted &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">OnCompleted</span>(<span class="params">Func&lt;<span class="keyword">object</span>, Task&gt; callback, <span class="keyword">object</span> state</span>)</span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">OnStarting</span>(<span class="params">Func&lt;<span class="keyword">object</span>, Task&gt; callback, <span class="keyword">object</span> state</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>DefaultHttpContext</code> 对象中表示请求和响应的 <code>Request</code> 和 <code>Response</code> 属性就是分别提取 <code>HttpRequestFeature</code> 和 <code>HttpResponseFeature</code> 特性创建出 <code>DefaultHttpRequest</code> 和 <code>DefaultHttpResponse</code> 对象，它们分别继承自 <code>HttpRequest</code> 和 <code>HttpResponse</code>。以下是伪代码的实现:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DefaultHttpRequest</span> : <span class="title">HttpRequest</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> IHttpRequestFeature RequestFeature &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultHttpRequest</span>(<span class="params">DefaultHttpContext context</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.RequestFeature = context.HttpContextFeatures.Get&lt;IHttpRequestFeature&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> Uri Url</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> <span class="keyword">this</span>.RequestFeature.Url; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">string</span> PathBase</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> <span class="keyword">this</span>.RequestFeature.PathBase; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DefaultHttpResponse</span> : <span class="title">HttpResponse</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> IHttpResponseFeature ResponseFeature &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> Stream OutputStream</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> <span class="keyword">this</span>.ResponseFeature.OutputStream; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">string</span> ContentType</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> <span class="keyword">this</span>.ResponseFeature.ContentType; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; <span class="keyword">this</span>.ResponseFeature.ContentType = <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">int</span> StatusCode</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> <span class="keyword">this</span>.ResponseFeature.StatusCode; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; <span class="keyword">this</span>.ResponseFeature.StatusCode = <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultHttpResponse</span>(<span class="params">DefaultHttpContext context</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ResponseFeature = context.HttpContextFeatures.Get&lt;IHttpResponseFeature&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="HttpContextFactory"><a href="#HttpContextFactory" class="headerlink" title="HttpContextFactory"></a>HttpContextFactory</h2><p>在服务器接收到请求时，它并不是直接利用原始上下文来创建 <code>HttpContext</code> 对象，而是通过 <code>HttpContextFactory</code> 来创建。<code>IHttpContextFactory</code> 接口除了定义创建 <code>HttpContext</code> 对象的 <code>Create</code> 方法之外，还定义了一个 <code>Dispose</code> 方法来释放指定的 <code>HttpContext</code> 对象。 <code>HttpContextFactory</code> 类是该接口的默认实现者，由它的 <code>Create</code> 方法创建并返回的是一个 <code>DefaultHttpContext</code> 对象:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IHttpContextFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">HttpContext <span class="title">Create</span>(<span class="params">IFeatureCollection featureCollection</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Dispose</span>(<span class="params">HttpContext httpContext</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HttpContextFactory</span> : <span class="title">IHttpContextFactory</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="comment">//省略其他成员</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HttpContext <span class="title">Create</span>(<span class="params">IFeatureCollection featureCollection</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span>(<span class="params">HttpContext httpContext</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上涉及的类型和接口和所在的命名空间：</p>
<table>
<thead>
<tr>
<th>类型或接口</th>
<th>命名空间</th>
</tr>
</thead>
<tbody>
<tr>
<td>HttpContext</td>
<td>Microsoft.AspNetCore.Http</td>
</tr>
<tr>
<td>HttpRequest</td>
<td>Microsoft.AspNetCore.Http</td>
</tr>
<tr>
<td>HttpResponse</td>
<td>Microsoft.AspNetCore.Http</td>
</tr>
<tr>
<td>DefaultHttpRequest</td>
<td>Microsoft.AspNetCore.Http.Internal</td>
</tr>
<tr>
<td>DefaultHttpResponse</td>
<td>Microsoft.AspNetCore.Http.Internal</td>
</tr>
<tr>
<td>IHttpRequestFeature</td>
<td>Microsoft.AspNetCore.Http.Features</td>
</tr>
<tr>
<td>IHttpResponseFeature</td>
<td>Microsoft.AspNetCore.Http.Features</td>
</tr>
</tbody>
</table>
<p>以及它们之间的 UML 关系图:<br><img src="/aspnetcore-fundamentals-pipelines/pipes_07.png" title="对象关系图"></p>
<h1 id="ApplicationBulder"><a href="#ApplicationBulder" class="headerlink" title="ApplicationBulder"></a>ApplicationBulder</h1><p>创建 <code>WebHost</code> 的 <code>WebHostBuilder</code> 提供了一个用于管道定制的 <code>Configure</code> 方法，它利用 <code>ApplicationBuilder</code> 参数进行中间件的注册。中间件在请求处理流程中体现为一个类型为 <code>Func&lt;RequestDelegate，RequestDelegate&gt;</code> 的委托对象，<code>RequestDelegate</code> 相当于一个 <code>Func&lt;HttpContext, Task&gt;</code> 对象，它体现了针对 <code>HttpContext</code> 所进行的某项操作，进而代表某个中间件针对请求的处理过程。那为何我们不直接用一个 <code>RequestDelegate</code> 对象来表示一个中间件，而将它表示成一个 <code>Func&lt;RequestDelegate，RequestDelegate&gt;</code> 对象呢？</p>
<p>在多数情况下，具体的请求处理需要注册多个不同的中间件，这些中间件按照注册时间的顺序进行排列构成了管道。对于单个中间件来说，在它完成了自身的请求处理任务之后，需要将请求传递给下一个中间件作后续的处理。<code>Func&lt;RequestDelegate，RequestDelegate&gt;</code> 中作为输入参数的 <code>RequestDelegate</code> 对象代表一个委托链，体现了后续中间件对请求的处理。当某个中间件将自身实现的请求处理任务添加到这个委托链中，新的委托链将作为这个 <code>Func&lt;RequestDelegate，RequestDelegate&gt;</code> 对象的返回值。<br><img src="/aspnetcore-fundamentals-pipelines/pipes_09.png" title="中间件的委托链"><br>以上图为例，如果用一个 <code>Func&lt;RequestDelegate，RequestDelegate&gt;</code> 来表示中间件 B，那么作为输入参数的 <code>RequestDelegate</code> 对象代表的是中间件 C 对请求的处理操作，而返回值则代表 B 和 C 先后对请求的处理操作。如果一个 <code>Func&lt;RequestDelegate，RequestDelegate&gt;</code> 代表第一个从服务器接收请求的中间件(比如 A)，那么执行该委托对象返回的 <code>RequestDelegate</code> 实际上体现了整个管道对请求的处理。</p>
<p>现在，来看看 <code>IApplicationBuilder</code> 接口的定义:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IApplicationBuilder</span></span><br><span class="line">&#123;</span><br><span class="line">    IServiceProvider             ApplicationServices &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    IFeatureCollection           ServerFeatures &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    IDictionary&lt;<span class="keyword">string</span>, <span class="keyword">object</span>&gt;  Properties &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">RequestDelegate         <span class="title">Build</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function">IApplicationBuilder     <span class="title">New</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function">IApplicationBuilder     <span class="title">Use</span>(<span class="params">Func&lt;RequestDelegate, RequestDelegate&gt; middleware</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>Use</code> 方法实现对中间件的注册，而 <code>Build</code> 方法则将所有注册的中间件转换成一个 <code>RequestDelegate</code> 对象。除了这两个核心方法，<code>IApplicationBuilder</code> 接口还定义了三个属性，其中 <code>ApplicationServices</code> 返回根据最初服务注册生成的 <code>ServiceProvider</code> 对象，而 <code>ServerFeatures</code> 属性返回的 <code>FeatureCollection</code> 对象是描述 <code>Server</code> 的特性集合。字典类型的 <code>Properties</code> 属性供用户存储任意自定义的属性，而 <code>New</code> 方法会根据自己「克隆」出一个新的 <code>ApplicationBuilder</code> 对象，这两个 <code>ApplicationBuilder</code> 对象应用具有相同的属性集合。</p>
<p>从编程便利性考虑，很多预定义的中间件类型都具有对应的用来注册的扩展方法，比如 <code>UseStaticFiles</code> 注册处理静态文件请求的中间件。</p>
<p><code>ApplicationBuilder</code> 类型是 <code>IApplicationBuilder</code> 的默认实现者，其定义了一个 <code>List&lt;Func&lt;RequestDelegate, RequestDelegate&gt;&gt;</code> 属性来存放所有注册的中间件，<code>Use</code> 方法只需要将指定的中间件添加到这个列表即可，而 <code>Build</code> 方法只需要逆序调用这些中间件对应的 <code>Func&lt;RequestDelegate, RequestDelegate&gt;</code> 对象就能得需要的 <code>RequestDelegate</code> 对象。值得一提的是，<code>Build</code> 方法在中间件链条的尾部添加了一个额外的中间件，该中间件会负责将响应状态码设置为 404，如果没有注册任何对请求作最终响应的中间件(这样的中间件将不会试图调用后续中间件)，整个管道会回复一个状态码为 404 的响应。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ApplicationBuilder</span> : <span class="title">IApplicationBuilder</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> IList&lt;Func&lt;RequestDelegate, RequestDelegate&gt;&gt; middlewares = <span class="keyword">new</span> List&lt;Func&lt;RequestDelegate, RequestDelegate&gt;&gt;();  </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> RequestDelegate <span class="title">Build</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        RequestDelegate app = context =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            context.Response.StatusCode = <span class="number">404</span>;</span><br><span class="line">            <span class="keyword">return</span> Task.FromResult(<span class="number">0</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> component <span class="keyword">in</span> middlewares.Reverse())</span><br><span class="line">        &#123;</span><br><span class="line">            app = component(app);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> app;</span><br><span class="line">    &#125;    </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> IApplicationBuilder <span class="title">Use</span>(<span class="params">Func&lt;RequestDelegate, RequestDelegate&gt; middleware</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        middlewares.Add(middleware);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="ApplicationBuilderFactory"><a href="#ApplicationBuilderFactory" class="headerlink" title="ApplicationBuilderFactory"></a>ApplicationBuilderFactory</h2><p><code>IApplicationBuilderFactory</code> 是 ASP.NET Core 用来创建 <code>IApplicationBuilder</code> 的工厂，如下面的代码片段所示，该接口定义了唯一个方法 <code>CreateBuilder</code> 接收 <code>FeatureCollection</code> 对象参数 来创建 <code>IApplicationBuilder</code> 对象，该 <code>IFeatureCollection</code> 对象正是承载与服务器相关特性的集合。<code>ApplicationBuilderFactory</code> 类型是该接口的默认实现者，当 <code>CreateBuilder</code> 方法被调用的时候，它会直接将构造时提供 <code>ServiceProvider</code> 对象和 <code>serverFeatures</code> 参数表示的 <code>IFeatureCollection</code> 对象来创建 <code>ApplicationBuilder</code> 对象。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IApplicationBuilderFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">IApplicationBuilder <span class="title">CreateBuilder</span>(<span class="params">IFeatureCollection serverFeatures</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ApplicationBuilderFactory</span> : <span class="title">IApplicationBuilderFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IServiceProvider _serviceProvider;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ApplicationBuilderFactory</span>(<span class="params">IServiceProvider serviceProvider</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>._serviceProvider = serviceProvider;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> IApplicationBuilder <span class="title">CreateBuilder</span>(<span class="params">IFeatureCollection serverFeatures</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApplicationBuilder(_serviceProvider, serverFeatures);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h1 id="中间件类型"><a href="#中间件类型" class="headerlink" title="中间件类型"></a>中间件类型</h1><p>虽然中间件最终体现为一个类型为 Func&lt;RequestDelegate, RequestDelegate&gt; 的委托对象，但是大部分情况下都会将中间件定义成一个单独的类型。中间件类型不要求实现某个接口或继承某个基类，但要遵循几个必要的约定。现在通过 ContentMiddleware 类来看看一个合法的中间件类型应该如何定义。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ContentMiddleare</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> RequestDelegate     _next;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[]         _content;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span>         _contentType;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ContentMiddleare</span>(<span class="params">RequestDelegate next, <span class="keyword">byte</span>[] content, <span class="keyword">string</span> contentType</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _next         = next;</span><br><span class="line">        _content      = content;</span><br><span class="line">        _contentType  = contentType;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">Invoke</span>(<span class="params">HttpContext context, ILoggerFactory loggerFactory</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        loggerFactory.CreateLogger&lt;ContentMiddleare&gt;().LogInformation(<span class="string">$"Write content (<span class="subst">&#123;_contentType&#125;</span>)"</span>);</span><br><span class="line">        context.Response.ContentType = _contentType;</span><br><span class="line">        <span class="keyword">await</span> context.Response.Body.WriteAsync(_content,<span class="number">0</span>, _content.Length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>ContentMiddleware 中间件将任何类型的内容响应给客户端，它的 _content 和 _contentType 两个字段分别代表响应内容和媒体类型(内容类型或者 MIME 类型)，它体现了一个典型中间件类型的定义规则或者约定:</p>
<ul>
<li>应该定义为非静态类。</li>
<li>具有一个公共构造函数。这个构造函数的第一个参数类型必须为 <code>RequestDelegate</code>，代表对请求的后续操作(可以视为下一个注册的中间件)</li>
<li>针对请求的处理定义在一个名为 <code>Invoke</code> 的公共实例方法，其返回类型为 Task。该方法的第一个参数类型为 <code>HttpContext</code>，代表当前 HTTP 上下文。可以为这个方法定义任意数量和类型的额外参数，当这个方法被执行的时候，系统将会采用依赖注入的方式为这些参数赋值。</li>
</ul>
<h2 id="中间件类型注册"><a href="#中间件类型注册" class="headerlink" title="中间件类型注册"></a>中间件类型注册</h2><p>中间件类型的注册可以通过调用 <code>IApplicationBuilder</code> 接口的扩展方法 <code>UseMiddleware</code> 和 <code>UseMiddleware&lt;TMiddleware&gt;</code> 来注册。除了指定中间件的类型之外，我们还需要按照顺序指定目标构造函数的全部或部分参数。不过构造函数的第一个参数 <code>RequestDelegate</code> 不需要提供，如果只指定了部分参数，缺失的参数将会通过 <code>ServiceProvider</code> 提供。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">UseMiddlewareExtensions</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> IApplicationBuilder UseMiddleware&lt;TMiddleware&gt;(<span class="keyword">this</span> IApplicationBuilder app, <span class="keyword">params</span> <span class="keyword">object</span>[] args);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IApplicationBuilder <span class="title">UseMiddleware</span>(<span class="params"><span class="keyword">this</span> IApplicationBuilder app, Type middleware, <span class="keyword">params</span> <span class="keyword">object</span>[] args</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以按照下面的方式来注册上面定义的 ContentMiddleware 中间件:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> WebHostBuilder()</span><br><span class="line">    .Configure(app =&gt; app.UseMiddleware&lt;ContentMiddleare&gt;(File.ReadAllBytes(<span class="string">"girl.png"</span>),<span class="string">"image/png"</span>))</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://berdypango.github.io/aspnetcore-fundamentals-logging/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Frost He">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FrostHe.Handbook">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/aspnetcore-fundamentals-logging/" itemprop="url">ASP.NET Core 框架基础 - 日志系统</a></h1>
        

        <div class="post-meta">
          
          <span class="post-time">
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  0
                </span>
              

              

              
            </div>
          

          
              <div class="post-description">
                  .NET Core 提供了独立的日志模型使我们可以采用统一的 API 来完成针对日志记录的编程，同时也可以利用其扩展点对这个模型进行定制
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>参考资料: </p>
<ul>
<li><a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/logging/?view=aspnetcore-2.1&amp;tabs=aspnetcore2x" target="_blank" rel="noopener">Logging in ASP.NET Core</a></li>
<li><a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/logging/loggermessage?view=aspnetcore-2.1" target="_blank" rel="noopener">Logging with Logger Message</a></li>
<li><a href="http://www.cnblogs.com/artech/p/logging-for-net-core-01.html" target="_blank" rel="noopener">.NET Core 的日志</a></li>
</ul>
<p>本文大纲:<br><!-- TOC --></p>
<ul>
<li><a href="#%E5%89%8D%E8%A8%80">前言</a></li>
<li><a href="#%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9E%8B%E4%B8%89%E8%A6%81%E7%B4%A0">日志模型三要素</a></li>
<li><a href="#%E5%88%9B%E5%BB%BA-logger">创建 Logger</a></li>
<li><a href="#%E9%87%87%E7%94%A8%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%9D%A5%E5%88%9B%E5%BB%BA%E6%97%A5%E5%BF%97">采用依赖注入来创建日志</a></li>
<li><a href="#%E6%97%A5%E5%BF%97%E7%B1%BB%E5%88%ABcategory">日志类别(Category)</a></li>
<li><a href="#%E6%97%A5%E5%BF%97%E7%BA%A7%E5%88%ABloglevel">日志级别(LogLevel)</a></li>
<li><a href="#%E6%97%A5%E5%BF%97%E4%BA%8B%E4%BB%B6-ideventid">日志事件 ID(EventId)</a></li>
<li><a href="#%E6%97%A5%E5%BF%97%E6%B6%88%E6%81%AF%E6%A8%A1%E6%9D%BFmessage-template">日志消息模板(Message Template)</a></li>
<li><a href="#%E6%97%A5%E5%BF%97%E8%BF%87%E6%BB%A4">日志过滤</a><ul>
<li><a href="#%E9%80%9A%E8%BF%87%E9%85%8D%E7%BD%AE%E5%88%9B%E5%BB%BA%E6%97%A5%E5%BF%97%E8%BF%87%E6%BB%A4%E8%A7%84%E5%88%99">通过配置创建日志过滤规则</a></li>
<li><a href="#%E4%BB%A5%E7%BC%96%E7%A8%8B%E6%96%B9%E5%BC%8F%E5%88%9B%E5%BB%BA%E6%97%A5%E5%BF%97%E8%BF%87%E6%BB%A4%E8%A7%84%E5%88%99">以编程方式创建日志过滤规则</a></li>
<li><a href="#%E6%97%A5%E5%BF%97%E8%BF%87%E6%BB%A4%E8%A7%84%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95">日志过滤规匹配算法</a></li>
<li><a href="#%E6%97%A5%E5%BF%97%E6%8F%90%E4%BE%9B%E5%99%A8%E5%88%AB%E5%90%8D">日志提供器别名</a></li>
<li><a href="#%E9%BB%98%E8%AE%A4%E6%9C%80%E5%B0%8F%E6%97%A5%E5%BF%97%E7%BA%A7%E5%88%AB">默认最小日志级别</a></li>
<li><a href="#%E6%97%A5%E5%BF%97%E5%85%A8%E5%B1%80%E8%BF%87%E6%BB%A4%E5%99%A8%E5%A7%94%E6%89%98">日志全局过滤器委托</a></li>
</ul>
</li>
<li><a href="#%E6%97%A5%E5%BF%97%E5%8C%BA%E9%99%90log-scopes">日志区限(Log Scopes)</a></li>
<li><a href="#%E5%86%85%E7%BD%AE%E6%97%A5%E5%BF%97%E6%8F%90%E4%BE%9B%E5%99%A8">内置日志提供器</a><ul>
<li><a href="#console-%E6%8F%90%E4%BE%9B%E5%99%A8">Console 提供器</a></li>
<li><a href="#debug-%E6%8F%90%E4%BE%9B%E5%99%A8">Debug 提供器</a></li>
<li><a href="#eventsource-%E6%8F%90%E4%BE%9B%E5%99%A8">EventSource 提供器</a></li>
<li><a href="#windows-eventlog-%E6%8F%90%E4%BE%9B%E5%99%A8">Windows EventLog 提供器</a></li>
<li><a href="#tracesource-%E6%8F%90%E4%BE%9B%E5%99%A8">TraceSource 提供器</a></li>
<li><a href="#azure-app-service-%E6%8F%90%E4%BE%9B%E5%99%A8">Azure App Service 提供器</a></li>
</ul>
</li>
<li><a href="#loggermessage-%E6%A8%A1%E5%BC%8F">LoggerMessage 模式</a><ul>
<li><a href="#loggermessagedefine">LoggerMessage.Define</a></li>
<li><a href="#loggermessagedefinescope">LoggerMessage.DefineScope</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>.NET Core提供了独立的日志模型使我们可以采用统一的 API 来完成针对日志记录的编程，我们同时也可以利用其扩展点对这个模型进行定制，比如可以将第三方日志提供器整合到我们的应用中。</p>
<h1 id="日志模型三要素"><a href="#日志模型三要素" class="headerlink" title="日志模型三要素"></a>日志模型三要素</h1><p>日志记录编程的核心对象:</p>
<ul>
<li>ILogger: 将日志消息写到对应的目的地(如文件，数据库等)</li>
<li>ILoggerFactory: 创建组合式的 Logger，该 Logger 其实是对一组 Logger 的封装，自身并不提供日志写入功能，而是委托内部封装的 Logger 来写日志。</li>
<li>ILoggerProvider: 创建具有写入日志功能的 Logger。</li>
</ul>
<p>LoggerFactory 可以注册多个 LoggerProvider 对象，在进行日志编程时，我们会利用 LoggerFactory 对象创建 Logger 来写日志，而该对象委托的内部 Logger 则由这些 LoggerProvider 提供。这三者的关系如下: </p>
<img src="/aspnetcore-fundamentals-logging/core-objects.png" title="三个核心对象之间的关系">
<h1 id="创建-Logger"><a href="#创建-Logger" class="headerlink" title="创建 Logger"></a>创建 Logger</h1><p>引入以下 Nuget Package 以实现原始的日志功能: </p>
<ul>
<li>Microsoft.Extensions.Logging.Abstractions: 引入 <code>ILoggerFactory</code> 和 <code>ILogger</code> 接口</li>
<li>Microsoft.Extensions.Logging: 引入 <code>ILoggerFactory</code> 的默认实现 <code>LoggerFactory</code></li>
<li>Microsoft.Extensions.Logging.Console: 引入 <code>ConsoleLoggerProvider</code></li>
<li>Microsoft.Extensions.Logging.Debug: 引入 <code>DebugLoggerProvider</code></li>
<li>System.Text.Encoding.CodePages: 由于 .NET Core 在默认情况下并不支持中文编码，需要在程序启动的时候显式注册一个支持中文编码的 <code>EncodingProvider</code></li>
</ul>
<p>首先创建 <code>LoggerFactory</code> 对象，然后通过 <code>AddProvider</code> 方法将一个 <code>ConsoleLoggerProvider</code> 和 <code>DebugLoggerProvider</code> 对象注册到 <code>LoggerFactory</code> 上，这两个 <code>LoggerProvider</code> 的构造函数接收一个 <code>Func&lt;string, LogLevel, bool&gt;</code> 类型的参数，该委托对象的两个输入参数分别代表日志消息的类型和等级，布尔类型的返回值决定创建的 <code>Logger</code> 是否会写入给定的日志消息。由于传入的委托对象总是返回 True，意味着所有级别的日志消息均会被这两个 <code>LoggerProvider</code> 创建的 <code>Logger</code> 对象写入对应的目的地。日志提供器注册完成之后，调用 <code>LoggerFactory</code> 的 <code>CreateLogger</code> 方法创建一个指定类别的 <code>Logger</code> 对象。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 注册 EncodingProvider 实现对中文编码的支持</span></span><br><span class="line">        Encoding.RegisterProvider(CodePagesEncodingProvider.Instance);</span><br><span class="line"></span><br><span class="line">        Func&lt;<span class="keyword">string</span>, LogLevel, <span class="keyword">bool</span>&gt; filter = (category, level) =&gt; <span class="literal">true</span>;</span><br><span class="line">        ILoggerFactory loggerFactory = <span class="keyword">new</span> LoggerFactory();</span><br><span class="line">        loggerFactory.AddProvider(<span class="keyword">new</span> ConsoleLoggerProvider(filter, <span class="literal">false</span>));</span><br><span class="line">        loggerFactory.AddProvider(<span class="keyword">new</span> DebugLoggerProvider(filter));</span><br><span class="line">        ILogger logger = loggerFactory.CreateLogger(<span class="keyword">nameof</span>(Program));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> eventId = <span class="number">3721</span>;</span><br><span class="line">        logger.LogInformation(eventId, <span class="string">$"升级到 .NET Core version 1.0.0"</span>);</span><br><span class="line">        logger.LogWarning(eventId, <span class="string">"并发量接近上限"</span>);</span><br><span class="line">        logger.LogError(eventId, <span class="string">"数据库连接失败(数据库：&#123;Database&#125;，用户名：&#123;User&#125;)"</span>, <span class="string">"TestDb"</span>, <span class="string">"sa"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="采用依赖注入来创建日志"><a href="#采用依赖注入来创建日志" class="headerlink" title="采用依赖注入来创建日志"></a>采用依赖注入来创建日志</h1><p>在 ASP.NET Core 应用中，总是以依赖注入的方式来获取相关的服务类型实例，<code>ILoggerFactory</code> 就是服务类型的一种。在创建 <code>ServiceCollection</code> 对象之后，调用 <code>AddLogging()</code> 向其注册日志服务，再从 <code>ServiceCollection</code> 对象中获取 <code>ILoggerFactory</code> 对象，调用 <code>ILoggerFactory</code> 的 <code>AddConsole()</code> 和 <code>AddDebug()</code> 扩展方法完成日志提供器向 <code>ILoggerFactory</code> 的注册。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> logger = <span class="keyword">new</span> ServiceCollection()</span><br><span class="line">    .AddLogging() <span class="comment">// call this extension method to register logging service</span></span><br><span class="line">    .BuildServiceProvider() <span class="comment">// build service provider to get services</span></span><br><span class="line">    .GetService&lt;ILoggerFactory&gt;() <span class="comment">// get ILoggerFactory service</span></span><br><span class="line">    .AddConsole() <span class="comment">// register console logger provider to logger factory</span></span><br><span class="line">    .AddDebug() <span class="comment">// register debug logger provider to logger factory</span></span><br><span class="line">    .CreateLogger(<span class="keyword">nameof</span>(Program)); <span class="comment">// create logger of category 'Program'</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>同一个 <code>LoggerFactory</code> 可以注册多个 <code>LoggerProvider，当</code> <code>LoggerFactory</code> 创建出相应的 <code>Logger</code> 对象来写入日志时，日志消息实际上会分发给所有 <code>LoggerProvider</code>。而每条日志消息都携带了日志等级， <code>LoggerProvider</code> 通过其构造函数传入的 Func 委托来过滤不同等级的日志消息，这样就实现了一条日志消息只写入特定的日志提供器的目的地。</p>
<h1 id="日志类别-Category"><a href="#日志类别-Category" class="headerlink" title="日志类别(Category)"></a>日志类别(Category)</h1><p>每一条日志消息都带有日志类别信息，在创建 ILogger 时可以指定类别，类别为任何字符串值，但按照惯例日志类别为类型的完全限定名，例如: “TodoApi.Controllers.TodoController”。</p>
<p>调用 <code>ILoggerFactory.CreateLogger</code> 时可以指定日志类别:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TodoController</span> : <span class="title">Controller</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ITodoRepository _todoRepository;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ILogger _logger;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TodoController</span>(<span class="params">ITodoRepository todoRepository,</span></span></span><br><span class="line"><span class="function"><span class="params">        ILoggerFactory logger</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _todoRepository = todoRepository;</span><br><span class="line">        _logger = logger.CreateLogger(<span class="string">"TodoApi.Controllers.TodoController"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>更多时候使用 <code>ILogger&lt;T&gt;</code> 则更简单:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TodoController</span> : <span class="title">Controller</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ITodoRepository _todoRepository;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ILogger _logger;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TodoController</span>(<span class="params">ITodoRepository todoRepository,</span></span></span><br><span class="line"><span class="function"><span class="params">        ILogger&lt;TodoController&gt; logger</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _todoRepository = todoRepository;</span><br><span class="line">        _logger = logger;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="日志级别-LogLevel"><a href="#日志级别-LogLevel" class="headerlink" title="日志级别(LogLevel)"></a>日志级别(LogLevel)</h1><p>日志级别由轻至重分别为: </p>
<ul>
<li>Trace = 0: 提供给发开人员用于跟踪和调试的信息，通常包含一些敏感数据，绝不能暴露给用户</li>
<li>Debug = 1: 在开发与调试阶段帮助开发人员分析调试的信息，这些消息通常是短期有效的信息，在部署环境中不会启用该级别</li>
<li>Information = 2: 记录应用程序的正常行为的日志级别，这些消息通常具有长期有效性。</li>
<li>Warning = 3: 记录应用程序运行期间不正常或意外事件的日志，这些行为不会导致应用程序崩溃但需要记录下来以供后续调查。</li>
<li>Error = 4: 记录无法被处理的错误及异常，这些消息指示在单一事务边界内失败，但不影响应用程序的其他部分</li>
<li>Critical = 5: 记录需要立即进行修正的致命错误，最高警戒级别</li>
</ul>
<p>ASP.NET Core 将框架级别的事件日志以 Debug 级别日志分发给不同的日志提供器。</p>
<h1 id="日志事件-ID-EventId"><a href="#日志事件-ID-EventId" class="headerlink" title="日志事件 ID(EventId)"></a>日志事件 ID(EventId)</h1><p>每记录一条日志，都可以为其指定事件 ID，事件 ID 用于将一系列相互关联的日志消息串起来，例如，将某件产品添加至购物车相关的日志的 ID 可为 1000，而与结账付款的事件 ID 可为 1001。日志事件 ID 以数据的形式将不同的日志进行逻辑分组，方便日后的查阅与分析。</p>
<h1 id="日志消息模板-Message-Template"><a href="#日志消息模板-Message-Template" class="headerlink" title="日志消息模板(Message Template)"></a>日志消息模板(Message Template)</h1><p>在调用 ILogger.Log() 时，需要为每条日志消息提供消息模板，该消息模板不同于传统 C# 格式化字符串和最新的插值字符串，其中包含命名占位符而不是数字占位符，填充到占位符的顺序又不与其名称相对应，而是按照占位符的顺序，日志框架这样设计是为了让日志提供器能够实现语义化或结构化的日志存储。如果采用以下方式写入日志:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">string</span> p1 = <span class="string">"parm1"</span>;</span><br><span class="line"><span class="keyword">string</span> p2 = <span class="string">"parm2"</span>;</span><br><span class="line">_logger.LogInformation(<span class="string">"Parameter values: &#123;p2&#125;, &#123;p1&#125;"</span>, p1, p2);</span><br></pre></td></tr></table></figure><br>将会得到的输出结果为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Parameter values: parm1, parm2</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>按照笔者的理解，许多日志提供器都采用了将占位符参数以字段的形式进行存储的功能，在消息模板中的占位符既是可以在消息输出中被替代的字符串，也是在结构化存储中的字段信息，当收集到大量的日志数据之后，通过结构化查询语句将大大提供分析效率。</p>
</blockquote>
<h1 id="日志过滤"><a href="#日志过滤" class="headerlink" title="日志过滤"></a>日志过滤</h1><p>可以针对特定的提供器，或类别，或所有提供器或所有类别指定最小记录的日志级别，小于该级别的日志消息将不会分布至相应的日志提供器，同样，可通过将日志级别设置为 <code>LogLevel.None</code> 来忽略所有日志。</p>
<h2 id="通过配置创建日志过滤规则"><a href="#通过配置创建日志过滤规则" class="headerlink" title="通过配置创建日志过滤规则"></a>通过配置创建日志过滤规则</h2><p>ASP.NET Core 项目模板的代码调用 CreateDefaultBuilder 方法了，该方法默认注册了 <code>Console</code> 和 <code>Debug</code> 提供器，同时告知日志系统查询 <code>Logging</code> 配置块来加载日志配置。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> webHost = <span class="keyword">new</span> WebHostBuilder()</span><br><span class="line">        .UseKestrel()</span><br><span class="line">        .UseContentRoot(Directory.GetCurrentDirectory())</span><br><span class="line">        .ConfigureAppConfiguration((hostingContext, config) =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> env = hostingContext.HostingEnvironment;</span><br><span class="line">            config.AddJsonFile(<span class="string">"appsettings.json"</span>, optional: <span class="literal">true</span>, reloadOnChange: <span class="literal">true</span>)</span><br><span class="line">                  .AddJsonFile(<span class="string">$"appsettings.<span class="subst">&#123;env.EnvironmentName&#125;</span>.json"</span>, optional: <span class="literal">true</span>, reloadOnChange: <span class="literal">true</span>);</span><br><span class="line">            config.AddEnvironmentVariables();</span><br><span class="line">        &#125;)</span><br><span class="line">        .ConfigureLogging((hostingContext, logging) =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            logging.AddConfiguration(hostingContext.Configuration.GetSection(<span class="string">"Logging"</span>));</span><br><span class="line">            logging.AddConsole();</span><br><span class="line">            logging.AddDebug();</span><br><span class="line">        &#125;)</span><br><span class="line">        .UseStartup&lt;Startup&gt;()</span><br><span class="line">        .Build();</span><br><span class="line"></span><br><span class="line">    webHost.Run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>配置数据以日志提供器和类别为单位指定了最小日志级别，例如:<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"Logging"</span>: &#123;</span><br><span class="line">    <span class="attr">"IncludeScopes"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"Debug"</span>: &#123;</span><br><span class="line">      <span class="attr">"LogLevel"</span>: &#123;</span><br><span class="line">        <span class="attr">"Default"</span>: <span class="string">"Information"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"Console"</span>: &#123;</span><br><span class="line">      <span class="attr">"LogLevel"</span>: &#123;</span><br><span class="line">        <span class="attr">"Microsoft.AspNetCore.Mvc.Razor.Internal"</span>: <span class="string">"Warning"</span>,</span><br><span class="line">        <span class="attr">"Microsoft.AspNetCore.Mvc.Razor.Razor"</span>: <span class="string">"Debug"</span>,</span><br><span class="line">        <span class="attr">"Microsoft.AspNetCore.Mvc.Razor"</span>: <span class="string">"Error"</span>,</span><br><span class="line">        <span class="attr">"Default"</span>: <span class="string">"Information"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"LogLevel"</span>: &#123;</span><br><span class="line">      <span class="attr">"Default"</span>: <span class="string">"Debug"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="以编程方式创建日志过滤规则"><a href="#以编程方式创建日志过滤规则" class="headerlink" title="以编程方式创建日志过滤规则"></a>以编程方式创建日志过滤规则</h2><p>考虑以下代码:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">WebHost.CreateDefaultBuilder(args)</span><br><span class="line">    .UseStartup&lt;Startup&gt;()</span><br><span class="line">    .ConfigureLogging(logging =&gt;</span><br><span class="line">        logging.AddFilter(<span class="string">"System"</span>, LogLevel.Debug)</span><br><span class="line">               .AddFilter&lt;DebugLoggerProvider&gt;(<span class="string">"Microsoft"</span>, LogLevel.Trace))</span><br><span class="line">    .Build();</span><br></pre></td></tr></table></figure></p>
<ul>
<li>第一个 <code>AddFilter</code> 方法指示所有提供器的 “System” 类别最小日志级别为 <code>Debug</code>。</li>
<li>第二个 <code>AddFilter</code> 方法指示 <code>Debug</code> 日志提供器的 “Microsoft” 类别最小日志级别为 <code>Trace</code>。</li>
</ul>
<h2 id="日志过滤规匹配算法"><a href="#日志过滤规匹配算法" class="headerlink" title="日志过滤规匹配算法"></a>日志过滤规匹配算法</h2><p>综合以上配置项和编程方式添加的过滤规则，其可以解释为: </p>
<style type="text/css">
<!-- 改变表格第一列的宽度 --!>
table th:nth-of-type(1) {
    width: 10%;
}
<!-- 改变表格第二列的宽度 --!>
table th:nth-of-type(2) {
    width: 10%;
}
</style>

<table>
<thead>
<tr>
<th>Number</th>
<th>Provider</th>
<th>Categories that begin with …</th>
<th>Minimun log level</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Debug</td>
<td>All categories</td>
<td>Information</td>
</tr>
<tr>
<td>2</td>
<td>Console</td>
<td>Microsoft.AspNetCore.Mvc.Razor.Internal</td>
<td>Warning</td>
</tr>
<tr>
<td>3</td>
<td>Console</td>
<td>Microsoft.AspNetCore.Mvc.Razor.Razor</td>
<td>Debug</td>
</tr>
<tr>
<td>4</td>
<td>Console</td>
<td>Microsoft.AspNetCore.Mvc.Razor</td>
<td>Error</td>
</tr>
<tr>
<td>5</td>
<td>Console</td>
<td>All categories</td>
<td>Information</td>
</tr>
<tr>
<td>6</td>
<td>All providers</td>
<td>All categories</td>
<td>Debug</td>
</tr>
<tr>
<td>7</td>
<td>All providers</td>
<td>System</td>
<td>Debug</td>
</tr>
<tr>
<td>8</td>
<td>Debug</td>
<td>Microsoft</td>
<td>Trace</td>
</tr>
</tbody>
</table>
<p>当一个指定类别的 ILogger 对象写入日志消息时，框架尝试使用以下逻辑来匹配过滤规则:</p>
<ol>
<li>选出所有匹配提供器或其别名的规则，如果没有任何规则匹配到该提供器，则应用所有不指定提供器的规则</li>
<li>在从 1 中筛选出的结果的基础上，选出匹配类别的最长类别规则，如果找不到任何规则，则应用所有未指定类别的规则</li>
<li>如果有多个规则匹配，则选择<strong>最后</strong>一个</li>
<li>如果没有任何匹配的规则，则应用<a href="#默认最小日志级别">默认最小日志级别</a></li>
</ol>
<p>假设现在有一个类别为 “Microsoft.AspNetCore.Mvc.Razor.RazorViewEngine” 的 <code>ILogger</code> 对象，当其写入日志消息时: </p>
<ul>
<li>Debug 提供器为其筛选出表格中的 1, 6, 8 规则，由于规则 8 最具体，所以规则 8 被应用</li>
<li>Console 提供器为其筛选出 3, 4, 5, 6 规则，规则 3 最具体，它会被应用</li>
</ul>
<p>因此，当该 <code>ILogger</code> 对象写入日志时，Debug 提供器将输出把级别 <code>Trace</code> 以上的日志消息，而 Console 提供器则输出级别 <code>Debug</code> 以上的日志消息。</p>
<h2 id="日志提供器别名"><a href="#日志提供器别名" class="headerlink" title="日志提供器别名"></a>日志提供器别名</h2><p>在配置项中可以将提供器的类型名作为其配置项的根节点，每个日志提供器也定义了别名，.NET Core 定义了以下日志提供器的别名:</p>
<ul>
<li>Console: </li>
<li>Debug: </li>
<li>EventLog: </li>
<li>AzureAppServices</li>
<li>TraceSource</li>
<li>EventSource</li>
</ul>
<h2 id="默认最小日志级别"><a href="#默认最小日志级别" class="headerlink" title="默认最小日志级别"></a>默认最小日志级别</h2><p>前文提到，在没有任何日志过滤规则匹配时，会采用默认最小日志级别，以下代码展示了如何设置默认最小级别:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WebHost.CreateDefaultBuilder(args)</span><br><span class="line">    .UseStartup&lt;Startup&gt;()</span><br><span class="line">    .ConfigureLogging(logging =&gt; logging.SetMinimumLevel(LogLevel.Warning))</span><br><span class="line">    .Build();</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>如果没有显式指定默认最小日志级别，那么框架的默认值为 <code>Information</code>。</p>
</blockquote>
<h2 id="日志全局过滤器委托"><a href="#日志全局过滤器委托" class="headerlink" title="日志全局过滤器委托"></a>日志全局过滤器委托</h2><p>可以向框架注册一个 <code>Func&lt;Provider, Category, LogLevel&gt;</code>  的委托，让匹配不到任何日志过滤规则的 <code>ILogger</code> 对象通过该委托获得日志级别:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">WebHost.CreateDefaultBuilder(args)</span><br><span class="line">    .UseStartup&lt;Startup&gt;()</span><br><span class="line">    .ConfigureLogging(logBuilder =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        logBuilder.AddFilter((provider, category, logLevel) =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (provider == <span class="string">"Microsoft.Extensions.Logging.Console.ConsoleLoggerProvider"</span> &amp;&amp; </span><br><span class="line">                category == <span class="string">"TodoApi.Controllers.TodoController"</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">    .Build();</span><br></pre></td></tr></table></figure></p>
<h1 id="日志区限-Log-Scopes"><a href="#日志区限-Log-Scopes" class="headerlink" title="日志区限(Log Scopes)"></a>日志区限(Log Scopes)</h1><p>可通过 <code>scope</code> 的方式将一系列由在逻辑上相互关联的操作产生的日志消息组合成一个集合，例如，你可能希望将一个数据库事务中产生的所有日志消息包含相同的事务 ID。调用 <code>ILogger.BeginScope&lt;TState&gt;</code> 返回一个 Scope 对象，该对象实现了 <code>IDisposable</code> 接口，通常使用 <code>using</code> 语句将一组与 Scope 相关的日志消息写入包围起来:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IActionResult <span class="title">GetById</span>(<span class="params"><span class="keyword">string</span> id</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TodoItem item;</span><br><span class="line">    <span class="keyword">using</span> (_logger.BeginScope(<span class="string">"Message attached to logs created in the using block"</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        _logger.LogInformation(LoggingEvents.GetItem, <span class="string">"Getting item &#123;ID&#125;"</span>, id);</span><br><span class="line">        item = _todoRepository.Find(id);</span><br><span class="line">        <span class="keyword">if</span> (item == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            _logger.LogWarning(LoggingEvents.GetItemNotFound, <span class="string">"GetById(&#123;ID&#125;) NOT FOUND"</span>, id);</span><br><span class="line">            <span class="keyword">return</span> NotFound();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ObjectResult(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>以下代码在 Program.cs 中为 Console 提供器启用了日志区限:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.ConfigureLogging((hostingContext, logging) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    logging.AddConfiguration(hostingContext.Configuration.GetSection(<span class="string">"Logging"</span>));</span><br><span class="line">    logging.AddConsole(options =&gt; options.IncludeScopes = <span class="literal">true</span>);</span><br><span class="line">    logging.AddDebug();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>在 <code>appsetings</code> 配置文件中使用配置项启用该功能仅在 ASP.NET Core 2.1 版本以后可用</p>
</blockquote>
<p>这样，每条日志消息都会包含完整的区限信息:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">info: TodoApi.Controllers.TodoController[1002]</span><br><span class="line">      =&gt; RequestId:0HKV9C49II9CK RequestPath:/api/todo/0 =&gt; TodoApi.Controllers.TodoController.GetById (TodoApi) =&gt; Message attached to logs created in the using block</span><br><span class="line">      Getting item 0</span><br><span class="line">warn: TodoApi.Controllers.TodoController[4000]</span><br><span class="line">      =&gt; RequestId:0HKV9C49II9CK RequestPath:/api/todo/0 =&gt; TodoApi.Controllers.TodoController.GetById (TodoApi) =&gt; Message attached to logs created in the using block</span><br><span class="line">      GetById(0) NOT FOUND</span><br></pre></td></tr></table></figure></p>
<h1 id="内置日志提供器"><a href="#内置日志提供器" class="headerlink" title="内置日志提供器"></a>内置日志提供器</h1><p>ASP.NET Core 内置了以下提供器:</p>
<ul>
<li>Console</li>
<li>Debug</li>
<li>EventLog</li>
<li>AzureAppServices</li>
<li>TraceSource</li>
<li>EventSource</li>
</ul>
<h2 id="Console-提供器"><a href="#Console-提供器" class="headerlink" title="Console 提供器"></a>Console 提供器</h2><p>Microsoft.Extensions.Logging.Console 包将日志消息输出到控制台:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logging.AddConsole()</span><br></pre></td></tr></table></figure></p>
<h2 id="Debug-提供器"><a href="#Debug-提供器" class="headerlink" title="Debug 提供器"></a>Debug 提供器</h2><p>Microsoft.Extensions.Logging.Debug 包通过 System.Diagnostics.Debug 类(调用 Debug.WriteLine 方法)输出日志消息，在 Linux 系统中，该提供器将日志写入 <code>/var/log/message</code> 中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logging.AddDebug()</span><br></pre></td></tr></table></figure></p>
<h2 id="EventSource-提供器"><a href="#EventSource-提供器" class="headerlink" title="EventSource 提供器"></a>EventSource 提供器</h2><p>Microsoft.Extensions.Logging.EventSource 包实现了事件追踪，在 Windows 系统下，它使用 ETW，该提供器是跨平台的，但在 Linux 或 macOS 下尚无可用的可视化工具。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logging.AddEventSourceLogger()</span><br></pre></td></tr></table></figure></p>
<h2 id="Windows-EventLog-提供器"><a href="#Windows-EventLog-提供器" class="headerlink" title="Windows EventLog 提供器"></a>Windows EventLog 提供器</h2><p>Microsoft.Extensions.Logging.EventLog 包将日志发送至 Windows Event Log。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logging.AddEventLog()</span><br></pre></td></tr></table></figure></p>
<h2 id="TraceSource-提供器"><a href="#TraceSource-提供器" class="headerlink" title="TraceSource 提供器"></a>TraceSource 提供器</h2><p>Microsoft.Extensions.Logging.TraceSource 包利用 System.Diagnostics.TraceSource 库和提供器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logging.AddTraceSource(sourceSwitchName)</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>该提供当前仅支持 .NET Framework 版本。</p>
</blockquote>
<h2 id="Azure-App-Service-提供器"><a href="#Azure-App-Service-提供器" class="headerlink" title="Azure App Service 提供器"></a>Azure App Service 提供器</h2><p>Microsoft.Extensions.Logging.AzureAppServices 包将日志写入到 Azure App Service 应用的文件系统的文本文件和 Azure Storage 帐号的 <a href="https://docs.microsoft.com/en-us/azure/storage/blobs/storage-quickstart-blobs-dotnet?tabs=windows#what-is-blob-storage" target="_blank" rel="noopener">blob storage</a>，该提供器仅在 ASP.NET Core 1.1 版本以后可用。</p>
<h1 id="LoggerMessage-模式"><a href="#LoggerMessage-模式" class="headerlink" title="LoggerMessage 模式"></a>LoggerMessage 模式</h1><p>与日志系统的扩展方法模式相比，<code>LoggerMessage</code> 模式可减少对象的分配和计算量以提供性能。该模式提供了以下优点:</p>
<ul>
<li>扩展方法模式，如 <code>LogInformation</code>, <code>LogDebug</code> 和 <code>LogError</code> 等方法会装箱值对象，而 <code>LoggerMessage</code> 模式通过使用强类型参数的 <code>Action</code> 委托避免了装箱</li>
<li>扩展方法模式在每条日志消息写入时都要求传递消息模板，而 <code>LoggerMessage</code> 模式仅在消息定义时传递消息模板</li>
</ul>
<h2 id="LoggerMessage-Define"><a href="#LoggerMessage-Define" class="headerlink" title="LoggerMessage.Define"></a>LoggerMessage.Define</h2><p><code>LoggerMessage.Define</code> 的示例代码可参考<a href="https://github.com/aspnet/Docs/tree/master/aspnetcore/fundamentals/logging/loggermessage/sample/" target="_blank" rel="noopener">示例代码</a></p>
<p><code>LoggerMessage.Define</code> 静态方法创建并返回一个 <code>Action</code> 委托用以记录日志，其重载最高支持 6 个消息模板的命名参数，传递至 Define 方法的字符串是一个包含变量占位符的消息模板而不是一个插值字符串(形如 <code>This is a {variable}.</code>)，占位符以定义的参数顺序依次被填充</p>
<blockquote>
<p>占位符的名称应该在多个消息模板之间保持一致，它们在结构化存储中扮演了字段名的角色，推荐以 Pascal 风格来命名占位符，例如 <code>{Count}</code>, <code>{FirstName}</code>。</p>
</blockquote>
<p>每条日志记录方法都是一个由 <code>LoggerMessage.Define</code> 方法创建的 <code>Action</code> 委托，例如:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> Action&lt;ILogger, Exception&gt; _indexPageRequested;</span><br></pre></td></tr></table></figure><br>对于该 Action，指定:</p>
<ul>
<li>日志级别</li>
<li>一个唯一的事件 ID(EventId)和包含扩展方法的类型的名称</li>
<li>消息模板</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_indexPageRequested = LoggerMessage.Define(</span><br><span class="line">    LogLevel.Information, </span><br><span class="line">    <span class="keyword">new</span> EventId(<span class="number">1</span>, <span class="keyword">nameof</span>(IndexPageRequested)), </span><br><span class="line">    <span class="string">"GET request for Index page"</span>);</span><br></pre></td></tr></table></figure>
<p>上述代码表示:</p>
<ul>
<li>日志级别设置为 <code>Information</code></li>
<li>事件 ID 设为 1 并传入 <code>IndexPageRequested</code> 类型的名称</li>
<li>自定义的消息模板</li>
</ul>
<p><code>Action</code> 委托由一个定义为 <code>ILogger</code> 的强类型 <code>IndexPageRequested</code> 扩展方法调用:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">IndexPageRequested</span>(<span class="params"><span class="keyword">this</span> ILogger logger</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _indexPageRequested(logger, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>ILogger</code> 在 <code>OnGetAsync</code> 方法中调用 <code>IndexPageRequested</code> 扩展方法完成日志记录。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">IndexPageRequested</span>(<span class="params"><span class="keyword">this</span> ILogger logger</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _logger.IndexPageRequested();</span><br><span class="line">    Quotes = <span class="keyword">await</span> _db.Quotes.AsNoTracking().ToListAsync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="LoggerMessage-DefineScope"><a href="#LoggerMessage-DefineScope" class="headerlink" title="LoggerMessage.DefineScope"></a>LoggerMessage.DefineScope</h2><p><code>LoggerMessage.DefineScope</code> 遵循一样的模式，不同之处在于其返回一个 <code>Func&lt;T,IDisposable&gt;</code> 委托，在使用该对象时，必须确保区限功能已启用，并使用 <code>using</code> 包裹上下文。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://berdypango.github.io/aspnetcore-fundamentals-configuration-options/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Frost He">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FrostHe.Handbook">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/aspnetcore-fundamentals-configuration-options/" itemprop="url">ASP.NET Core 框架基础 - 配置系统 Options 模式</a></h1>
        

        <div class="post-meta">
          
          <span class="post-time">
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  1,089
                </span>
              

              

              
            </div>
          

          
              <div class="post-description">
                  ASP.NET Core 配置系统 Options 模式详解
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>参考资料:</p>
<ul>
<li><a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration/options?view=aspnetcore-2.1" target="_blank" rel="noopener">Options pattern in ASP.NET Core</a></li>
<li><a href="http://www.cnblogs.com/artech/p/new-config-system-01.html" target="_blank" rel="noopener">http://www.cnblogs.com/artech/p/new-config-system-01.html</a></li>
<li><a href="https://github.com/aspnet/Options" target="_blank" rel="noopener">Options Github Source</a></li>
</ul>
<p>本文大纲:<br><!-- TOC --></p>
<ul>
<li><a href="#options-%E6%A8%A1%E5%BC%8F">Options 模式</a><ul>
<li><a href="#%E9%85%8D%E7%BD%AE%E7%BB%91%E5%AE%9A">配置绑定</a></li>
<li><a href="#%E6%89%A9%E5%B1%95%E6%96%B9%E6%B3%95-addoptions">扩展方法 AddOptions</a><ul>
<li><a href="#optionsmanagertoptions">OptionsManager<toptions></toptions></a></li>
<li><a href="#iconfigureoptionsin-toptions">IConfigureOptions<in toptions=""></in></a></li>
<li><a href="#configureoptionstoptions">ConfigureOptions<toptions></toptions></a></li>
</ul>
</li>
<li><a href="#%E6%89%A9%E5%B1%95%E6%96%B9%E6%B3%95-configure">扩展方法 Configure</a></li>
<li><a href="#%E5%88%9B%E5%BB%BA-options-%E5%AF%B9%E8%B1%A1">创建 Options 对象</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->
<h1 id="Options-模式"><a href="#Options-模式" class="headerlink" title="Options 模式"></a>Options 模式</h1><p>在真实的项目中我们大多采用 <code>Options</code> 模式来使用配置，<code>Options</code> 是配置的逻辑结构在对象层面的体现，通常，可以将一个 <code>Configuration</code> 对象绑定为一个 <code>Options</code> 对象。这样的绑定称为<strong>「配置绑定」</strong>。</p>
<h2 id="配置绑定"><a href="#配置绑定" class="headerlink" title="配置绑定"></a>配置绑定</h2><p><code>Microsoft.Extensions.Configuration.Binder</code> 包为 <code>IConfiguration</code> 接口定义了 <code>Bind</code> 扩展方法，该方法接收一个代表 <code>Options</code> 的 <code>object</code> 类型的参数，并将 <code>Configuration</code> 的配置数据绑定到该对象上。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">ConfigurationBinder</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Bind</span>(<span class="params"><span class="keyword">this</span> IConfiguration configuration, <span class="keyword">object</span> instance</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>配置绑定的目标类型可以是一个简单的基元类型，也可以是一个自定义数据类型，还可以是一个数组、集合或者字典类型。上述 <code>Bind</code> 方法在进行配置绑定的过程中会根据不同的目标类型采用不同的策略。</p>
<p><code>Options</code> 模式是对依赖注入的应用，通过调用 <code>IServiceCollection</code> 扩展方法 <code>AddOptions</code> 添加 <code>Options</code> 模式的服务注册，再通过 <code>Configure&lt;TOptions&gt;</code> 扩展方法配置目标 <code>Options</code> 的 T 类型。消费方利用 <code>ServiceProvider</code> 得到一个类型为 <code>IOptions&lt;TOptions&gt;</code> 的服务对象后，读取 <code>Value</code> 属性得到由配置绑定生成的 <code>TOptions</code> 实例。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">IConfiguration config = ...;</span><br><span class="line">FormatOptions options = <span class="keyword">new</span> ServiceCollection()</span><br><span class="line">    .AddOptions()</span><br><span class="line">    .Configure&lt;FormatOptions&gt;(config.GetSection(<span class="string">"Format"</span>))</span><br><span class="line">    .BuildServiceProvider()</span><br><span class="line">    .GetService&lt;IOptions&lt;FormatOptions&gt;&gt;()</span><br><span class="line">    .Value;</span><br></pre></td></tr></table></figure></p>
<h2 id="扩展方法-AddOptions"><a href="#扩展方法-AddOptions" class="headerlink" title="扩展方法 AddOptions"></a>扩展方法 AddOptions</h2><p>当调用 <code>IServiceCollection</code> 的 <code>AddOptions</code> 时，该方法对 <code>IOptions&lt;&gt;</code> 接口注册一个服务，该服务的实现类型为 <code>OptionsManager&lt;TOptions&gt;</code> ，生命周期为 <code>Singleton</code>。配置绑定生成的 <code>Options</code> 对象最终都是通过 <code>OptionsManager&lt;TOptions&gt;</code> 创建的。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IServiceCollection <span class="title">AddOptions</span>(<span class="params"><span class="keyword">this</span> IServiceCollection services</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    services.TryAdd(ServiceDescriptor.Singleton(<span class="keyword">typeof</span>(IOptions&lt;&gt;), <span class="keyword">typeof</span>(OptionsManager&lt;&gt;)));</span><br><span class="line">    <span class="keyword">return</span> services;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>以下是几个相关类型的定义:</p>
<h3 id="OptionsManager"><a href="#OptionsManager" class="headerlink" title="OptionsManager"></a>OptionsManager<toptions></toptions></h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class OptionsManager&lt;TOptions&gt; : IOptions&lt;TOptions&gt; where TOptions: class, new()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OptionsManager</span>(<span class="params">IEnumerable&lt;IConfigureOptions&lt;TOptions&gt;&gt; setups</span>)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">virtual</span> TOptions Value &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>OptionsManager&lt;TOptions&gt;</code> 类型的构造函数接受一个 <code>IConfigureOptions&lt;TOptions&gt;</code> 的集合，<code>Options</code> 对象的创建体现在 <code>Value</code> 属性上。该属性的实现非常简单，它先调用 <code>TOptions</code> 类型的默认无参构造函数(<code>TOptions</code> 代表的类型必须具有一个默认无参构造函数)创建一个空的 <code>TOptions</code> 对象，然后将其传递给构造函数中指定的<code>ConfigureOptions&lt;TOptions&gt;</code> 对象逐个进行转换处理。</p>
<h3 id="IConfigureOptions"><a href="#IConfigureOptions" class="headerlink" title="IConfigureOptions"></a>IConfigureOptions<in toptions=""></in></h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface IConfigureOptions&lt;in TOptions&gt; where TOptions: class</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">TOptions options</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>IConfigureOptions&lt;TOptions&gt;</code> 接口定义了一个唯一的 <code>Configure</code> 方法，该方法将 <code>Options</code> 对象作为输入参数。</p>
<h3 id="ConfigureOptions"><a href="#ConfigureOptions" class="headerlink" title="ConfigureOptions"></a>ConfigureOptions<toptions></toptions></h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class ConfigureOptions&lt;TOptions&gt;: IConfigureOptions&lt;TOptions&gt; where TOptions : class, new()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Action&lt;TOptions&gt; Action &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConfigureOptions</span>(<span class="params">Action&lt;TOptions&gt; action</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.Action = action;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">TOptions options</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.Action(options);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>IConfigure&lt;TOptions&gt;</code> 的默认实现类型 <code>ConfigureOptions&lt;TOptions&gt;</code> 在其构造函数中接收一个 <code>Action&lt;TOptions&gt;</code> 委托对象，再在 <code>Configure</code> 方法中调用该委托实现对 <code>TOptions</code> 的操作。</p>
<h2 id="扩展方法-Configure"><a href="#扩展方法-Configure" class="headerlink" title="扩展方法 Configure"></a>扩展方法 Configure</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> IServiceCollection Configure&lt;TOptions&gt;(<span class="keyword">this</span> IServiceCollection services, <span class="keyword">string</span> name, IConfiguration config, Action&lt;BinderOptions&gt; configureBinder)</span><br><span class="line">    <span class="keyword">where</span> TOptions : <span class="keyword">class</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (services == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="keyword">nameof</span>(services));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (config == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="keyword">nameof</span>(config));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> services.AddSingleton&lt;IConfigureOptions&lt;TOptions&gt;&gt;(<span class="keyword">new</span> NamedConfigureFromConfigurationOptions&lt;TOptions&gt;(name, config, configureBinder));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在调用 <code>IServiceCollection</code> 的 <code>Configure</code> 方法时，其内部注册了一个 <code>IConfigureOptions&lt;TOptions&gt;</code> 接口的单例服务，其实际类型为 <code>NamedConfigureFromConfigurationOptions&lt;TOptions&gt;</code>，该类型最终继承自 <code>ConfigureOptions&lt;TOptions&gt;</code> 类型，并且在其构造函数中声明了一个匿名方法作为 <code>Action&lt;TOptions&gt;</code> 的参数传入 <code>NamedConfigureFromConfigurationOptions&lt;TOptions&gt;</code> 中，最终实现配置绑定。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NamedConfigureFromConfigurationOptions</span>(<span class="params"><span class="keyword">string</span> name, IConfiguration config, Action&lt;BinderOptions&gt; configureBinder</span>)</span></span><br><span class="line"><span class="function">    : <span class="title">base</span>(<span class="params">name, options =&gt; config.Bind(options, configureBinder</span>))</span></span><br></pre></td></tr></table></figure></p>
<h2 id="创建-Options-对象"><a href="#创建-Options-对象" class="headerlink" title="创建 Options 对象"></a>创建 Options 对象</h2><p>Options 编程模式以两个注册到 <code>ServiceCollection</code> 的服务为核心，这两个服务对应的服务接口分别是: </p>
<ul>
<li><code>IOptions&lt;TOptions&gt;</code>: 直接提供最终绑定了配置数据的 <code>Options</code> 对象</li>
<li><code>IConfigureOptions&lt;TOptions&gt;</code>: 在 <code>Options</code> 对象返回之前对它实施相应的初始化工作。</li>
</ul>
<p>这个两个服务分别通过扩展方法 <code>AddOptions</code> 和 <code>Configure</code> 方法注册到指定的 <code>ServiceCollection</code> 中，服务的真实类型分别是 <code>OptionsManager&lt;TOptions&gt;</code> 和 <code>NamedConfigureFromConfigurationOptions&lt;TOptions&gt;</code>，后者派生于 <code>ConfigureOptions&lt;TOptions&gt;</code>。下图所示的 UML 体现了 <code>Options</code> 模型中涉及的这些接口／类型以及它们之间的关系。</p>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://berdypango.github.io/aspnetcore-fundamentals-configuration/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Frost He">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FrostHe.Handbook">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/aspnetcore-fundamentals-configuration/" itemprop="url">ASP.NET Core 框架基础 - 配置系统</a></h1>
        

        <div class="post-meta">
          
          <span class="post-time">
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  2,486
                </span>
              

              

              
            </div>
          

          
              <div class="post-description">
                  配置 API 提供了统一的方式以键值对的形式来读取和设置配置项，配置项在运行时从多个配置源读取信息，并以一个多层级的字典表树来存储这些值
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>参考资料:</p>
<ul>
<li><a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration/?view=aspnetcore-2.1&amp;tabs=basicconfiguration" target="_blank" rel="noopener">Configuration in ASP.NET Core</a></li>
<li><a href="http://www.cnblogs.com/artech/p/new-config-system-01.html" target="_blank" rel="noopener">http://www.cnblogs.com/artech/p/new-config-system-01.html</a></li>
</ul>
<p>本文大纲:<br><!-- TOC --></p>
<ul>
<li><a href="#%E5%89%8D%E8%A8%80">前言</a></li>
<li><a href="#%E4%BB%8E%E7%BC%96%E7%A8%8B%E8%A7%92%E5%BA%A6%E8%AE%A4%E8%AF%86%E9%85%8D%E7%BD%AE%E7%B3%BB%E7%BB%9F">从编程角度认识配置系统</a></li>
<li><a href="#%E4%BB%8E%E8%AE%BE%E8%AE%A1%E8%A7%92%E5%BA%A6%E8%AE%A4%E8%AF%86%E9%85%8D%E7%BD%AE%E7%B3%BB%E7%BB%9F">从设计角度认识配置系统</a><ul>
<li><a href="#%E9%85%8D%E7%BD%AE%E6%95%B0%E6%8D%AE%E7%9A%84%E8%BD%AC%E6%8D%A2">配置数据的转换</a></li>
<li><a href="#configuration-%E5%AF%B9%E8%B1%A1">Configuration 对象</a></li>
<li><a href="#configurationprovider-%E5%AF%B9%E8%B1%A1">ConfigurationProvider 对象</a></li>
<li><a href="#configurationsource-%E5%AF%B9%E8%B1%A1">ConfigurationSource 对象</a></li>
<li><a href="#configurationbuilder-%E5%AF%B9%E8%B1%A1">ConfigurationBuilder 对象</a></li>
</ul>
</li>
<li><a href="#%E5%AF%B9%E8%B1%A1%E5%85%B3%E7%B3%BB%E5%9B%BE">对象关系图</a></li>
<li><a href="#%E5%90%8C%E6%AD%A5-configuration-%E7%9A%84%E6%9B%B4%E6%94%B9">同步 Configuration 的更改</a></li>
</ul>
<!-- /TOC -->
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>配置 API 提供了统一的方式以键值对的形式来读取和设置配置项，配置项在运行时从多个配置源读取信息，并以一个多层级的字典表树来存储这些值。配置源支持以下提供器:</p>
<ul>
<li>文件格式(INI, JSON 和 XML)</li>
<li>命令行参数</li>
<li>环境变量</li>
<li>内存对象</li>
<li><a href="https://docs.microsoft.com/en-us/aspnet/core/security/app-secrets?view=aspnetcore-2.1&amp;tabs=visual-studio" target="_blank" rel="noopener">Secret Manager</a> 存储</li>
<li><a href="https://docs.microsoft.com/en-us/aspnet/core/security/key-vault-configuration?view=aspnetcore-2.1&amp;tabs=aspnetcore2x" target="_blank" rel="noopener">Azure Key Vault</a></li>
<li>自定义配置源提供器</li>
</ul>
<p>任何一个配置项的值都映射到一个字符串键，框架内置了实现类型将配置项映射到一个 POCO 对象。<code>Options</code> 模式使用 <code>Options</code> 类型代表一组关联的设置项。</p>
<h1 id="从编程角度认识配置系统"><a href="#从编程角度认识配置系统" class="headerlink" title="从编程角度认识配置系统"></a>从编程角度认识配置系统</h1><p>从编程角度来看，开发人员主要用到了以下三个对象</p>
<ul>
<li><code>Configuration</code>: 客户代码最终使用的包含配置项的对象</li>
<li><code>ConfigurationBuilder</code>: 构建 <code>Configuration</code> 的对象</li>
<li><code>ConfigurationSource</code>: 配置源对象</li>
</ul>
<img src="/aspnetcore-fundamentals-configuration/3-objects.png" title="配置系统所使用的三个对象">
<p>读取配置时，根据配置的定义方式创建相应的 <code>ConfigurationSource</code> 对象，并将其注册到创建的 <code>ConfigurationBuilder</code> 对象上，后者利用注册的这些 <code>ConfigurationSource</code> 提供最终的 <code>Configuration</code> 对象。</p>
<p><code>IConfiguration</code>, <code>IConfigurationSource</code> 和 <code>IConfigurationBuilder</code> 接口分别代表这些对象的抽象，三者均定义在 <code>Microsoft.Extensions.Configuration.Abstractions</code> 包中，默认实现定义在 <code>Microsoft.Extensions.Configuration</code> 包中。</p>
<p>虽然大部分情况下配置从整体来说都具有结构化的层次关系，但是<strong>「原子」</strong>配置项都以最简单的<strong>「键-值对」</strong>的形式来体现，并且键和值通常都是字符串。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> configBuilder = <span class="keyword">new</span> ConfigurationBuilder();</span><br><span class="line"><span class="keyword">var</span> configuration = configBuilder</span><br><span class="line">                    .Add(<span class="keyword">new</span> MemoryConfigurationSource &#123; InitialData = source &#125;)</span><br><span class="line">                    .Build();</span><br></pre></td></tr></table></figure>
<p>这里首先创建了一个 <code>ConfigurationBuilder</code> 对象，然后将一个 <code>MemoryConfigurationSource</code> 对象注册到它上面，随后调用 <code>IConfigurationBuilder.Build</code> 方法得到一个 <code>IConfiguration</code> 对象。</p>
<p>真实项目中涉及的配置大都具有结构化的层次，<code>Configuration</code> 对象同样具有这样的结构，结构化配置具有一个配置树，一个 <code>Configuration</code> 对象对应这棵树的某个节点，而整棵配置树也可由根节点对应的 <code>Configuration</code> 来表示，以键值对体现的原子配置项对应配置树中不具有子节点的<strong>「叶子节点」</strong>。</p>
<h1 id="从设计角度认识配置系统"><a href="#从设计角度认识配置系统" class="headerlink" title="从设计角度认识配置系统"></a>从设计角度认识配置系统</h1><p>配置具有多种原始来源，如内存对象，物理文件，数据库或其他自定义存储介质。如果采用物理文件来存储配置数据，我们还可以选择不同的文件格式(JSON, XML 和 INI)。因此配置的原始数据结构是不确定的，配置模型的最终目的在于提取原始的配置数据并将其转换成一个 <code>Configuration</code> 对象以对客户代码提供统一的编程模型。</p>
<h2 id="配置数据的转换"><a href="#配置数据的转换" class="headerlink" title="配置数据的转换"></a>配置数据的转换</h2><p>配置从原始结构向逻辑结构的转换需要一种<strong>「中间结构」</strong>——数据字典，整棵配置树的所有节点都会转换成基于字典的中间结构，最终再完成到 <code>Configuration</code> 对象的转换，父子级节点之间以 <code>:</code> 进行连接。</p>
<img src="/aspnetcore-fundamentals-configuration/conversion-process.png" title="转换流程">
<p>一个 <code>Configuration</code> 对象具有树形层次结构的意思不是说该类型具有对应的数据成员(字段或属性)定义，而是它提供的 API <strong>「在逻辑上体现出树形层次结构」</strong>，配置树是一种逻辑结构。</p>
<h2 id="Configuration-对象"><a href="#Configuration-对象" class="headerlink" title="Configuration 对象"></a>Configuration 对象</h2><p>一个 <code>Configuration</code> 对象表示配置树的某个配置节点，表示根节点的对象与表示其它配置节点的对象是不同的，所以配置模型采用 <code>IConfigurationRoot</code> 接口来表示根节点，根节点以外的其他配置节点则用 <code>IConfigurationSection</code> 接口表示，这两个接口都继承自 <code>IConfiguration</code>。下图为我们展示了由一个 <code>ConfigurationRoot</code> 对象和一组 <code>ConfigurationSection</code> 对象构成的配置树。<br><img src="/aspnetcore-fundamentals-configuration/root&section.png" title="配置节点的两种类型"><br>下面的代码展示了 <code>IConfigurationRoot</code> 接口的定义，该接口仅定义了一个 <code>Reload</code> 方法实现对配置数据的重新加载。<code>ConfigurationRoot</code> 对象表示配置树的根，也代表整棵配置树，如果它被重新加载，意味着整棵配置树的所有配置数据均被重新加载。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IConfigurationRoot</span> : <span class="title">IConfiguration</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Reload</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>非根配置节点的 <code>IConfigurationSection</code> 接口具有如下三个属性: </p>
<ul>
<li>Key: 只读，用来唯一标识多个具有相同父节点的 <code>ConfigurationSection</code> 对象</li>
<li>Path 表示当前配置节点在配置树中的路径，该路径由多个 Key 值组成，并采用冒号(<code>:</code>)分隔纵深节点。Path 和 Key 的值体现了当前配置节在整个配置树中的位置。</li>
<li>Value: 表示当前 <code>IConfigurationSection</code> 配置节点的值。只有配置树的<strong>叶子节点</strong>对应的<code>ConfigurationSection</code> 对象的 Value 属性才有值，非叶子节点对应的 <code>ConfigurationSection</code> 对象仅表示存放子配置节点的逻辑容器，它们的 Value 为 Null。值得一提的是，这个 Value 属性并不是只读的，而是可读可写的，但是写入的值不会被持久化，因为配置树只是逻辑结构，而非物理结构。所以一旦配置树被重新加载，写入的值将会丢失。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IConfigurationSection</span> : <span class="title">IConfiguration</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="keyword">string</span> Path &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">string</span> Key &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">string</span> Value &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
现在来看看 <code>IConfiguration</code> 接口的定义: <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IConfiguration</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">IEnumerable&lt;IConfigurationSection&gt; <span class="title">GetChildren</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function">IConfigurationSection <span class="title">GetSection</span>(<span class="params"><span class="keyword">string</span> key</span>)</span>;</span><br><span class="line">    <span class="function">IChangeToken <span class="title">GetReloadToken</span>(<span class="params"></span>)</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">string</span> <span class="keyword">this</span>[<span class="keyword">string</span> key] &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>GetChildren</code>: 返回 <code>ConfigurationSection</code> 的集合，表示所有从属于它的配置节点</li>
<li><code>GetSection</code>: 根据指定的 key 返回一个具体的子配置节点。key 参数与当前配置对象的 Path 属性的值进行组合以确定目标配置节点所在的路径。</li>
<li><code>GetReloadToken</code>: 返回当配置重新加载时进行回调的 <code>IChangeToken</code> 对象，有关 <code>IChangeToken</code> 详见后文。</li>
</ul>
<p>以下示例通过不同的 key 值获得相同配置节点的值:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Dictionary&lt;<span class="keyword">string</span>, <span class="keyword">string</span>&gt; source = <span class="keyword">new</span> Dictionary&lt;<span class="keyword">string</span>, <span class="keyword">string</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta"><span class="meta-string">"A:B:C"</span></span>] = <span class="string">"ABC"</span></span><br><span class="line">&#125;;</span><br><span class="line">IConfiguration root = <span class="keyword">new</span> ConfigurationBuilder()</span><br><span class="line">        .Add(<span class="keyword">new</span> MemoryConfigurationSource &#123; InitialData = source &#125;)</span><br><span class="line">        .Build();</span><br><span class="line"> </span><br><span class="line">IConfigurationSection section1 = root.GetSection(<span class="string">"A:B:C"</span>);</span><br><span class="line">IConfigurationSection section2 = root.GetSection(<span class="string">"A:B"</span>).GetSection(<span class="string">"C"</span>);</span><br><span class="line">IConfigurationSection section3 = root.GetSection(<span class="string">"A"</span>).GetSection(<span class="string">"B:C"</span>);</span><br><span class="line"> </span><br><span class="line">Debug.Assert(section1.Value == <span class="string">"ABC"</span>);</span><br><span class="line">Debug.Assert(section2.Value == <span class="string">"ABC"</span>);</span><br><span class="line">Debug.Assert(section3.Value == <span class="string">"ABC"</span>);</span><br><span class="line"> </span><br><span class="line">Debug.Assert(!ReferenceEquals(section1, section2));</span><br><span class="line">Debug.Assert(!ReferenceEquals(section1, section3));        </span><br><span class="line">Debug.Assert(<span class="literal">null</span> != root.GetSection(<span class="string">"D"</span>));</span><br></pre></td></tr></table></figure><br>虽然上述代码得到的 <code>ConfigurationSection</code> 对象均指向配置树的同一个节点，但是它们并非同一个对象。当调用 <code>GetSection</code> 方法时，无论配置树是否存在一个与指定路径匹配的配置节点，它总是会创建一个 <code>ConfigurationSection</code> 对象。</p>
<blockquote>
<p><code>IConfiguration</code> 的索引器执行与 <code>GetSection</code> 方法相同的逻辑。</p>
</blockquote>
<h2 id="ConfigurationProvider-对象"><a href="#ConfigurationProvider-对象" class="headerlink" title="ConfigurationProvider 对象"></a>ConfigurationProvider 对象</h2><p>虽然每种不同类型的配置源都具有一个对应的 <code>ConfigurationSource</code> 类型，但对原始数据的读取并不由 <code>ConfigurationSource</code> 实现，而是委托一个对应的 <code>ConfigurationProvider</code> 对象来完成。不同配置类型的 <code>ConfigurationSource</code> 由不同的 <code>ConfigurationProvider</code> 实现读取。<br><img src="/aspnetcore-fundamentals-configuration/configuration-provider.png" title="ConfigurationProvider"><br><code>ConfigurationProvider</code> 将配置数据从原始结构转换为数据字典，因此定义在 <code>IConfigurationProvider</code> 接口中的方法大多为针对字典对象的操作:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IConfigurationProvider</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Load</span>(<span class="params"></span>)</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">TryGet</span>(<span class="params"><span class="keyword">string</span> key, <span class="keyword">out</span> <span class="keyword">string</span> <span class="keyword">value</span></span>)</span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Set</span>(<span class="params"><span class="keyword">string</span> key, <span class="keyword">string</span> <span class="keyword">value</span></span>)</span>;</span><br><span class="line">  <span class="function">IEnumerable&lt;<span class="keyword">string</span>&gt; <span class="title">GetChildKeys</span>(<span class="params">IEnumerable&lt;<span class="keyword">string</span>&gt; earlierKeys, <span class="keyword">string</span> parentPath</span>)</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><br>配置数据通过调用 <code>ConfigurationProvider</code> 的 <code>Load</code> 方法完成加载。<code>TryGet</code> 方法获取由指定的Key 所标识的配置项的值。<code>ConfigurationProvider</code> 是只读的，<code>ConfigurationProvider</code> 只负责从持久化资源中读取配置数据，而不负责更新保存在持久化资源的配置数据，它的 <code>Set</code> 方法设置的配置数据只会保存在内存中。<code>ConfigurationProvider</code> 的 <code>GetChildKeys</code> 方法用于获取某个指定配置节点的所有子节点的 Key。</p>
<h2 id="ConfigurationSource-对象"><a href="#ConfigurationSource-对象" class="headerlink" title="ConfigurationSource 对象"></a>ConfigurationSource 对象</h2><p><code>ConfiurationSource</code> 在配置模型中代表配置源，它通过注册到 <code>ConfigurationBuilder</code> 上为后者创建的 <code>Configuration</code> 提供原始的配置数据。由于原始配置数据的读取实现在相应的 <code>ConfigurationProvider</code> 中，所以 <code>ConfigurationSource</code> 的作用在于提供相应的 <code>ConfigurationProvider</code>。如下面的代码片段所示，该接口具有一个唯一的 <code>Build</code> 方法根据指定的 <code>ConfigurationBuilder</code> 对象提供对应的<code>ConfigurationProvider</code>。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IConfigurationSource</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">IConfigurationProvider <span class="title">Build</span>(<span class="params">IConfigurationBuilder builder</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="ConfigurationBuilder-对象"><a href="#ConfigurationBuilder-对象" class="headerlink" title="ConfigurationBuilder 对象"></a>ConfigurationBuilder 对象</h2><p><code>ConfigurationBulder</code> 在整个配置模型中处于一个核心地位，它是 <code>Configuration</code> 的创建者，<code>IConfigurationBulder</code> 接口定义了两个方法，其中 <code>Add</code> 方法用于注册 <code>ConfigurationSource</code>，最终的 <code>Configuration</code> 则通过 <code>Build</code> 方法创建，后者返回一个代表整棵配置树的<code>ConfigurationRoot</code> 对象。注册的 <code>ConfigurationSource</code> 保存在 <code>Sources</code> 属性表示的集合中，<code>Properties</code> 属性则以字典的形式存放任意的自定义数据。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IConfigurationBuilder</span></span><br><span class="line">&#123;</span><br><span class="line">    IEnumerable&lt;IConfigurationSource&gt;  Sources &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    Dictionary&lt;<span class="keyword">string</span>, <span class="keyword">object</span>&gt;         Properties &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">IConfigurationBuilder     <span class="title">Add</span>(<span class="params">IConfigurationSource source</span>)</span>;</span><br><span class="line">    <span class="function">IConfigurationRoot        <span class="title">Build</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>配置系统提供了 <code>ConfigurationBulder</code> 类型作为 <code>IConfigurationBulder</code> 接口的默认实现者。</p>
<blockquote>
<p>无论是 <code>ConfigurationRoot</code> 还是 <code>ConfigurationSection</code>，它们自身都没有维护任何数据。这句话有点自相矛盾，因为配置树仅仅是 API 在逻辑上所体现的数据结构，并不代表具体的配置数据也是按照这样的结构进行存储的。</p>
</blockquote>
<h1 id="对象关系图"><a href="#对象关系图" class="headerlink" title="对象关系图"></a>对象关系图</h1><p>配置系统的四个核心对象之间的关系简单而清晰，可以通过一句话来概括: <code>ConfigurationBuilder</code> 利用注册的 <code>ConfigurationSource</code> 得到相应的 <code>ConfigurationProvider</code>，再调用 <code>ConfigurationProvider</code> 的 <code>Load</code> 方法读取原始配置数据并创建出相应的 <code>Configuration</code> 对象。下图所示的 UML 展示了配置模型涉及的主要接口/类型以及它们之间的关系:<br><img src="/aspnetcore-fundamentals-configuration/4-core-objects.png" title="配置系统核心对象关系图"></p>
<h1 id="同步-Configuration-的更改"><a href="#同步-Configuration-的更改" class="headerlink" title="同步 Configuration 的更改"></a>同步 Configuration 的更改</h1><p>参考<a href="http://www.cnblogs.com/artech/p/new-config-system-10.html" target="_blank" rel="noopener">配置的同步机制是如何实现的？</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://berdypango.github.io/aspnetcore-fundamentals-filesystem/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Frost He">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FrostHe.Handbook">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/aspnetcore-fundamentals-filesystem/" itemprop="url">ASP.NET Core 框架基础 - 文件系统</a></h1>
        

        <div class="post-meta">
          
          <span class="post-time">
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  2,069
                </span>
              

              

              
            </div>
          

          
              <div class="post-description">
                  .NET Core 以 File Provider 为核心构建了一套抽象的「文件系统」
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>参考资料:</p>
<ul>
<li><a href="http://www.cnblogs.com/artech/p/net-core-file-provider-01.html" target="_blank" rel="noopener">ASP.NET Core 的文件系统</a></li>
<li><a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/file-providers?view=aspnetcore-2.1" target="_blank" rel="noopener">File Providers in ASP.NET Core</a></li>
</ul>
<p>本文大纲:<br><!-- TOC --></p>
<ul>
<li><a href="#%E6%8A%BD%E8%B1%A1%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F">抽象的「文件系统」</a></li>
<li><a href="#fileprovider-%E6%8A%BD%E8%B1%A1">FileProvider 抽象</a></li>
<li><a href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%9E%E7%8E%B0%E8%80%85">文件系统的实现者</a><ul>
<li><a href="#physicalfileprovider">PhysicalFileProvider</a></li>
<li><a href="#embeddedfileprovider">EmbeddedFileProvider</a></li>
<li><a href="#compositefileprovider">CompositeFileProvider</a></li>
</ul>
</li>
<li><a href="#%E7%9B%91%E6%8E%A7%E5%8F%98%E5%8C%96">监控变化</a></li>
<li><a href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3">文件系统详解</a><ul>
<li><a href="#fileinfo--getfileinfo-%E6%96%B9%E6%B3%95">FileInfo &amp; GetFileInfo 方法</a></li>
<li><a href="#directorycontents--getdirectorycontents-%E6%96%B9%E6%B3%95">DirectoryContents &amp; GetDirectoryContents 方法</a></li>
<li><a href="#changetoken-%E5%8F%8A-watch-%E6%96%B9%E6%B3%95">ChangeToken 及 Watch 方法</a></li>
<li><a href="#%E8%B7%AF%E5%BE%84%E5%89%8D%E7%BC%80">路径前缀 「/」</a></li>
<li><a href="#%E5%AF%B9%E8%B1%A1%E5%85%B3%E7%B3%BB%E5%9B%BE">对象关系图</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->
<h1 id="抽象的「文件系统」"><a href="#抽象的「文件系统」" class="headerlink" title="抽象的「文件系统」"></a>抽象的「文件系统」</h1><p>ASP.NET Core 利用一个抽象化的 <code>FileProvider</code> 以统一的方式提供所需的文件。<code>FileProvider</code> 是所有实现了 <code>IFileProvider</code> 接口的类型的统称，<code>FileProvider</code> 是个抽象的概念，所以由它构建的也是一个抽象的文件系统。</p>
<p>这个文件系统采用目录的方式来组织和规划文件，这里所谓的目录和文件都是抽象的概念，并非对一个具体物理目录和文件的映射。文件系统的目录仅仅是文件的逻辑容器，而文件可能对应一个物理文件，也可能保存在数据库中，或者来源于网络，甚至有可能根本就不能存在，其内容需要在读取时动态生成。</p>
<p>一个 <code>FileProvider</code> 可以视为针对一个根目录的映射。目录除了可以存放文件之外，还可以包含多个子目录，所以目录/文件在整体上呈现出树形层细化结构。</p>
<h1 id="FileProvider-抽象"><a href="#FileProvider-抽象" class="headerlink" title="FileProvider 抽象"></a>FileProvider 抽象</h1><p><code>IFileProvider</code> 接口提供了获取文件信息(<code>IFileInfo</code>)和目录信息的方法，并支持追踪变化并发送通知(<code>IChangeToken</code>)的功能。</p>
<p><code>IFileInfo</code> 接口代表单独的文件信息或目录，其含有以下属性: </p>
<ul>
<li>Exists: 标识是否存在</li>
<li>IsDirectory: 标识是否为目录</li>
<li>Name: 描述「文件」的名称</li>
<li>Length: 以字节计算</li>
<li>LastModified: 上次修改的日期</li>
<li>CreateReadStream: 调用该方法来读取内容</li>
</ul>
<h1 id="文件系统的实现者"><a href="#文件系统的实现者" class="headerlink" title="文件系统的实现者"></a>文件系统的实现者</h1><p>IFileProvider 内置了三个实现类型:</p>
<ul>
<li>Physical: 访问真实的物理文件结构</li>
<li>Embedded: 访问嵌套于程序集内的文件</li>
<li>Composite: 组合来自于其他提供器的文件和目录访问</li>
</ul>
<h2 id="PhysicalFileProvider"><a href="#PhysicalFileProvider" class="headerlink" title="PhysicalFileProvider"></a>PhysicalFileProvider</h2><p><code>PhysicalFileProvider</code> 实现了对访问物理文件系统的支持，其内部包裹了 <code>System.IO.File</code> 类型，该类型将所有可访问路径限制在一个根目录下，在初始化该类型时必须为其提供一个代表目录的路径参数。以下代码演示了如何创建一个 <code>PhysicalFileProvider</code>:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IFileProvider provider = <span class="keyword">new</span> PhysicalFileProvider(applicationRoot);</span><br><span class="line">IDirectoryContents contents = provider.GetDirectoryContents(<span class="string">""</span>); <span class="comment">// the applicationRoot contents</span></span><br><span class="line">IFileInfo fileInfo = provider.GetFileInfo(<span class="string">"wwwroot/js/site.js"</span>); <span class="comment">// a file under applicationRoot</span></span><br></pre></td></tr></table></figure></p>
<h2 id="EmbeddedFileProvider"><a href="#EmbeddedFileProvider" class="headerlink" title="EmbeddedFileProvider"></a>EmbeddedFileProvider</h2><p>在 .NET Core 中，通过在 <em>.csproj</em> 文件中使用 <code>&lt;EmbeddedResource&gt;</code> 元素将文件嵌套至程序集中:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ItemGroup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">EmbeddedResource</span> <span class="attr">Include</span>=<span class="string">"Resource.txt;**\*.js"</span> <span class="attr">Exclude</span>=<span class="string">"bin\**;obj\**;**\*.xproj;packages\**;@(EmbeddedResource)"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Content</span> <span class="attr">Update</span>=<span class="string">"wwwroot\**\*;Views\**\*;Areas\**\Views;appsettings.json;web.config"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">CopyToPublishDirectory</span>&gt;</span>PreserveNewest<span class="tag">&lt;/<span class="name">CopyToPublishDirectory</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">Content</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ItemGroup</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>向 <code>EmbeddedFileProvider</code> 类型的构造函数提供 <code>Assembly</code> 对象来创建它。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> embeddedProvider = <span class="keyword">new</span> EmbeddedFileProvider(Assembly.GetEntryAssembly());</span><br></pre></td></tr></table></figure><br>嵌套资源没有「目录」的概念，不同命名空间的资源同样可以通过 <code>.</code> 语法来访问。<code>EmbeddedFileProvider</code> 类型的构造器接收一个可选的 <code>baseNamespace</code> 参数，指定该参数可以将调用 <code>GetDirectoryContents</code> 方法访问的范围限制在该命名空间下。</p>
<h2 id="CompositeFileProvider"><a href="#CompositeFileProvider" class="headerlink" title="CompositeFileProvider"></a>CompositeFileProvider</h2><p><code>CompositeFileProvider</code> 组合多个 <code>IFileProvider</code> 对象并暴露一个针对不同 provider 的统一访问接口，创建 <code>CompositeFileProvider</code> 实例需要向其传递一个或多个 <code>IFileProvider</code> 对象。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> physicalProvider = _hostingEnvironment.ContentRootFileProvider;</span><br><span class="line"><span class="keyword">var</span> embeddedProvider = <span class="keyword">new</span> EmbeddedFileProvider(Assembly.GetEntryAssembly());</span><br><span class="line"><span class="keyword">var</span> compositeProvider = <span class="keyword">new</span> CompositeFileProvider(physicalProvider, embeddedProvider);</span><br></pre></td></tr></table></figure></p>
<h1 id="监控变化"><a href="#监控变化" class="headerlink" title="监控变化"></a>监控变化</h1><p><code>IFileProvider</code> 包含一个 <code>Watch</code> 方法对监控文件和目录变化提供了支持，该方法接收一个路径参数，该参数可通过 <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/file-providers?view=aspnetcore-2.1#globbing-patterns" target="_blank" rel="noopener">globbing patterns</a> 来指定多个文件。<code>Watch</code> 方法返回一个 <code>IChangeToken</code> 对象，该对象包含一个 <code>HasChanged</code> 属性和一个 <code>RegisterChangeCallback</code> 方法。<code>RegisterChangeCallback</code> 在指定路径的文件发送变化后被调用。</p>
<p>值得注意的是，每一个 <code>IChangeToken</code> 对象仅监控<strong>一次</strong>变化。单个 <code>ChangeToken</code> 对象的使命在于当绑定的数据源第一次发生变换时对外发送相应的信号，而不具有持续发送数据变换的能力。它具有一个 <code>HasChanged</code> 属性表示数据是否已经发生变化，而并没有提供一个让这个属性「复位」的方法。</p>
<p>如果需要对文件进行持续监控，需要在注册的回调中重新调用 <code>FileProvider</code> 的 <code>Watch</code> 方法，并利用新生成的 <code>ChangeToken</code> 再次注册回调。除此之外，考虑到 <code>ChangeToken</code> 的 <code>RegisterChangeCallback</code> 方法以一个 <code>IDisposable</code> 对象的形式返回回调注册对象，我们应该在对回调实施二次注册时调用第一次返回的回调注册对象的 <code>Dispose</code> 方法将其释放掉。</p>
<p>或者，可以使用定义在 <code>ChangeToken</code> 类型中如下两个方法 <code>OnChange</code> 方法来注册数据发生改变时自动执行的回调。这两个方法具有两个参数:</p>
<ul>
<li><code>Func&lt;IChangeToken&gt;</code>: 用于创建 <code>ChangeToken</code>对象的委托对象</li>
<li><code>Action&lt;object&gt;/Action&lt;TState&gt;</code>: 代表回调操作的委托对象</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">ChangeToken</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IDisposable <span class="title">OnChange</span>(<span class="params">Func&lt;IChangeToken&gt; changeTokenProducer, Action changeTokenConsumer</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;        </span><br><span class="line">        Action&lt;<span class="keyword">object</span>&gt; callback = <span class="literal">null</span>;</span><br><span class="line">        callback = <span class="keyword">delegate</span> (<span class="keyword">object</span> s) &#123;</span><br><span class="line">            changeTokenConsumer();</span><br><span class="line">            changeTokenProducer().RegisterChangeCallback(callback, <span class="literal">null</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> changeTokenProducer().RegisterChangeCallback(callback, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> IDisposable OnChange&lt;TState&gt;(Func&lt;IChangeToken&gt; changeTokenProducer, Action&lt;TState&gt; changeTokenConsumer, TState state)</span><br><span class="line">    &#123;</span><br><span class="line">        Action&lt;<span class="keyword">object</span>&gt; callback = <span class="literal">null</span>;</span><br><span class="line">         callback = <span class="keyword">delegate</span> (<span class="keyword">object</span> s) &#123;</span><br><span class="line">            changeTokenConsumer((TState) s);</span><br><span class="line">            changeTokenProducer().RegisterChangeCallback(callback, s);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> changeTokenProducer().RegisterChangeCallback(callback, state);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以使用 <code>TaskCompletionSource</code> 对象:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">MainAsync</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IChangeToken token = _fileProvider.Watch(<span class="string">"quotes.txt"</span>);</span><br><span class="line">    <span class="keyword">var</span> tcs = <span class="keyword">new</span> TaskCompletionSource&lt;<span class="keyword">object</span>&gt;();</span><br><span class="line"></span><br><span class="line">    token.RegisterChangeCallback(state =&gt; </span><br><span class="line">        ((TaskCompletionSource&lt;<span class="keyword">object</span>&gt;)state).TrySetResult(<span class="literal">null</span>), tcs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> tcs.Task.ConfigureAwait(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">"quotes.txt changed"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>基于 Docker 容器和网络共享的文件系统不会正确的发送改变通知，可通过设置 <code>DOTNET_USE_POLLINGFILEWATCHER</code> 环境变量为 1 或者 true 每 4 秒轮询文件改变。</p>
</blockquote>
<h1 id="文件系统详解"><a href="#文件系统详解" class="headerlink" title="文件系统详解"></a>文件系统详解</h1><p><code>FileProvider</code> 的定义:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IFileProvider</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="function">IFileInfo <span class="title">GetFileInfo</span>(<span class="params"><span class="keyword">string</span> subpath</span>)</span>;</span><br><span class="line">    <span class="function">IDirectoryContents <span class="title">GetDirectoryContents</span>(<span class="params"><span class="keyword">string</span> subpath</span>)</span>;</span><br><span class="line">    <span class="function">IChangeToken <span class="title">Watch</span>(<span class="params"><span class="keyword">string</span> filter</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="FileInfo-amp-GetFileInfo-方法"><a href="#FileInfo-amp-GetFileInfo-方法" class="headerlink" title="FileInfo &amp; GetFileInfo 方法"></a>FileInfo &amp; GetFileInfo 方法</h2><p>可以通过向 <code>GetFileInfo</code> 传递一个子路径(通常为相对路径)来访问指定文件的信息，当调用这个方法的时候，无论指定的路径是否存在，该方法总是返回一个具体的 <code>FileInfo</code> 对象。即使指定的路径对应一个具体的目录，这个 <code>FileInfo</code> 对象的 <code>IsDirectory</code> 也总是返回 False（它的Exists属性也返回False）。</p>
<h2 id="DirectoryContents-amp-GetDirectoryContents-方法"><a href="#DirectoryContents-amp-GetDirectoryContents-方法" class="headerlink" title="DirectoryContents &amp; GetDirectoryContents 方法"></a>DirectoryContents &amp; GetDirectoryContents 方法</h2><p>调用 <code>FileProvider</code> 的 <code>GetDirectoryContents</code> 方法，目录内容通过该方法返回 <code>DirectoryContents</code> 对象来表示。一个 <code>DirectoryContents</code> 对象实际上表示一个 <code>FileInfo</code> 的集合，组成这个集合的所有 <code>FileInfo</code> 是对所有文件和子目录的描述。和 <code>GetFileInfo</code> 方法一样，不论指定的目录是否存在，<code>GetDirectoryContents</code> 方法总是会返回一个具体的 <code>DirectoryContents</code> 对象，它的 Exists 属性会帮助我们确定指定目录是否存在。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface IDirectoryContents : IEnumerable&lt;IFileInfo&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">bool</span> Exists &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="ChangeToken-及-Watch-方法"><a href="#ChangeToken-及-Watch-方法" class="headerlink" title="ChangeToken 及 Watch 方法"></a>ChangeToken 及 Watch 方法</h2><p>目前仅 <code>PhysicalFileProvider</code> 类型提供了 Watch 方法的实现，它会委托一个 <code>FileSystemWatcher</code> 对象来完成最终的文件监控任务。<code>Watch</code> 方法的返回类型为 <code>IChangeToken</code> 接口，<code>ChangeToken</code> 可视为一个与某个数据进行关联，并在数据发生变化对外发送通知的令牌。如果关联的数据发生改变，它的 <code>HasChanged</code> 属性将变成 <code>True</code>。调用它的 <code>RegisterChangeCallback</code> 方法注册一个在数据发生改变时可以自动执行的回调方法。该方法以一个 <code>IDisposable</code> 对象的形式返回注册对象，原则上讲我们应该在适当的时机调用其 <code>Dispose</code> 方法注销回调的注册，以免内存泄漏。<code>IChangeToken</code> 接口的另一个属性 <code>ActiveChangeCallbacks</code>，它表示当数据发生变化时是否需要主动执行注册的回调操作。</p>
<h2 id="路径前缀-「-」"><a href="#路径前缀-「-」" class="headerlink" title="路径前缀 「/」"></a>路径前缀 「/」</h2><p>无论是调用 <code>GetFileInfo</code>，<code>GetDirectoryContents</code> 方法指定的目标文件和目录的路径，还是在调用 <code>Watch</code> 方法时指定筛选表达式，都是针对当前 <code>FileProvider</code> 根目录的相对路径。指定的这个路径可以采用 <code>/</code> 字符作为前缀，但是这个前缀是不必要的。</p>
<h2 id="对象关系图"><a href="#对象关系图" class="headerlink" title="对象关系图"></a>对象关系图</h2><p>文件系统还涉及到其他一些对象，如 <code>DirectoryContents</code>、<code>FileInfo</code> 和 <code>ChangeToken</code>。这些对象都具有对应的接口定义，下图所示的 UML 展示了涉及的这些接口以及它们之间的关系。</p>
<img src="/aspnetcore-fundamentals-filesystem/objects-uml.png" title="对象关系图">
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://berdypango.github.io/microservice-overview/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Frost He">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FrostHe.Handbook">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/microservice-overview/" itemprop="url">微服务架构的挑战与解决方案</a></h1>
        

        <div class="post-meta">
          
          <span class="post-time">
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  2,586
                </span>
              

              

              
            </div>
          

          
              <div class="post-description">
                  总结了使用微服务架构应用程序所面临的挑战与解决方案
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="分布式数据管理的挑战和解决方案"><a href="#分布式数据管理的挑战和解决方案" class="headerlink" title="分布式数据管理的挑战和解决方案"></a>分布式数据管理的挑战和解决方案</h1><h2 id="挑战-1-如何定义每个微服务的边界"><a href="#挑战-1-如何定义每个微服务的边界" class="headerlink" title="挑战 #1: 如何定义每个微服务的边界"></a>挑战 #1: 如何定义每个微服务的边界</h2><p>定义微服务边界可能是每位用户遇到的第一项挑战。每个微服务必须是应用程序的一部分，并且每个微服务应对其带来的优势和挑战具有自治性。但是，如何识别这些边界？</p>
<p>首先，需要着重关注应用程序的逻辑域模型和相关数据。必须尝试识别同一应用程序中数据和不同上下文的分离岛。每个上下文可能具有不同的业务语言(不同的业务术语)，应独立定义和管理上下文。不同上下文中所用的术语和实体可能听起来很相似，但你可能会发现在特定上下文中，某个业务概念可在另一个上下文中用于不同目的，甚至名称也不同。例如，用户在身份或成员身份上下文中称为用户，在 CRM 上下文中称为客户，在订购上下文中称为购买者等等。</p>
<p>多个应用程序上下文(各上下文具有不同域)之间的边界识别方法，也可用于识别各业务微服务及其相关域模型和数据的边界。始终尝试最大程度减少这些微服务之间的耦合度。</p>
<h2 id="挑战-2-如何创建从多个微服务中检索数据的查询"><a href="#挑战-2-如何创建从多个微服务中检索数据的查询" class="headerlink" title="挑战 #2: 如何创建从多个微服务中检索数据的查询"></a>挑战 #2: 如何创建从多个微服务中检索数据的查询</h2><p>第二个挑战是如何实现从多个微服务中检索数据的查询，同时避免从远程客户端应用到微服务的闲时通信。例如，某个移动应用的单个屏幕需要显示属于购物篮、目录和用户标识微服务的用户信息。还例如，某个复杂报告涉及位于多个微服务中的表。正确的解决方案取决于查询的复杂程度。但在任何情况下，如果想要提高系统通信的效率，都需要通过某种方法来聚合信息。最常用的解决方案如下:</p>
<ul>
<li>API 网关: 对于来自多个微服务(拥有不同数据库)的简单数据聚合，推荐方法是称为 API 网关的聚合微服务。</li>
<li>具有查询/读取表的 CQRS: 用于聚合来自多个微服务的数据的另一个解决方案是具体化视图模式。此方法将事先(在发生实际查询之前准备非规范化数据)生成一个包含属于多个微服务的数据的只读表。该表采用满足客户端应用要求的格式。</li>
<li>中央数据库的「冷数据」: 对于可能不需要实时数据的复杂报告和查询，常用方法是将「冷数据」作为「热数据」(来自微服务的事务数据)导出到仅用于报告的大型数据库。该中央数据库系统可以是基于大数据的系统(如 Hadoop)、基于 Azure SQL 数据仓库的数据仓库，甚至是仅用于报告的单个 SQL 数据库(如果大小没有问题)。</li>
</ul>
<p>请注意，此集中式数据库仅用于不需要实时数据的查询和报告。作为事实来源的原始更新和事务必须位于微服务数据中。用于同步数据的方法有两种：使用事件驱动的通信，或使用其他数据库基础结构导入/导出工具。 </p>
<h2 id="挑战-3-如何跨多个微服务实现一致性"><a href="#挑战-3-如何跨多个微服务实现一致性" class="headerlink" title="挑战 #3: 如何跨多个微服务实现一致性"></a>挑战 #3: 如何跨多个微服务实现一致性</h2><p>每个微服务拥有的数据是该微服务专有的，并且只能通过其本身的微服务 API 访问。因此，面临的挑战是如何在保持多个微服务的一致性的同时实现端到端的业务进程。</p>
<p>「目录微服务」保存所有产品的相关信息，包括它们的库存。「订购微服务」管理订单，并且必须验证新订单是否超过可用目录产品库存。在该应用程序的单片版本中，订购子系统可简单地使用 ACID 事务来检查可用库存、在订单表中创建订单以及更新产品表中的可用库存。</p>
<p>但是，在基于微服务的应用程序中，订单和产品表属于其各自的微服务。如图所示，微服务不应包含其他微服务在其事务或查询中所拥有的数据库。</p>

<p>订购微服务不应直接更新产品表，因为产品表属于目录微服务。要更新目录微服务，订购微服务应只使用异步通信，如集成事件（消息和基于事件的通信）。需要在可用性和 ACID 一致性之间做出选择。大多数基于微服务的方案都需要高可用性和高可伸缩性，而非一致性。任务关键型应用程序必须随时保持最新且可运行状态，开发人员可通过使用弱或最终一致性的技术来实现一致性。 这是大多数基于微服务的体系结构采用的方法。</p>
<p>此外，ACID 式或两阶段提交事务均违背微服务原则；大多数 NoSQL 数据库(如 Azure Cosmos DB、MongoDB 等)不支持两阶段提交事务。但维护服务和数据库的数据一致性至关重要。此挑战还涉及，当某些数据需要冗余时(例如，需要在目录微服务和购物篮微服务中使用产品名称或说明时)，如何在多个微服务之间传播更改。</p>
<h2 id="挑战-4：如何设计跨微服务边界的通信"><a href="#挑战-4：如何设计跨微服务边界的通信" class="headerlink" title="挑战 #4：如何设计跨微服务边界的通信"></a>挑战 #4：如何设计跨微服务边界的通信</h2><p>假设客户端应用程序对单个微服务（如订购微服务）进行 HTTP API 调用。如果订购微服务在相同的请求/响应周期内转而使用 HTTP 调用其他微服务，这表示正在创建 HTTP 调用链。刚开始时，这可能听起来很合理。但是，如果继续进行，则需要考虑一些重要问题：</p>
<ul>
<li>堵塞和低性能: 由于 HTTP 同步性质，直到所有内部 HTTP 调用完成后，原始请求才会收到响应。假设这些调用的数量显著增加，同时某个对微服务的中间 HTTP 调用受到阻塞。这会对性能造成影响，并且随着其他 HTTP 请求的增加，整体可伸缩性将受到的影响将成倍增长。</li>
<li>微服务将与 HTTP 耦合: 业务微服务不应与其他业务微服务耦合。理想情况下，它们不应「知道」其他微服务的存在。如果应用程序依赖于如例所示的耦合微服务，那么几乎不可能实现每个微服务的自治。</li>
<li>任一微服务中失败将导致最终失败: 如果实现由 HTTP 调用链接的微服务链，那么任一微服务失败(最终所有微服务都将失败)都将导致整个微服务链的失败。基于微服务的系统应设计为在部分故障期间也尽可能地继续工作。即使实现使用具有指数回退或断路器机制的客户端逻辑，HTTP 调用链越复杂，实现基于 HTTP 的故障策略就越复杂。</li>
</ul>
<img src="/microservice-overview/image15.png" title="微服务间通信的反模式与模式">
<h2 id="异步微服务集成强化了微服务的自治性"><a href="#异步微服务集成强化了微服务的自治性" class="headerlink" title="异步微服务集成强化了微服务的自治性"></a>异步微服务集成强化了微服务的自治性</h2><p>生成基于微服务的应用程序时，重要的是集成微服务的方法。理想情况下，应尝试减少内部微服务之间的通信，微服务间的通信越少越好。但在许多情况下，必须以某种方式集成微服务，当需要执行此操作时，关键的规则是微服务间的通信应为「异步」。这并不代表必须使用特定协议(例如，异步消息传送与同步 HTTP)。 这仅代表微服务之间的通信<strong>「应该只通过异步传播数据来完成，但不要依赖其他内部微服务作为初始服务的 HTTP 请求/响应操作的一部分。」</strong></p>
<p>微服务通信通常分为两个轴:</p>
<ol>
<li>同步还是异步<ul>
<li>同步协议: HTTP 是同步协议。客户端发送请求并等待服务响应，这与客户端代码执行无关，客户端可能是同步(线程被阻止)或异步的(线程没有被阻止，并且响应最终会到达回调)。重要的是，协议 (HTTP/HTTPS) 是同步的，仅当客户端代码接收到 HTTP 服务器响应时，才可以继续其任务。</li>
<li>异步协议: AMQP 之类的其他协议（许多操作系统和云环境支持的协议）使用异步消息。客户端代码或消息发件人通常不会等待响应。</li>
</ul>
</li>
<li>单个接收方还是多个接收方<ul>
<li>单个接收方: 命令模式，具有单个接收者的基于消息的异步通信意味着存在点到点通信，即，仅向正在从该通道读取数据的一个使用者传递消息，并且该消息仅处理一次。但也有一些特殊情况。例如，在试图从故障中自动恢复的云系统中，可以多次发送相同的消息。由于网络或其他故障，客户端必须能够重试发送消息，并且服务器必须实现幂等操作，以便对特定消息仅处理一次。基于消息的单接收者通信特别适用于将异步命令从一个微服务发送到另一个微服务。<img src="/microservice-overview/image18.png" title="接收异步消息的单个微服务"></li>
<li>多个接收方: 发布/订阅模式，作为一种更灵活的方法，你可能还需要使用发布/订阅机制，以便其他订阅者微服务或外部应用程序能够收到发送者发送的通信。这样一来，以后无需修改发送者服务也可添加额外的订阅者。使用发布/订阅通信时，你可能会使用事件总线接口向任何订阅者发布事件。</li>
</ul>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://berdypango.github.io/ddd-tactical-domain-service/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Frost He">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FrostHe.Handbook">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/ddd-tactical-domain-service/" itemprop="url">《实现领域驱动设计》读书笔记(6) - 战术建模之领域服务</a></h1>
        

        <div class="post-meta">
          
          <span class="post-time">
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  1,044
                </span>
              

              

              
            </div>
          

          
              <div class="post-description">
                  当某个操作不适合放在实体和值对象上时，最好的方式便是使用领域服务
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>系列大纲: <a href="/tags/ddd/">《实现领域驱动设计》读书笔记</a></p>
<p>本文大纲:<br><!-- TOC --></p>
<ul>
<li><a href="#%E5%89%8D%E8%A8%80">前言</a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%A2%86%E5%9F%9F%E6%9C%8D%E5%8A%A1">什么是领域服务</a><ul>
<li><a href="#%E7%8B%AC%E7%AB%8B%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%91%BD%E5%90%8D%E5%AE%9E%E8%B7%B5">独立的接口和命名实践</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>领域中的服务表示一个<strong>无状态</strong>的操作，它用于实现特定于某个领域的任务。当某个操作不适合放在实体和值对象上时，最好的方式便是使用领域服务了。有时我们倾向于使用聚合根上的静态方法来实现这些操作，但是在 DDD 中，这是一种代码异味。</p>
<h1 id="什么是领域服务"><a href="#什么是领域服务" class="headerlink" title="什么是领域服务"></a>什么是领域服务</h1><p>虽然领域服务中有 “服务” 这个词，但它并不意味着作为远程的，重量级的事务操作的提供方。<strong>当领域中的某个操作过程或转换过程不是实体或值对象的职责时，我们便应该将该操作放在一个单独的接口中，即领域服务。</strong>参考以下几点来对领域模型建模: </p>
<ul>
<li>执行一个显著的业务操作过程</li>
<li>对领域对象进行转换</li>
<li>以多个领域对象作为输入进行计算，结果产生一个值对象。</li>
</ul>
<p>以上第三点提到的 “计算”，也应该具有 “显著的业务操作过程” 的特点。请确保领域服务是无状态的，并且能够明确的表达限界上下文中的<strong>「通用语言」</strong>。</p>
<p>过度得使用领域服务将导致贫血领域模型，即所有的业务逻辑都位于领域服务中，而不是实体和值对象中。以下的例子是一个使用领域服务的情况，假设我们有以下需求: </p>
<ul>
<li>系统必须对 User 进行认证(authenticate)，并且只有当 Tenant 处于激活状态时才能对 User 进行认证。</li>
<li>密码必须经过加密，且不能使用明文密码</li>
</ul>
<p>此时，认证细节不属于 Tenant 或 User 的职责，应该创建一个专门处理认证逻辑的领域服务，客户端伪代码如下:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> authenticationService = DomainRegistry.AuthenticationService();</span><br><span class="line"><span class="keyword">var</span> userDescriptor = authenticationService.Authenticate(tenantId, username, password);</span><br></pre></td></tr></table></figure><br>客户端只需获取到一个无状态的 <code>AuthenticationService</code>，然后调用它的 Authenticate 方法即可。与认证有关的所有实现细节放在领域服务中，在需要的情况下，领域服务可以使用任何领域对象来完成操作，包括对密码的加密过程。客户端不需要知道任何认证细节。该方法返回一个 UserDescriptor 值对象，这是一个很小的对象，并且是安全的。</p>
<p>而调用这段代码的客户方，在多数情况下为<strong>「应用服务」</strong>，它可以进一步将该 UserDescriptor 对象返回给它自己的调用者，由此可见领域服务和应用服务的区别。</p>
<h2 id="独立的接口和命名实践"><a href="#独立的接口和命名实践" class="headerlink" title="独立的接口和命名实践"></a>独立的接口和命名实践</h2><p>如果该领域服务可能有多种实现，那么应该为其定义单独的接口，该接口应该与身份相关聚合(比如 Tenant，User 和 Group)定义在相同的<strong>「模块」</strong>中，因为 <code>AuthenticationService</code> 也是一个与身份相关的概念。而该接口的实现类——如果正在使用<strong>「依赖倒置原则」</strong>或<strong>「六边形架构」</strong>，可以放置在基础设施层的某个模块中。</p>
<p>在 C# 中通常以 I 字符开头来表示接口，此处的接口名称为 IAuthenticationService，但如果这里将实现类命名为 AuthentionService 或 DefaultAuthenticationService，这通常意味着根本就不需要一个接口，如果领域服务有多个实现类，那么应该根据各种实现类的特点进行命名，这也意味着在领域中存在一些特定的功能。对于非技术性的领域服务来说，去除接口是不会破坏可测试性的，因为该服务依赖的所有接口都可以注入进来。</p>
<blockquote>
<p>依据笔者的理解，作者此处是想说明，接口很容易遭到滥用，很多模块将接口和其默认实现定义在同一个包中，这通常可以由一个单一的实现类来代替。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://berdypango.github.io/ddd-tactical-value-object/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Frost He">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FrostHe.Handbook">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/ddd-tactical-value-object/" itemprop="url">《实现领域驱动设计》读书笔记(5) - 战术建模之值对象</a></h1>
        

        <div class="post-meta">
          
          <span class="post-time">
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  4,583
                </span>
              

              

              
            </div>
          

          
              <div class="post-description">
                  值对象用于度量和描述事物，即便一个领域概念必须建模成实体，在设计时也应该更偏向于将其作为值对象的容器，而不是子实体的容器
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>系列大纲: <a href="/tags/ddd/">《实现领域驱动设计》读书笔记</a></p>
<p>本文大纲: </p>
<ul>
<li><a href="#%E4%B8%8D%E5%8F%98%E6%80%A7">不变性</a></li>
<li><a href="#%E6%A6%82%E5%BF%B5%E6%95%B4%E4%BD%93">概念整体</a></li>
<li><a href="#%E5%8F%AF%E6%9B%BF%E6%8D%A2%E6%80%A7">可替换性</a></li>
<li><a href="#%E5%80%BC%E5%AF%B9%E8%B1%A1%E7%9B%B8%E7%AD%89%E6%80%A7">值对象相等性</a></li>
<li><a href="#%E6%97%A0%E5%89%AF%E4%BD%9C%E7%94%A8%E8%A1%8C%E4%B8%BA">无副作用行为</a></li>
<li><a href="#%E6%9C%80%E5%B0%8F%E5%8C%96%E9%9B%86%E6%88%90">最小化集成</a></li>
<li><a href="#%E7%94%A8%E5%80%BC%E5%AF%B9%E8%B1%A1%E8%A1%A8%E7%A4%BA%E6%A0%87%E5%87%86%E7%B1%BB%E5%9E%8B">用值对象表示标准类型</a></li>
<li><a href="#%E5%AE%9E%E7%8E%B0">实现</a></li>
<li><a href="#%E6%8C%81%E4%B9%85%E5%8C%96%E5%80%BC%E5%AF%B9%E8%B1%A1">持久化值对象</a><ul>
<li><a href="#%E5%8D%95%E4%B8%AA%E5%80%BC%E5%AF%B9%E8%B1%A1">单个值对象</a></li>
<li><a href="#%E5%80%BC%E5%AF%B9%E8%B1%A1%E9%9B%86%E5%90%88%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%B0%E5%8D%95%E4%B8%AA%E5%88%97%E4%B8%AD">值对象集合序列化到单个列中</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E4%BD%93%E4%BF%9D%E5%AD%98%E5%A4%9A%E4%B8%AA%E5%80%BC%E5%AF%B9%E8%B1%A1">使用数据库实体保存多个值对象</a></li>
<li><a href="#orm-%E4%B8%8E%E6%9E%9A%E4%B8%BE%E7%8A%B6%E6%80%81%E5%AF%B9%E8%B1%A1">ORM 与枚举状态对象</a></li>
</ul>
</li>
</ul>
<p>值对象用于度量和描述事物，即便一个领域概念必须建模成实体，在设计时也应该更偏向于将其作为值对象的容器，而不是子实体的容器</p>
<blockquote>
<p>笔者曾一度认为值对象就是 C# 语言中使用 <code>struct</code> 结构来表示的多个数据代表一个整体的集合，后来发现书中讲到的值对象无关技术实现，而是从概念上定义它的职责，包括不可变性和非唯一性。</p>
</blockquote>
<blockquote>
<p>同样的，在有了实体这把武器之后，当一个实体需要嵌套其他对象时，实体经常遭到滥用。当面临将对象定义为实体还是值对象的选择时，由于缺乏对于值对象的充分认识，很多开发人员选择了嵌套实体。</p>
</blockquote>
<h2 id="不变性"><a href="#不变性" class="headerlink" title="不变性"></a>不变性</h2><p>当我们只关心某个对象的属性时，该对象便可作为一个值对象，为其添加有意义的属性，并赋予它们相应的行为。值对象在其生命周期中是「<strong>不可变</strong>」的，本身代表了某种状态，它没有任何身份标识，也应该尽量避免像实体一样复杂。在设计得当的前提下，我们可以对值对象的实例进行创建和传递，甚至在使用完之后将其直接扔掉。我们不必担心客户代码对值对象进行修改，一个值对象的生命周期可长可短，它就像一个无害的过客在系统中来来往往。</p>
<p>当决定一个领域概念是否是一个值对象时，考虑以下特征：</p>
<ul>
<li>它度量或者描述了领域中的一件东西</li>
<li>它可以作为不变量</li>
<li>它将不同的相关的属性组合成一个概念性的整体</li>
<li>当度量和描述改变时，可以用另一个值对象予以替换</li>
<li>它可以和其他值对象进行相等性比较</li>
<li>它不会对协作对象造成副作用</li>
</ul>
<p>为了保持值对象的不变性，创建它所依赖的参数必须一次性全部传给其构造函数，之后任何时间都不可能再改变它。有时根据需要，会在值对象中引用实体对象，这种情况需要谨慎，当实体对象的状态发生改变时，引用它的值对象也将发生改变，这违背了值对象不变性特征。</p>
<h2 id="概念整体"><a href="#概念整体" class="headerlink" title="概念整体"></a>概念整体</h2><p>编程语言提供的基元类型(如 <code>string</code>, <code>int</code>, <code>double</code> 等)似乎是值对象的最佳类型，但有时，这种思维方式会造成对基元类型的滥用。</p>
<p>假如需要在 「<strong>ThingOfWorth</strong>」 类中加入名为 「<strong>Name</strong>」 的属性，我们自然而然的会想到将其定义为 <code>string</code> 类型，但很快我们就发现该类型的名字需要以不同的方式进行展示，此时，处理展示方式的逻辑就会莫名其妙的由客户代码来完成，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户代码</span></span><br><span class="line">String name = thingOfWorth.name();</span><br><span class="line">String capitalizedName = name.subString(<span class="number">0</span>,<span class="number">1</span>).toUpperCase() + name.subString(<span class="number">1</span>).toLowerCase();</span><br></pre></td></tr></table></figure></p>
<p>在以上示例中，客户代码自己试图解决 <code>name</code> 的大小写问题。通过定义 「<strong>ThingName</strong>」 类型，我们可以将与 <code>name</code> 有关的所有逻辑操作放到该类型中，然后在构造该值对象时进行格式化，客户代码只需调用相应的方法即可得到结果，而不必自行处理这些逻辑。</p>
<p>有些编程语言允许我们简单地向一个类添加新的行为(例如 C# 的扩展方法)。此时，你可能会想着用 <code>Double</code> 类型来表示货币，如果需要计算不同货币之间的汇率，我们只需要向 <code>Double</code> 类型添加 <code>convertToCurrency(Currency aCurrency)</code> 扩展方法即可。但是在这种场景下使用语言特性就一定是一个好主意吗？首先，和货币相关的行为很有可能丢失在浮点数计算中；其次，<code>Double</code> 类型也丝毫没有表达出领域概念。很快，我们就会丢掉领域关注点。</p>
<blockquote>
<p>当你试图将多个属性加在一个实体上，这有可能弱化了各个属性之间的关系，那么此时就应该考虑将这些相互关联的属性组合在一个值对象中了。每个值对象都是一个「<strong>内聚的概念整体</strong>」，它表达了通用语言中的一个概念。</p>
</blockquote>
<h2 id="可替换性"><a href="#可替换性" class="headerlink" title="可替换性"></a>可替换性</h2><p>值对象的可替换性可通过数字的替换来理解，假设领域中有一个名为 <code>total</code> 的概念，该概念用整数表示。如果 <code>total</code> 的当前值为 <code>3</code>，但是之后需要重设为 <code>4</code>，此时我们并不会将整数修改成 <code>4</code>，而是简单地将 <code>total</code> 的值重新赋值为 <code>4</code>。</p>
<blockquote>
<p>从语言层面来说，这里的修改其实是对该属性赋新值，但看上去像是修改，实际上只是语法糖，原先为 <code>3</code> 的内存并不会被修改为 <code>4</code>，而是被新的代表 <code>4</code> 的内存块替代。</p>
</blockquote>
<p>考虑下面一种更复杂的值对象替换：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FullName name = <span class="keyword">new</span> FullName(<span class="string">"金"</span>,<span class="string">"沐"</span>);</span><br><span class="line"><span class="comment">// 稍后</span></span><br><span class="line">name = <span class="keyword">new</span> FullName(<span class="string">"金"</span>,<span class="string">"灶沐"</span>);</span><br></pre></td></tr></table></figure></p>
<p>这里，我们并没有使用 FullName 类型的某个方法来修改其自身的状态(<strong>这破坏了值对象的不变性</strong>)，而是构造一个新的值对象实例来替换原来的实例。</p>
<h2 id="值对象相等性"><a href="#值对象相等性" class="headerlink" title="值对象相等性"></a>值对象相等性</h2><p>值对象的相等性应该由组成其实例的每一个属性及其类型来决定，在上文的 「<strong>FullName</strong>」 对象中，当两个 「<strong>FullName</strong>」 实例的每个属性及其类型都相等，我们才认为两个实例相等，尽管他们在内存中是不同的地址。值对象的相等性可用来支撑「<strong>聚合</strong>」唯一标识的比较，实体的唯一标识是不能改变的，这可以部分通过值对象的不变性实现。值对象的整体概念也可以用来支撑不只一个属性的实体标识，同时，如果实体的唯一标识需要一些「<strong>无副作用行为</strong>」，这些行为便可以在值对象上实现。</p>
<h2 id="无副作用行为"><a href="#无副作用行为" class="headerlink" title="无副作用行为"></a>无副作用行为</h2><p>一个对象的方法可以设计成一个「<strong>无副作用函数(Side-Effect Free Function)</strong>」，该函数表示对某个对象的操作，只用于产生输出，而不会修改对象的状态。对于不变的值对象而言，所有的方法都必须是无副作用函数。下面的例子通过调用 「<strong>FullName</strong>」 对象上的无副作用方法将该对象本身替换成另一个实例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FullName name = <span class="keyword">new</span> FullName(<span class="string">"金"</span>,<span class="string">"沐"</span>);</span><br><span class="line"><span class="comment">// 稍后</span></span><br><span class="line">name = name.withMiddleInitial(<span class="string">"灶"</span>);</span><br></pre></td></tr></table></figure></p>
<p>这里的代码更具表达性，<code>withMiddleInitial</code> 方法并没有修改值对象的状态，因此它不会产生副作用。该方法通过已有 <code>firstName</code> 和 <code>lastName，外加传入的</code> <code>middleName</code> 创建一个新的 <code>FullName</code> 值对象实例。<code>withMiddleInitial()</code> 还捕获到了重要的领域业务逻辑，从而避免了将这些逻辑泄漏到客户代码中。</p>
<blockquote>
<p>这里所说的捕获重要的领域业务逻辑，是指该方法本身是具有表达性的，比起使用 <code>new</code> 语句创建实例，更像是调用了该实例支持的某个行为满足了客户代码的需求。</p>
</blockquote>
<p>有些值对象的方法引用了实体，这存在一些问题。例如下面的代码，我们有一个实体对象 <code>product</code>，该对象被值对象 <code>BusinessPriority</code> 引用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> priority = businessPriority.priorityOf(product);</span><br></pre></td></tr></table></figure></p>
<p>我们至少可以看出以下问题：</p>
<ul>
<li><code>BusinessPriority</code> 不仅依赖 <code>Product</code> 类型，还试图去理解该实体的内部状态，我们应该尽量使值对象只依赖于它自己的属性，并且只理解它自身的状态。</li>
<li>阅读本段代码的人并不知道使用了 <code>Product</code> 的哪些部分，这种表达方法并不明确，从而降低了模型的清晰度。更好的方式是只传入需要用到的 <code>Product</code> 属性。</li>
<li>更重要的是，在将实体作为参数的值对象方法中，我们很难看出该方法是否会对实体进行修改，测试也将变得非常困难。</li>
</ul>
<p>有了以上分析，我们需要对值对象进行改进，要增加一个值对象的健壮性，我们传给值对象方法的参数依然应该是值对象。这样我们可以获得更高层次的无副作用行为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> priority = businessPriority.priority(product.businessPriorityTotals());</span><br></pre></td></tr></table></figure></p>
<p>这里，我们把 <code>Product</code> 实体的 <code>BusinessPriorityTotals</code> 值对象传递给了 <code>priority()</code> 方法。</p>
<hr>
<p>如果打算使用编程语言提供的基本值对象类型，而不使用特定的值对象，我们是无法将领域特定的无副作用函数分配给编程语言提供的基元值对象的。有些真正简单的属性是没有必要特殊对待的。例如，一些布尔类型或数值类型，它们已经能够自给了，并不需要额外的功能支持，也并不和实体中的其他属性关联。这些简单的属性称为<strong>意义整体</strong>。</p>
<h2 id="最小化集成"><a href="#最小化集成" class="headerlink" title="最小化集成"></a>最小化集成</h2><p>当模型概念从上游上下文流入下游上下文时，尽量使用值对象来表示这些概念。这样做的好处是可以达到最小化集成，即最小化下游模型中用于管理职责的属性数目。</p>
<h2 id="用值对象表示标准类型"><a href="#用值对象表示标准类型" class="headerlink" title="用值对象表示标准类型"></a>用值对象表示标准类型</h2><p>系统中既有表示事物的实体和描述实体的值对象，同时还存在「<strong>标准类型(Standard Type)</strong>」来区分不同的类型。假设通用语言中定义了一个 「<strong>PhoneNumber</strong>」 值对象，同时需要为每个 「<strong>PhoneNumber</strong>」 对象制定一个类型，用以区分家庭电话，移动电话，工作电话还是其他类型的电话号码。不同类型的电话号码类型需要建模成一种类的层级关系吗？为每一个类型创建一个类对于客户代码的使用来说是非常困难的。此时，你需要标准类型来描述不同的电话号码，比如 <code>Home</code>，<code>Mobile</code>，<code>Work</code> 或者 <code>Other</code>。</p>
<p>枚举类型是实现标准类型的一种简单方法。枚举提供了一组有限数量的值对象，它非常轻量且无副作用。通常来说，<strong>没有必要为标准类型提供描述信息</strong>，只需要名字就足够了。为什么？文本描述通常只在<strong>用户界面层</strong>中才会用到，此时可以用一个显示资源和类型名字匹配起来。很多时候用于显示的文本都需要进行本地化，因此将这种功能放在模型中并不合适。通常来说，在模型中使用标准类型的名字是最好的方式。</p>
<blockquote>
<p>为了维护方便，最好是为标准类型创建单独的限界上下文。</p>
</blockquote>
<p>有些标准类型所表达的概念不像是某种标准而更像是一种状态，此时标准类型实现为状态模式，但为每一种状态创建单独的类会使系统变得复杂。对于实体的状态类来说，有些行为来自于自身，有些继承自抽象基类，这一方面在子类和父类之间形成了紧耦合，另一方面使代码的可读性变差。如果你不打算使用状态模式，那么枚举可能是最简单的方法。</p>
<p>一个共享不变的值对象可以从持久化存储中获取，此时可以通过标准类型的「<strong>领域服务</strong>」或「<strong>工厂</strong>」来获取值对象。<strong>我们应该为每组标准类型创建一个领域服务或工厂</strong>(比如一个服务处理电话号码类型，一个服务处理邮寄地址类型，另一个服务处理货币类型)，服务或工厂将按需从持久化存储中获取标准类型，而客户方代码并不知道这些标准类型是来自数据库中的。另外，使用领域服务或工厂还使得我们可以加入不同的缓存机制，由于值对象在数据库中是只读的，并且在整个系统中是不变的，缓存机制也将变得更加简单安全。</p>
<p>总的来说，建议尽量使用枚举来表示标准类型，即便你认为某个标准类型更像一种状态模式。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>通常来说，值对象至少包含两个构造函数，第一个构造函数接受用于构建对象状态的所有属性参数，称为主构造函数。该构造函数调用私有的 <code>setter</code> 方法初始化默认的对象状态，该私有的 <code>setter</code> 方法向我们展示了一种自委派性。</p>
<blockquote>
<p>只有主构造函数才能使用自委派性来设置属性值，除此之外，其他任何方法都不能使用 <code>setter</code> 方法。由于所有的 <code>setter</code> 方法都是私有的，消费方是没有机会调用这些方法的，这是保持值对象不变性的两个重要因素。</p>
</blockquote>
<p>第二个构造函数用于将一个值对象复制到另一个新的值对象，即复制构造函数。它将构造过程委派给主构造函数，先从原对象中取出各个属性，再将这些属性作为参数传给主构造函数。</p>
<blockquote>
<p>复制构造函数对于测试来说是非常重要的，测试对象时，我们希望验证值对象的不变性，通过复制构造函数创建一个原实例的副本，验证两者的相等性。</p>
</blockquote>
<h2 id="持久化值对象"><a href="#持久化值对象" class="headerlink" title="持久化值对象"></a>持久化值对象</h2><p>以下着重讨论如何持久化包含值对象的聚合实例。聚合的读取和保存通过资源库完成。</p>
<p>有时，值对象需要以实体的身份进行持久化。换句话说，某个值对象实例会单独占据一张表中的某条记录，而该表也是专门为这个值对象类型而设计的，它甚至拥有自己的主键列。当面临「<strong>对象 - 关系阻抗失配</strong>」时，考虑以下几个问题：</p>
<ol>
<li>我当前所建模的概念表示领域中的一个东西呢，还是只是用于描述和度量其他东西？</li>
<li>如果该概念起描述作用，那么它是否满足值对象的几个特征？</li>
<li>将该概念建模成实体是不是只是持久化上的考虑？</li>
<li>将该概念建模成实体是不是因为它拥有唯一标识，我们关注的是对象实例的个体性，并且需要在其整个生命周期中跟踪其变化？</li>
</ol>
<p>我们不应该使持久化机制影响到对值对象的建模。<strong>无论使用什么技术来完成数据建模，数据库实体，主键，引用完整性和索引都不能用来驱动你对领域概念的建模。</strong></p>
<h3 id="单个值对象"><a href="#单个值对象" class="headerlink" title="单个值对象"></a>单个值对象</h3><p>当实体包含单个值对象，值对象的属性需要和包含它的实体保存在一张数据表中时，其列名最好采用与数据库一致的形式，例如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BusinessPriority.Ratings.Benefit</span><br><span class="line">=&gt;</span><br><span class="line">business_priority_ratings_benefit</span><br></pre></td></tr></table></figure></p>
<h3 id="值对象集合序列化到单个列中"><a href="#值对象集合序列化到单个列中" class="headerlink" title="值对象集合序列化到单个列中"></a>值对象集合序列化到单个列中</h3><p>将一个 List 或 Set 的值对象保存在单个列中需要考虑以下问题：</p>
<ul>
<li>列宽：有些对象集合可以包含任意多个元素，但数据库的列宽是有限制的。</li>
<li>查询：如果需要对该集合中的元素进行查询，无法用 SQL 语句实现，但从一个集合中查询一个或多个属性是比较少见的情况。</li>
<li>序列化器和反序列化器：需要自定义类型来实现序列化器和反序列化器，这只是增加了工作量。</li>
</ul>
<h3 id="使用数据库实体保存多个值对象"><a href="#使用数据库实体保存多个值对象" class="headerlink" title="使用数据库实体保存多个值对象"></a>使用数据库实体保存多个值对象</h3><p>我们不能因为某个概念<strong>非常符合数据库实体而将其建模成领域模型中的实体</strong>。有时，是对象 - 关系阻抗失配需要我们采用这种方法，但这绝非 DDD 原则。要实现这种方案，我们可以采用「<strong>层超类型</strong>」，或又名「<strong>委派身份标识(主键)</strong>」。下面的例子使用了两层层超类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public abstract class IdentifiedDomainObject: ISerializable</span><br><span class="line">&#123;</span><br><span class="line">    private long _id = -1;</span><br><span class="line">    protected long Id </span><br><span class="line">    &#123;</span><br><span class="line">        get =&gt; this._id;</span><br><span class="line">        set =&gt; this._id = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来定义另一层层超类型，该层超类型是值对象专属的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public abstract class IdentifiedValueObject: IdentifiedDomainObject</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>虽然 <strong>IdentifiedValueObject</strong> 什么也不做，但它显式地表明了建模意图。<strong>IdentifiedValueObject</strong> 还应该有另外一个专属于实体的抽象子类 <strong>Entity</strong>。现在，每一个值对象类型都可以方便地获得一个隐藏的委派主键，我们可以自由地将其映射成数据库实体，而在领域模型中将其建模成值对象。</p>
<blockquote>
<p>委派标识主要用于数据建模，其没有领域模型含义，这里更多是说明当实体包含值对象集合并且需要对其进行查询时如何对它们进行持久化，这样的值对象在数据库中会有一张单独的表，但这并不代表他们就是领域模型中的实体。</p>
</blockquote>
<h3 id="ORM-与枚举状态对象"><a href="#ORM-与枚举状态对象" class="headerlink" title="ORM 与枚举状态对象"></a>ORM 与枚举状态对象</h3><p>参考 《实现领域驱动设计》 P230</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://berdypango.github.io/ddd-tactical-entity/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Frost He">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FrostHe.Handbook">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/ddd-tactical-entity/" itemprop="url">《实现领域驱动设计》读书笔记(4) - 战术建模之实体</a></h1>
        

        <div class="post-meta">
          
          <span class="post-time">
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  1,746
                </span>
              

              

              
            </div>
          

          
              <div class="post-description">
                  当我们需要考虑一个对象的个性特征，或需要区分不同的对象时，我们引入实体这个领域概念。一个实体是一个唯一的东西，并且可以在相当长的时间内持续地变化
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>系列大纲: <a href="/tags/ddd/">《实现领域驱动设计》读书笔记</a></p>
<p>本文大纲: </p>
<ul>
<li><a href="#%E5%94%AF%E4%B8%80%E6%A0%87%E8%AF%86">唯一标识</a></li>
<li><a href="#%E5%A7%94%E6%B4%BE%E6%A0%87%E8%AF%86">委派标识</a></li>
<li><a href="#%E6%A0%87%E8%AF%86%E7%A8%B3%E5%AE%9A%E6%80%A7">标识稳定性</a></li>
<li><a href="#%E5%AE%9E%E4%BD%93%E5%8F%8A%E5%85%B6%E6%9C%AC%E8%B4%A8%E7%89%B9%E5%BE%81">实体及其本质特征</a><ul>
<li><a href="#%E8%B4%AB%E8%A1%80%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%9E%8B">贫血领域模型</a></li>
<li><a href="#%E5%BC%BA%E7%B1%BB%E5%9E%8B%E5%AE%9E%E4%BD%93%E6%A0%87%E8%AF%86">强类型实体标识</a></li>
<li><a href="#%E6%A8%A1%E5%9E%8B%E6%89%80%E6%89%AE%E6%BC%94%E7%9A%84%E8%A7%92%E8%89%B2">模型所扮演的角色</a></li>
<li><a href="#%E4%B8%8D%E5%8F%98%E6%9D%A1%E4%BB%B6">不变条件</a></li>
<li><a href="#%E9%AA%8C%E8%AF%81">验证</a></li>
<li><a href="#%E8%B7%9F%E8%B8%AA%E5%8F%98%E5%8C%96">跟踪变化</a></li>
</ul>
</li>
</ul>
<p>当我们需要考虑一个对象的个性特征，或需要区分不同的对象时，我们引入实体这个领域概念。一个实体是一个唯一的东西，并且可以在相当长的时间内持续地变化。「<strong>唯一的身份标识</strong>」和「<strong>可变性特征</strong>」将实体和值对象区分开来。</p>
<blockquote>
<p>常年进行 .NET 生态开发的人很容易把实体等同于 <strong>Entity Framework</strong> 中的 <code>Entity</code>，认为 <code>Entity</code> 就是数据库模型的对象映射，然而书中所说的实体完全是不同的概念，是面向业务领域的模型，纯数据模型而不具备任何行为的实体被称作「<strong>贫血领域模型</strong>」</p>
</blockquote>
<h2 id="唯一标识"><a href="#唯一标识" class="headerlink" title="唯一标识"></a>唯一标识</h2><p>以下是常用的创建实体身份标识的策略，从简单到复杂依次为：</p>
<ul>
<li>用户提供一个或多个初始唯一值作为程序输入，程序应该保证这些初始值是唯一的</li>
<li>程序内部通过某种算法自动生成身份标识</li>
<li>程序依赖于持久化存储，比如数据库来生成唯一标识</li>
<li>另一个限界上下文已经决定出了唯一标识，这作为程序的输入，用户可以在一组标识中进行选择</li>
</ul>
<p>聚合根实体对象的唯一标识是全局唯一的，在同一个聚合中，一般实体的唯一标识只要和聚合内的其他实体区分开来即可。</p>
<blockquote>
<p>将唯一标识的生成放在「<strong>资源库(Repository)</strong>」中是一种自然的选择</p>
</blockquote>
<p>从数据库中获取标识比直接从应用程序中生成标识要慢得多，一种解决方法是将数据库序列缓存在应用程序中，比如缓存在资源库中。</p>
<blockquote>
<p>有时，标识的生成和赋值时间对于实体来说是重要的，及早标识生成和赋值发生在持久化实体之前。延迟标识生成和赋值发生在持久化实体的时候</p>
</blockquote>
<h2 id="委派标识"><a href="#委派标识" class="headerlink" title="委派标识"></a>委派标识</h2><p>有些 <code>ORM</code> 工具通过自己的方式来处理对象的身份标识，如果我们自己的领域需要另外一种实体标识，此时两者将产生冲突。为了解决这个问题，需要使用两种标识，一种为领域所用，一种为 <code>ORM</code> 所用，在 <code>Hibernate</code> 中，被称为委派标识。委派标识与领域中的实体标识没有任何关系，委派标识只是为了迎合 <code>ORM</code> 创建的。</p>
<h2 id="标识稳定性"><a href="#标识稳定性" class="headerlink" title="标识稳定性"></a>标识稳定性</h2><p>在多数情况下，我们都不应该修改实体的唯一标识，这样可以在实体的整个生命周期中保持标识的稳定性。</p>
<h2 id="实体及其本质特征"><a href="#实体及其本质特征" class="headerlink" title="实体及其本质特征"></a>实体及其本质特征</h2><h3 id="贫血领域模型"><a href="#贫血领域模型" class="headerlink" title="贫血领域模型"></a>贫血领域模型</h3><p>过多拥有 <code>getter</code> 和 <code>setter</code> 方法而缺乏行为的模式可以概括为贫血领域模型。</p>
<h3 id="强类型实体标识"><a href="#强类型实体标识" class="headerlink" title="强类型实体标识"></a>强类型实体标识</h3><p>标识需要有特殊的类型还是可以使用简单的字符串？实体的唯一标识会用在很多地方，它可以用在不同限界上下文的所有实体上。在这种情况下，使用一个强类型的实体标识可以保证所有订阅方所持有的实体都能使用正确的标识。</p>
<blockquote>
<p>这里所说的实体标识更多是指聚合根的实体标识？</p>
</blockquote>
<h3 id="模型所扮演的角色"><a href="#模型所扮演的角色" class="headerlink" title="模型所扮演的角色"></a>模型所扮演的角色</h3><p>在面向对象编程中，通常由接口来定义实现类的角色，在正确的设计情况下，一个类对于每一个它所实现的接口都存在一种角色。如果一个类没有显式的角色 - 即该类没有实现任何接口，那么默认情况下它扮演的即是本类的角色，也即，该类的公有方法表示该类的隐式接口。</p>
<h3 id="不变条件"><a href="#不变条件" class="headerlink" title="不变条件"></a>不变条件</h3><p>不变条件是在整个实体生命周期中都必须保持事务一致性的一种状态，有时一个实体维护了一个或多个不变条件。如果实体的不变条件要求该实体所包含的所有对象都不能为 null，那么这些状态需要作为参数传递给构造函数，并且在相应的 <code>setter</code> 方法中对新值进行非 <code>null</code> 检查来确保一致性。</p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><blockquote>
<p><strong>自封装</strong>：无论从何处访问对象的状态，即使从对象内部访问数据，都必须通过 <code>getter</code> 和 <code>setter</code> 方法实现。</p>
</blockquote>
<p>自封装首先为对象的实例变量和类变量提供了一层抽象。其次，我们可以方便地在对象中访问其所引用对象的属性。重要的是，自封装使验证变得非常简单。</p>
<p>验证的主要目的在于检查模型的正确性，我们将对模型进行三个级别的验证：</p>
<ul>
<li>验证属性: 通过自封装的方式在 <code>setter</code> 方法中对属性进行验证</li>
<li>验证整体对象: 为了实现对整体对象的验证，可创建 <code>Entity</code> 层超类型，在其中定义 <code>Validate</code> 虚方法，实现类通过重写该方法按需调用验证逻辑，同时，由于验证逻辑的变化速度比实体本身还要快，所以应该将真正的验证逻辑委托给专门的验证类，实体在其 <code>Validate</code> 方法中使用这些验证类，从而使验证逻辑与实体解耦。</li>
<li>验证组合对象: 关注点从单个实体是否合法转向多个实体的是组合是否全部合法，包括一个或多个聚合实例。最好的方式是把这样的验证过程创建成一个领域服务，该领域服务通过资源库读取需要验证的聚合实例，然后对每个实例进行验证，可以是单独验证，也可以和其他聚合实例一起验证。</li>
</ul>
<h3 id="跟踪变化"><a href="#跟踪变化" class="headerlink" title="跟踪变化"></a>跟踪变化</h3><p>领域专家可能会关心发生在模型中的一些重要事件，此时就需要对实体的一些特殊变化进行跟踪了。跟踪变化最实用的方法是「<strong>领域事件</strong>」和「<strong>事件存储</strong>」。可以为领域专家所关心的所有状态改变都创建单独的事件类型，事件的名字和属性表明发生了什么样的事件。当命令操作执行完后，系统发出这些领域事件，订阅方接收发生在模型上的所有事件。接收到事件后，订阅方将事件保存在事件存储中。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://berdypango.github.io/ddd-strategic-archietecture/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Frost He">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FrostHe.Handbook">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/ddd-strategic-archietecture/" itemprop="url">《实现领域驱动设计》读书笔记(3) - 战略建模之架构</a></h1>
        

        <div class="post-meta">
          
          <span class="post-time">
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  5,462
                </span>
              

              

              
            </div>
          

          
              <div class="post-description">
                  从传统分层架构到六边形架构，再到以六边形架构为基础扩展出的其他架构形态。架构只是实现领域驱动设计的建模工具，
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>系列大纲: <a href="/tags/ddd/">《实现领域驱动设计》读书笔记</a></p>
<p>本文大纲:</p>
<ul>
<li><a href="#%E5%88%86%E5%B1%82%E6%9E%B6%E6%9E%84">分层架构</a></li>
<li><a href="#%E5%85%AD%E8%BE%B9%E5%BD%A2%E6%9E%B6%E6%9E%84%E7%AB%AF%E5%8F%A3%E4%B8%8E%E9%80%82%E9%85%8D%E5%99%A8%E6%9E%B6%E6%9E%84%E6%B4%8B%E8%91%B1%E6%9E%B6%E6%9E%84">六边形架构(端口与适配器架构，洋葱架构)</a><ul>
<li><a href="#%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99">依赖倒置原则</a></li>
</ul>
</li>
<li><a href="#%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84service-oriented-architecture-soa">面向服务架构(Service-Oriented Architecture, SOA)</a></li>
<li><a href="#restrepresentational-state-transfer">REST(Representational State Transfer)</a><ul>
<li><a href="#restful-http-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E5%85%B3%E9%94%AE%E6%96%B9%E9%9D%A2">RESTful HTTP 服务端的关键方面</a></li>
<li><a href="#rest-%E5%92%8C-ddd">REST 和 DDD</a></li>
</ul>
</li>
<li><a href="#%E5%91%BD%E4%BB%A4%E4%B8%8E%E6%9F%A5%E8%AF%A2%E8%81%8C%E8%B4%A3%E5%88%86%E7%A6%BB---cqrs">命令与查询职责分离 - CQRS</a><ul>
<li><a href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86%E5%99%A8">客户端和查询处理器</a></li>
<li><a href="#%E6%9F%A5%E8%AF%A2%E6%A8%A1%E5%9E%8B">查询模型</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%9E%B6%E6%9E%84">事件驱动架构</a><ul>
<li><a href="#%E7%AE%A1%E9%81%93%E5%92%8C%E8%BF%87%E6%BB%A4%E5%99%A8">管道和过滤器</a></li>
<li><a href="#%E9%95%BF%E6%97%B6%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8Bsaga">长时处理过程(Saga)</a></li>
<li><a href="#%E4%BA%8B%E4%BB%B6%E6%BA%90eventsource">事件源(EventSource)</a></li>
</ul>
</li>
<li><a href="#%E6%95%B0%E6%8D%AE%E7%BD%91%E7%BB%87%E5%92%8C%E5%9F%BA%E4%BA%8E%E7%BD%91%E6%A0%BC%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97">数据网织和基于网格的分布式计算</a></li>
</ul>
<h1 id="分层架构"><a href="#分层架构" class="headerlink" title="分层架构"></a>分层架构</h1><p>分层架构的一个重要原则是: 每层只能与位于其下方的层发生耦合。<strong>「严格分层架构」</strong>只允许某层与直接位于其下方的层发生偶尔，而<strong>「松散分层架构」</strong>则允许任意上方层与任意下方层发生耦合。由于<strong>「用户界面层」</strong>和<strong>「应用服务层」</strong>经常需要与基础设施打交道，许多系统都是基于<strong>「松散分层架构」</strong>的。</p>
<p>在分层架构中，领域的核心域通常只位于架构的其中一层，<strong>「用户界面层」</strong>和<strong>「应用服务层」</strong>均位于其上。</p>
<blockquote>
<p>根据笔者的理解，用户界面层对应所有对系统产生消费行为的客户端，可能是人也可能是其他系统，用户界面是应用层的直接消费方。</p>
</blockquote>
<p>有人认为既然用户界面需要对用户输入进行验证，那么它就应该包含业务逻辑。事实上，<strong>用户界面进行的验证和领域模型的验证是不同的</strong>，在用户界面中使用的只是数据的渲染和展现，而领域模型的验证的关注点却跟一致性有关，此时可以使用展现模型将用户界面与领域模型解耦。</p>
<blockquote>
<p><strong>「应用服务」</strong>位于应用层中，<strong>「应用服务」</strong>和<strong>「领域服务」</strong>的职责是不同的，后续的文章专门针对两者进行了讨论。</p>
</blockquote>
<p>领域逻辑不应该出现在应用服务中，应用服务可以用于控制持久化事务和安全认证，或者向其他系统发送基于事件的消息通知，另外还可以用于创建邮件以发送给用户。<strong>应用服务本身并不处理业务逻辑，但它是领域模型的直接消费者，它主要用于协调领域对象的操作，应用服务是很轻量的</strong>。比如<strong>聚合</strong>。同时，应用服务是表达用例和用户故事的主要手段。因此，应用服务通常的用途是: 接收来自用户界面的输入参数，再通过资源库获取到<strong>聚合</strong>实例，然后执行相应的操作，例如:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Transactional</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CommitBacklogItemToSprint</span>(<span class="params"><span class="keyword">string</span> tenantId, <span class="keyword">string</span> backlogItemId, <span class="keyword">string</span> sprintId</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// construct wanted id objects.</span></span><br><span class="line">    <span class="keyword">var</span> tenantId = <span class="keyword">new</span> TenantId(tenantId);</span><br><span class="line">    <span class="keyword">var</span> backlogItemId = <span class="keyword">new</span> BacklogItemId(backlogItemId);</span><br><span class="line">    <span class="comment">// get backlogItem object from repository.</span></span><br><span class="line">    <span class="keyword">var</span> backlogItem = backlogItemRepository.BacklogItemOfId(tenantId, backlogItemId);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> sprintId = <span class="keyword">new</span> SprintId(sprintId);</span><br><span class="line">    <span class="keyword">var</span> sprint = sprintRepository.SprintOfId(tenantId, sprintId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// call the commit method from backlogItem.</span></span><br><span class="line">    backlogItem.CommitTo(sprint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>上述代码很好的诠释了前文提及的关于应用服务<strong>「协调领域对象的操作」</strong>的功能</p>
</blockquote>
<p>如果应用服务比上述功能复杂许多，这通常意味着领域逻辑已经泄露到应用服务中了，此时的领域模型将变成<strong>「贫血领域模型」</strong>。因此，最佳实践是将应用服务做成很薄的一层。</p>
<h1 id="六边形架构-端口与适配器架构，洋葱架构"><a href="#六边形架构-端口与适配器架构，洋葱架构" class="headerlink" title="六边形架构(端口与适配器架构，洋葱架构)"></a>六边形架构(端口与适配器架构，洋葱架构)</h1><h2 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h2><ul>
<li>高层模块不应该依赖于低层模块，两者都应该依赖于抽象</li>
<li>抽象不应该依赖于细节，细节应该依赖于抽象。</li>
</ul>
<p>当传统的分层架构引入了依赖倒置原则，会发现已经不存在分层的概念了，无论是高层还是低层都依赖于抽象，好像把整个分层架构推平了。在六边形架构中，不同的消费者通过<strong>「对等」</strong>的方式与系统交互，当需要新增消费者时，只需添加一个新的适配器将客户输入转化成能被系统 API 所理解的参数就行了。同时，系统输出，例如<strong>「图形界面」</strong>，<strong>「持久化」</strong>和<strong>「消息」</strong>等都可以通过不同方式实现，并且是可替换的，对于每种特定的输出，都有一个新的适配器负责完成相应的转化功能。</p>
<p>六边形架构提倡用<strong>「内部区域」</strong>和<strong>「外部区域」</strong>来看待整个系统，在外部区域中，不同的客户代码提交输入，内部系统用于获取持久化数据，并对程序输出进行存储，或在中途将输出转发到另外的地方(比如消息)。</p>
<blockquote>
<p>依据笔者理解，端口和适配器的意思是，将系统想象成一般的计算机，HTTP 协议和 AMPQ 协议以及用户界面可看作不同的端口，而适配器则负责将来自这些协议的数据转化成系统 API 能够理解的数据。</p>
</blockquote>
<p>在使用六边形架构时，我们应该根据用例来设计应用程序，而不是根据需要支持的客户数目来设计。任何客户都可能向不同的端口发出请求，但是所有的适配器都将使用相同的 API。</p>
<p>应用程序位于六边形架构的<strong>「内部区域」</strong>，公共 API 通过<strong>「应用服务」</strong>暴露给外部区域，而如前文所述，应用服务是领域模型的直接消费者，所有的输入都将委派给内部的领域对象。</p>
<p>我们可以将资源库的实现看作是持久化适配器，该适配器用于访问先前存储的聚合实例，或者保存新的实例，我们可以通过不同的方式实现资源库，如关系型数据库，文档型数据库以及内存数据库，他们分别对应着不同的适配器，但服务于同一种端口——<strong>持久化</strong>，即同一个端口可以有多种适配器。</p>
<img src="/ddd-strategic-archietecture/port&adapter.png" title="六边形架构">
<p>六边形架构的好处在于易于测试，整个应用程序和领域模型可以在没有客户和存储机制的条件下进行设计开发。基于六边形架构，可以扩展为 SOA，REST，事件驱动架构，CQRS 架构或者数据网织或基于网格的分布式缓存，还有可能 Map-Reduce 这种分布式并行处理方式。</p>
<h1 id="面向服务架构-Service-Oriented-Architecture-SOA"><a href="#面向服务架构-Service-Oriented-Architecture-SOA" class="headerlink" title="面向服务架构(Service-Oriented Architecture, SOA)"></a>面向服务架构(Service-Oriented Architecture, SOA)</h1><p>服务的设计原则如下: </p>
<ul>
<li>服务契约: 通过契约文档，服务阐述自身的目的与功能</li>
<li>松耦合: 服务将依赖关系最小化</li>
<li>服务抽象: 服务只发布契约，而向消费方隐藏内部逻辑</li>
<li>服务重用性: 一种服务可以被其他服务重用</li>
<li>服务自治性: 服务自行控制环境与资源以保持独立性，这有助于保持服务的一致性和可靠性</li>
<li>服务无状态性: 服务负责消费者的状态管理，但不能与服务的自治性发生冲突</li>
<li>服务可发现性: 消费方可以通过服务元数据来查找服务和理解服务</li>
<li>服务组合性: 一种服务可以由其他服务组合而成，而不管其他服务的大小和复杂性如何</li>
</ul>
<p>这些原则可以与六边形架构结合起来，此时服务边界位于最左侧，而领域模型位于中心位置，消费方可以通过 REST，SOAP 和消息机制获取服务。</p>
<img src="/ddd-strategic-archietecture/SOA.png" title="支持 SOA 的六边形架构">
<p>业务服务可以由任意数量的技术服务来提供，技术服务可以是 REST 资源，SOAP 接口或消息类型。业务服务强调业务战略，即如何对业务和技术进行整合。</p>
<h1 id="REST-Representational-State-Transfer"><a href="#REST-Representational-State-Transfer" class="headerlink" title="REST(Representational State Transfer)"></a>REST(Representational State Transfer)</h1><p>REST 既不是使用 HTTP 直接发送 XML/JSON，也不是将 URI 的查询参数传递给方法。<strong>REST 是一种架构风格</strong>，架构风格之于架构就像设计模式之于设计一样，它将不同架构实现共有的东西抽象出来，使得我们在谈论架构时不至于陷入技术细节中。分布式系统架构存在多种架构风格，包括<strong>客户端-服务器</strong>架构风格和<strong>分布式对象(例如远程过程调用)</strong>风格。REST 是 Web 架构的一种架构风格，和其他技术一样，我们可以通过不同的方式来使用 Web 协议，有些使用方式符合设计者的初衷，而有些则不然。例如，你可以使用关系型数据库管理系统(RDBMS)创建表，列，外键关联，视图和约束等，你也可以只创建一张包含两列的表，一列表示‘键’，一列表示‘值’，然后将序列化之后的对象保存在值列中。此时，你依然在使用 RDBMS，但你却使用不到多少 RDBMS 的功能，如查询，组合，排列和分组等。</p>
<p>同理，Web 协议既可以按照它的设计初衷为人所用——此时便是一种遵循 REST 架构风格的方式——也可以通过一种不遵循其设计初衷的方式为人所用。因此，当我们没有足够充分的理由使用 REST 风格的 HTTP 所带来的好处时，采用另一种分布式系统架构可能是合适的，就像在保存拥有唯一键的数值时，NoSQL 键值对存储方式是一种更好的选择一样。</p>
<h2 id="RESTful-HTTP-服务端的关键方面"><a href="#RESTful-HTTP-服务端的关键方面" class="headerlink" title="RESTful HTTP 服务端的关键方面"></a>RESTful HTTP 服务端的关键方面</h2><p><strong>「资源」</strong>是关键的概念，系统的设计者将决定哪些有意义的<strong>「东西」</strong>可以暴露给外界，并且给这些<strong>「东西」</strong>一个唯一的身份标识。通常来说，每种资源都拥有一个 URI，每个 URI 都需要指向某个资源。</p>
<p>另一个关键方面是<strong>「无状态通信」</strong>，消息是自描述的，例如，HTTP 请求本身便包含了服务端所需要的全部信息，服务端可以使用其本身的状态来辅助通信，重要的是: <strong>我们不能依靠请求本身来创建一个隐式上下文环境(会话)</strong>。无状态通信保证了不同请求之间的相互独立性，这在很大程度上提高了系统的可伸缩性。</p>
<p>如果将资源看作对象，那么每一个对象都支持相同的接口，可以调用的方法是一个固定的集合，它们全都可以用 HTTP 动作表示，其中最重要的有 <code>GET</code>，<code>PUT</code>，<code>POST</code> 和 <code>DELETE</code>。这也是将 REST 与其他架构风格区别开来的关键。虽然乍一看这些方法将会转化成 <strong>CRUD</strong> 操作，但通常我们所创建的资源并不表示任何持久化实体，而是封装了某种行为，当调用 HTTP 动词对应的操作时，实际上是在调用这些行为。</p>
<blockquote>
<p>依据笔者理解，对象化的资源并不代表任何领域模型中的实体，而是根据某一项业务操作抽象出来的资源块，其中包括用以展示的数据和具有一致性边界的行为。</p>
</blockquote>
<p>在 HTTP 规范中，每种 HTTP 方法都有一个明确的定义，比如 <code>GET</code> 方法只能用于<strong>「安全」</strong>的操作: </p>
<ul>
<li>它可能完成一些客户并没有要求的动作行为</li>
<li>它总是读取数据</li>
<li>它可能被缓存起来</li>
</ul>
<p>最后，通过使用 HATEOAS(Hypermedia as Engine of Application State)，REST 服务的消费方可以沿着某种路径发现应用程序可能的状态变化。简单来讲，就是单个资源并不独立存在，不同资源是相互链接在一起的，对于服务器来说，这意味着在返回中包含对其他资源的链接，由此消费方便可通过这些链接访问到相应的资源。</p>
<h2 id="REST-和-DDD"><a href="#REST-和-DDD" class="headerlink" title="REST 和 DDD"></a>REST 和 DDD</h2><p>不建议将领域模型直接暴露给外界，这样会使系统接口变得非常脆弱，领域模型的任何改变都会导致系统接口的改变。要将 DDD 与 RESTful HTTP 合并起来使用，我们有两种方式。</p>
<p>第一种方法是为系统接口层单独创建一个限界上下文，再在此上下文中通过适当的策略来访问核心模型，这是一种经典的方法，它将系统接口看作一个整体，通过资源抽象将系统功能暴露给外界，而不是通过服务或远程接口。这种方法让核心域和系统接口之间完成了解耦。</p>
<p>另一种方法用于需要使用标准媒体类型的时候。如果某种媒体类型并不用于支持单个系统接口，而是用于一组相似的客户端-服务器交互场景，此时可以创建一个领域模型来处理每一种媒体类型。这种方法本质上为 DDD 中的共享内核或发布语言。</p>
<blockquote>
<p>这里提到的媒体类型表示 MIME type。</p>
</blockquote>
<p>通常来讲，添加新资源并在已有资源中创建到新资源的链接是非常简单的，要添加新的格式也同样如此。另外，基于 REST 的系统也是非常容易理解，系统被分为很多较小的资源块，每一个资源块都可以独立测试和调试。HTTP 设计本身以及 URI 成熟的重写与缓存机制使得 RESTful HTTP 成为一种不错的架构选择，该架构具有很好的松耦合性和可伸缩性。</p>
<h1 id="命令与查询职责分离-CQRS"><a href="#命令与查询职责分离-CQRS" class="headerlink" title="命令与查询职责分离 - CQRS"></a>命令与查询职责分离 - CQRS</h1><p>从<strong>「资源库」</strong>中查询所有需要显示的数据是困难的，特别是在需要显示来自不同聚合类型与实例的数据时，领域越复杂，这种困难越大。一种被软件系统广泛采用的做法是使用<strong>「数据传输对象(Data Transfer Object, DTO)」</strong>，即从不同的资源库中获取聚合实例，然后再将它们组装成 DTO。</p>
<p>然而，查询这些数据所带来的性能消耗可能会随着数据量增大而显著降低，另外一种办法是使用 <strong>「CQRS(Command-Query Responsibility Segregation)」</strong>。CQRS 是将紧缩(Stringent)对象(或组件)设计原则和命令-查询分离(CQS)应用在架构模式中的结果。</p>
<blockquote><p>一个方法要么是执行某种动作命令，要么是返回数据的查询，而不能两者皆是。换句话说，问题不应该对答案进行修改。一个方法只有在具有参考透明性的时候才能返回数据，此时该方法不会产生副作用。</p>
<footer><strong>[Bertrand Meyer]</strong></footer></blockquote>
<p>在对象层面，这意味着:</p>
<ul>
<li>如果一个方法修改了对象的状态，该方法便是一个命令(Command)，它不应该返回数据，在 Java 和 C# 中，这样的方法应该声明为 void</li>
<li>如果一个方法返回了数据，该方法便是一个查询(Query)，此时它不应该通过直接或间接的手段修改对象的状态，在 Java 或 C# 中，这样的方法应该以其返回的数据类型进行声明</li>
</ul>
<p>在领域模型中，我们通常会看到同时包含命令和查询的聚合，也经常在资源库中看到不同的查询方法，这些方法对对象属性进行过滤。但在 CQRS 中，我们忽略这些常态的情形，而是通过另一种方式来查询用于显示的数据。</p>
<p>假设，一个聚合不再有查询方法，只有命令方法，资源库也将变成只有 <code>Add()</code> 或 <code>Save()</code> 方法(分别支持创建和更新操作)，同时只有一个查询方法，如 <code>FromId()</code>，这个唯一的查询方法以聚合 ID 作为参数，然后返回该聚合实例。资源库不能使用其他方法来查询聚合，比如对属性进行过滤等。在将所有查询方法移除之后，我们将此时的模型称为<strong>「命令模型(Command Model)」</strong>，但我们仍然需要向用户显示数据，为此我们将创建第二个模型，该模型专门用于优化查询，称之为<strong>「查询模型(Query Model)」</strong>。</p>
<blockquote>
<p>你可能会认为: 这种架构风格需要大量的额外工作，我们解决了一些问题，同时带来了另外的问题，而且我们需要编写更多的代码。但无论如何，不要急于否定这种架构，在某些情况下，新增的复杂性是合理的。</p>
</blockquote>
<p>因此，领域模型被一分为二，最终得到如下图所示的系统组件:</p>
<h2 id="客户端和查询处理器"><a href="#客户端和查询处理器" class="headerlink" title="客户端和查询处理器"></a>客户端和查询处理器</h2><p>客户端可以是 Web 浏览器，也可以是桌面应用程序，它们将使用运行在服务器端的一组查询处理器。查询处理器表示一个只知道如何向数据库执行基本查询并将查询结果以某种格式返回的简单组件。</p>
<h2 id="查询模型"><a href="#查询模型" class="headerlink" title="查询模型"></a>查询模型</h2><p>查询模型是一种非规范化数据模型，它并不反映领域行为，只是用于数据显示。如果数据模型是 SQL 数据库，那么每个数据库表视图便是一种数据显示视图，它可以包含很多列，甚至是所有数据的超集，表视图可以通过多张表进行创建，此时每张表代表整个显示数据的一个逻辑子集。</p>
<p>todo..</p>
<h1 id="事件驱动架构"><a href="#事件驱动架构" class="headerlink" title="事件驱动架构"></a>事件驱动架构</h1><p>事件驱动架构不见得必须与六边形架构一同使用，但引入六边形架构有助于理解事件驱动架构。</p>
<h2 id="管道和过滤器"><a href="#管道和过滤器" class="headerlink" title="管道和过滤器"></a>管道和过滤器</h2><p>考虑以下地 shell 命令，它便是一种最简单的管道和过滤器:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat phone_numbers.txt | grep 303 | wc -l</span><br></pre></td></tr></table></figure></p>
<p>这行 Linux 命令用于在 phone_numbers.txt 文件中统计含有电话区号 “303” 的所有文本行的数量:</p>
<ol>
<li>cat 命令向标准输出流输出 phone_numbers.txt 文件中的内容。通常来说，标准输出流与终端相连，但其后连接了 “|” 符号，输出会通过管道转向下一个命令工具。</li>
<li>grep 命令从标准输出流中读取数据，即从 cat 命令输出的内容，并匹配含有 “303” 的所有行，并将查找到的结果通过管道转向下一个命令工具。</li>
<li>最后，wc 命令读取标准输出流，即 grep 命令的输出结果，其参数 <code>-l</code> 表示统计所读行的数量。由于在 wc 命令之后没有另外的管道了，此时的输出直接显示在终端。</li>
</ol>
<p>每个工具都接收一个数据集，对其进行处理，再输出另一个数据集，每一个命令都充当着过滤器的作用。在整个过滤过程完成之后，输入数据和输出数据可能完全不一样了，本例中，原始输入数据是一个文本文件，最终输出的只有一个数字 “3”。</p>
<p>领域模型中发布领域事件的组件便可类比这里的过滤器，而领域事件则可类比为管道。</p>
<h2 id="长时处理过程-Saga"><a href="#长时处理过程-Saga" class="headerlink" title="长时处理过程(Saga)"></a>长时处理过程(Saga)</h2><p>todo..</p>
<h2 id="事件源-EventSource"><a href="#事件源-EventSource" class="headerlink" title="事件源(EventSource)"></a>事件源(EventSource)</h2><p>事件源是指: 对于某个聚合上的每次命令操作，都有至少一个领域事件发布出去，该领域事件描述了操作的执行结果。每一个领域事件都将被保存到<strong>「事件存储」</strong>中，每次从资源库中获取某个聚合时，我们将根据发生在该聚合上的历史事件来重建该聚合实例，事件的作用顺序与它们的产生顺序相同。</p>
<p>随着时间推移，发生在聚合实例上的事件越来越多，那么，重放这些成百上千的事件会对那些操作繁忙的模型造成影响，为了避免这种瓶颈，我们可以通过聚合状态<strong>「快照」</strong>的方式来进行优化。可以创建一个聚合内存状态的快照，此时的快照反应了聚合在事件存储历史中某个事件发生后的状态。为了达到这样的目的，我们需要利用该事件及其发生前的所有事件来重建聚合实例，之后对聚合状态进行序列化，再把序列化之后的快照保存在事件存储中。这样，便可通过聚合快照来实例化某个聚合，接着再重放比快照更新的事件来修改聚合的状态，直至读取时发生在聚合上的最后一个事件。</p>
<p>创建快照所需的前置事件数量临界值可以由团队确立，例如，发现某个聚合在接收到 50 个事件之后为其创建快照可以获得最佳性能，那么 50 就是其临界值。</p>
<p>事件通常以二进制的方式保存在事件存储中，这使得事件源不能用于查询操作。事实上，为事件源所设计的资源库只有一个接受聚合 ID 的查询方法，因此需要另外的方法来支持查询，通常将 CQRS 和事件源一同使用。</p>
<h1 id="数据网织和基于网格的分布式计算"><a href="#数据网织和基于网格的分布式计算" class="headerlink" title="数据网织和基于网格的分布式计算"></a>数据网织和基于网格的分布式计算</h1><p>todo..</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://berdypango.github.io/ddd-strategic/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Frost He">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FrostHe.Handbook">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/ddd-strategic/" itemprop="url">《实现领域驱动设计》读书笔记(2) - 战略建模</a></h1>
        

        <div class="post-meta">
          
          <span class="post-time">
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  3,553
                </span>
              

              

              
            </div>
          

          
              <div class="post-description">
                  战略建模从高层视角为软件的各个子系统确定统一的术语模型，确定上下文边界，选择适当的架构，并在不同上下文之间引入集成策略。
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>系列大纲: <a href="/tags/ddd/">《实现领域驱动设计》读书笔记</a></p>
<p>本文大纲:</p>
<ul>
<li><a href="#%E9%80%9A%E7%94%A8%E8%AF%AD%E8%A8%80ubiquitous-language">通用语言(Ubiquitous Language)</a></li>
<li><a href="#%E9%A2%86%E5%9F%9F%E5%92%8C%E5%AD%90%E5%9F%9F">领域和子域</a><ul>
<li><a href="#%E6%A0%B8%E5%BF%83%E5%9F%9F">核心域</a></li>
<li><a href="#%E6%94%AF%E6%92%91%E5%AD%90%E5%9F%9F">支撑子域</a></li>
<li><a href="#%E9%80%9A%E7%94%A8%E5%AD%90%E5%9F%9F">通用子域</a></li>
<li><a href="#%E9%97%AE%E9%A2%98%E7%A9%BA%E9%97%B4problem-space%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E7%A9%BA%E9%97%B4solution-space">问题空间(Problem Space)和解决方案空间(Solution Space)</a></li>
</ul>
</li>
<li><a href="#%E9%99%90%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87bounded-context">限界上下文(Bounded Context)</a></li>
<li><a href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E6%98%A0%E5%B0%84%E5%9B%BE">上下文映射图</a></li>
</ul>
<h1 id="通用语言-Ubiquitous-Language"><a href="#通用语言-Ubiquitous-Language" class="headerlink" title="通用语言(Ubiquitous Language)"></a>通用语言(Ubiquitous Language)</h1><p>通用语言是团队成员间能够互相理解的语言，它统一了开发团队和领域专家之间的术语，从而提高了沟通效率。通用语言不同于「<strong>统一建模语言(UML, Unified Modelling Language)</strong>」，<code>UML</code> 是开发人员之间的语言。</p>
<hr>
<p>通用语言的几点注意：</p>
<ul>
<li>限界上下文和通用语言存在一对一的关系</li>
<li>只有当团队工作在独立的限界上下文中时，通用语言才是 “通用”的</li>
<li>虽然我们只工作在一个限界上下文中，但我们可能经常会与其他限界上下文打交道，这时可以通过上下文映射图来对这些限界上下文进行集成，每个限界上下文都有自己的通用语言，而有时语言间的术语可能有重叠的部分</li>
</ul>
<h1 id="领域和子域"><a href="#领域和子域" class="headerlink" title="领域和子域"></a>领域和子域</h1><p>在 DDD 中，一个领域可能包含多个限界上下文，通常一个限界上下文对应一个子域。“领域”一词承载了太多含义，领域既可以表示整个业务系统，也可以表示其中的某个核心域或支撑子域，一个模型在一个子域应该表达出清晰的含义。</p>
<p>例如，在一个电子商务系统中，至少要向买家展示不同类别的产品，允许买家下单和付款，还需要安排物流。这个特定的领域可以划分为「<strong>产品目录(Product Catalog)</strong>」，「<strong>订单(Order)</strong>」，「<strong>发票(Invoicing)</strong>」和「<strong>物流(Shipping)</strong>」。子域不一定会很大，可以简单到只包含一套算法，这套算法对业务系统来说可能非常重要，但并不包含在核心域之中。在正确实施 DDD 的情况下，这种简单的子域可以以「<strong>模块(Module)</strong>」的形式从核心域中分离出来。</p>
<h2 id="核心域"><a href="#核心域" class="headerlink" title="核心域"></a>核心域</h2><p>通常代表了促进业务成功的核心功能，核心域应该配备最好的领域专家和开发团队。</p>
<h2 id="支撑子域"><a href="#支撑子域" class="headerlink" title="支撑子域"></a>支撑子域</h2><p>如果一个限界上下文对应着业务的某些重要方面，但却不是核心，那么它便是一个「<strong>支撑子域</strong>」。</p>
<h2 id="通用子域"><a href="#通用子域" class="headerlink" title="通用子域"></a>通用子域</h2><p>如果一个子域被用于整个业务系统，那么这个子域便是「<strong>通用子域</strong>」。例如在众多系统中都有的「<strong>认证与授权子系统</strong>」通常就是一个通用子域。</p>
<h2 id="问题空间-Problem-Space-和解决方案空间-Solution-Space"><a href="#问题空间-Problem-Space-和解决方案空间-Solution-Space" class="headerlink" title="问题空间(Problem Space)和解决方案空间(Solution Space)"></a>问题空间(Problem Space)和解决方案空间(Solution Space)</h2><ul>
<li>问题空间是领域的一部分，对问题空间的开发将产生一个新的核心域，对问题空间的评估应该同时考虑已有子域和额外所需子域。因此，问题空间是核心域和其他子域的组合。</li>
<li>解决方案空间包括一个或多个限界上下文，因为限界上下文即是一个特定的解决方案。</li>
</ul>
<hr>
<p>在我们实施某个解决方案之前，我们需要对问题空间和解决方案空间进行评估，首先回答以下问题：</p>
<ul>
<li>这个战略核心域的名字是什么？</li>
<li>它的目标是什么？</li>
<li>它包含哪些概念？</li>
<li>它的支撑子域和通用子域是什么？</li>
<li>如何安排项目人员？</li>
<li>你能组建一支合适的团队吗？</li>
</ul>
<p>解决方案空间在很大程度上受到现有系统和技术的影响。我们应该根据限界上下文仔细考虑以下问题：</p>
<ul>
<li>有哪些软件资产是已经存在的，它们可以重用吗？</li>
<li>哪些资产是需要创建的，或者从别处获得？</li>
<li>这些资产是如何集成在一起的？</li>
<li>还需要什么样的集成？</li>
<li>假设已经有了现有资产和那些需要被创建的资产，我们还需要做些什么？</li>
<li>核心域和那些支撑项目的成功几率如何？会不会出现由于其中一个失败而导致整个项目失败的可能？</li>
<li>有哪些地方我们使用了完全不同的术语？</li>
<li>限界上下文之间在哪些地方存在概念重叠？</li>
<li>这些重叠的概念在不同的限界上下文之间是如何映射和翻译的？</li>
<li>哪些限界上下文包含了核心域中的概念，其中使用了哪些战术建模工具？</li>
</ul>
<h1 id="限界上下文-Bounded-Context"><a href="#限界上下文-Bounded-Context" class="headerlink" title="限界上下文(Bounded Context)"></a>限界上下文(Bounded Context)</h1><p>限界上下文采用 <em>模型+上下文</em> 的形式来命名。</p>
<p>同一个概念在不同的限界上下文中的关注点是不一样的，例如在一个电子商务系统中，”顾客” 这个概念在订单系统上下文中，其关注点有先前购买情况，忠诚度，可买产品，折扣和物流方式，而在下单时，”顾客” 的上下文包括名字，产品寄送地址，订单总价和一些付款术语。所以 “顾客” 在这个例子中并没有一个清晰的含义。类似的问题其实是脱离了不同限界上下文中协作概念的关注点，在不同的限界上下文中，”顾客” 扮演了不同的协作概念，例如在产品目录上下文中，”顾客” 可以用 “浏览者” 表示，而在订单上下文中，”顾客” 以 “购买者” 表示。”顾客” 一词本身包含了太多可能的角色，不同的角色有不同的职责。在不同的限界上下文中，不同角色充当了 “顾客” 的某种角色，进而使得单一限界上下文该角色的含义清晰，并与其他限界上下文的关注点得以分离。</p>
<p>限界上下文是一个显式的语义边界，领域模型便存在于这个边界之内。领域模型把通用语言表达成软件模型，创建边界的原因在于，每一个模型概念，包括它的属性和行为，在边界之内都具有特殊的含义。限界上下文并不旨在创建单一的项目资产，它并不是一个单独的<strong>组件</strong>，<strong>文档</strong>或者<strong>框图</strong>。因此，它并不是一个 <code>jar</code> 或者 <code>dll</code>，但这些可以用来表示限界上下文。</p>
<p>在上下文边界之外，我们通常不会使用该上下文之内的对象实例，但是不同上下文中彼此关联的对象可能共享一些状态。</p>
<p>一个限界上下文并不是只包含领域模型。模型自然是限界上下文的一等公民，但它并不局限于此。它通常标定了一个系统，一个应用程序或者一个业务服务。有时一个限界上下文包含的内容可能比较少，例如，一个通用子域可能只包含领域模型。</p>
<p>当模型驱动着数据库 Schema 的设计时，<strong>数据库 Schema 也应该位于该模型所处的上下文边界之内</strong>。因为数据库 Schema 是由建模团队设计，开发并维护的。这也意味着数据库中表和列的名字应该和模型的名字保持一致。另一方面，如果数据库 Schema 已经存在，或者另有一个专门的数据建模团队要求有别于模型的数据库 Schema 设计，此时的 Schema 便不能和模型位于同一个限界上下文中了。</p>
<p>如果「<strong>用户界面(UI)</strong>」被用于渲染模型，并且驱动着模型的行为设计时，同样，该用户界面也应该属于模型所在的上下文边界之内。但是，这并不表示我们应该在用户界面中对领域进行建模，因为这样将导致「<strong>贫血领域对象</strong>」或者任何试图将领域概念带到领域模型之外的举措。</p>
<p>通常情况下，一个系统/应用程序的使用者并不只是人，还可能是另外的计算机系统。系统中有可能存在诸如 Web 服务之类的组件，或者使用 REST 资源来与模型交互，在所有可能的情形下，这些面向服务的组件都应该位于上下文边界之内。</p>
<p>用户界面和面向服务的端点都会将操作委派给「<strong>应用服务(Application Service)</strong>」，应用服务包含了不同类型的服务，比如安全和事务管理等。对于模型来说，应用服务扮演的是一种门面模式(Facade)。同时，应用服务还具有任何管理功能，它将来自用例流(Use Case Flow)的请求转换成领域逻辑的执行流。应用服务也是位于上下文边界之内的。</p>
<p>限界上下文主要用来封装通用语言和领域对象，但同时它也包含了那些为领域模型提供交互手段和辅助功能的内容。需要注意的是，对于架构中的每个组件，我们都应该将其放在适当的地方。限界上下文可以包含「<strong>模块(Module)</strong>」，「<strong>聚合(Aggregate)</strong>」，「<strong>领域事件(Domain Event)</strong>」和「<strong>领域服务(Domain Service)</strong>」。限界上下文应该足够大，以表达它所对应的整套通用语言。</p>
<h1 id="上下文映射图"><a href="#上下文映射图" class="headerlink" title="上下文映射图"></a>上下文映射图</h1><p>上下文映射图表示了不同限界上下文之间是如何集成的，任何两个限界上下文可能存在某种模式：</p>
<ul>
<li>合作关系(Partnership): 两个团队各自负责自己的上下文，在接口的演化上进行合作以同时满足两个系统的需求</li>
<li>共享内核(Shared Kernel): 两个上下文对模型和代码的共享产生一种紧密的依赖性，需要为共享的部分指定一个显式的边界，并保持共享内核的最小化。在没有与另一个团队协商的情况下，共享内核是不能改变的。应该引入一种持续集成机制来保证共享内核与通用语言的一致性。</li>
<li>客户方-供应方开发(Customer-Supplier Development): 两个上下文处于上-下游关系，上游团队独立于下游团队完成开发，下游团队的开发可能会受到很大的影响。因此在上游团队的计划中，应该顾及下游团队的需求。</li>
<li>遵奉者(Confirmist): 在存在上-下游关系的两个团队中，上游团队完全不考虑下游团队的需求，而下游团队只能盲目地使用上游团队的模型。</li>
<li>防腐层(Anticorruption Layer): <strong>ACL</strong>，当两个上下文不是<strong>合作</strong>，<strong>共享内核</strong>或者<strong>客户-供应方</strong>关系时，翻译将变得复杂。下游团队需要根据自己的领域模型创建一个单独的层，该层作为上游系统的代理提供功能。防腐层通过已有的接口与其他系统交互，在防腐层内部，在自己的模型和他方的模型之间进行翻译转换。如果翻译过于复杂，并且需要大量的数据复制和同步，从而使得翻译前后的模型存在很大的相似度，那么你可能过多地使用了外部上下文中的数据，导致自己的模型混淆不清了。</li>
<li>开放主机服务(Open Host Service): <strong>OHS</strong>，定义一种协议，其他系统通过该协议来访问该系统，协议是公开的，这样任何想与这个系统集成的人都可以使用该协议。通常来讲，我们可以将开发主机服务看成是<strong>远程过程调用 (Remote Procedure Call)</strong> 的 API。同时，它也可以通过<strong>消息机制</strong>实现。</li>
<li>发布语言(Published Language): <strong>PL</strong>，在两个限界上下文之间翻译模型需要一种公用的语言。此时你应该使用一种发布出来的共享语言来完成集成交流。发布语言通常与开放主机服务一起使用，常见的发布语言使用 XML Schema。在使用 REST 服务时，可以使用 XML 和 JSON，也可以使用 Google Proto Buffer 来表示。使用 REST 的好处是每个客户端都可以指明使用哪种语言，同时还可以指明资源的展现方法。</li>
<li>另谋他路(SeperateWay): 如果两套系统之间没有任何显著的关系，那么他们是完全解耦的，集成总是昂贵的。</li>
<li>大泥球(Big Ball of Mud): 当我们检查已有系统时，经常会发现系统中存在混杂在一起的模型，它们之间的边界非常模糊，此时应该为整个系统绘制一个边界，然后将其归纳在大泥球范围之列。</li>
</ul>
<p>系统间集成经常依赖于 RPC。RPC 与编程语言中的过程调用非常相似。和在相同进程中的过程调用不同的是，RPC 更容易产生有损性能的时间延迟，并有可能导致调用彻底失败。虽然 REST 并不是真正意义上的 RPC，但它却具有与 RPC 相似的特征。如果系统所依赖的状态已经存在于本地，那么系统将获得更大的自治性。DDD 的做法是在本地创建一些由外部模型翻译而成的领域对象，这些对象保留着本地模型所需的最小状态集。为了初始化这些对象，我们只需要有限的 RPC 调用或 REST 请求。然而，要与远程模型保持同步，最好的方式是在远程系统中采用面向消息的通知机制(例如 RabbitMQ)。消息通知可以通过服务总线进行发布，也可以采用消息队列或者 REST。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://berdypango.github.io/ddd-overview/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Frost He">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FrostHe.Handbook">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/ddd-overview/" itemprop="url">《实现领域驱动设计》读书笔记(1) - 总览</a></h1>
        

        <div class="post-meta">
          
          <span class="post-time">
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  626
                </span>
              

              

              
            </div>
          

          
              <div class="post-description">
                  本文记录了领域驱动设计的概念及主要涵盖的内容
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>系列大纲: <a href="/tags/ddd/">《实现领域驱动设计》读书笔记</a></p>
<p>本文大纲: </p>
<ul>
<li><a href="#%E5%89%8D%E8%A8%80">前言</a></li>
<li><a href="#%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%9E%8B">领域模型</a><ul>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%9E%8B">什么是领域模型？</a></li>
</ul>
</li>
</ul>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>面向对象编程的博大精深至今只浅尝一二，开发实践中一直希望能够持久向好的设计方向上靠而不过度设计。2015 年时第一次接触到领域驱动设计，当时看了 《实现领域驱动设计》这本书，初看时晦涩难懂，许多概念与当时的理解存在很大偏差，一度不理解为何要那样设计。在经过了几个项目的实战之后，如今再翻出来看，对书中总结的思考方式和方法论有了一番新的体会。现在看来，领域驱动设计之所以难以理解，在于其方法论的概念是抽象于任何语言和技术实现的，长期工作于一线的开发人员要转换思维去理解类似「<strong>值对象</strong>」，「<strong>标准类型</strong>」等这样的概念，需要一些时间。</p>
<p>一谈到「<strong>领域驱动设计</strong>」或者 <code>DDD</code>，总是很难通过一句话来概括，它既不是设计模式，也不代表任何技术实现，仅仅是面向对象程序设计的一种方法论，其中涵盖了在任何软件系统中可能涉及的方方面面。</p>
<h1 id="领域模型"><a href="#领域模型" class="headerlink" title="领域模型"></a>领域模型</h1><blockquote><h2 id="什么是领域模型？"><a href="#什么是领域模型？" class="headerlink" title="什么是领域模型？"></a>什么是领域模型？</h2><p>领域模型是关于某个特定业务领域的软件模型。通常，领域模型通过对象来实现，这些对象同时包含了「<strong>数据</strong>」和「<strong>行为</strong>」，并且表达了准确的业务含义</p>
<footer><strong>——《领域驱动设计》</strong></footer></blockquote>
<hr>
<p>全书由高层视角深入到实现的细枝末节来组织章节，其索引大致为：</p>
<ul>
<li>战略建模<ul>
<li>通用语言(Ubiquitous Language)</li>
<li>领域，子域和核心域</li>
<li>限界上下文(Bounded Context)</li>
<li>上下文映射图(Context Mapping)</li>
<li>架构(Archiecture)</li>
</ul>
</li>
<li>战术建模<ul>
<li>实体(Entity)</li>
<li>值对象(Value Object)</li>
<li>领域服务(Domain Service)</li>
<li>领域事件(Domain Event)</li>
<li>模块(Module)</li>
<li>聚合(Aggregate)</li>
<li>工厂(Factory)</li>
<li>资源库(Repository)</li>
<li>集成限界上下文(Integrating Bounded Contexts)</li>
<li>应用程序</li>
</ul>
</li>
</ul>
<p>这些不同的内容会在后续的笔记中一一提到，只取我觉得有价值的部分记录下来。设计一个系统时所需要的所有建模工具都能在以上这些概念中找到，并且针对这些应用场景提出了指导意见和最佳实践。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://berdypango.github.io/router-openwrt-shadowsocks/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Frost He">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FrostHe.Handbook">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/router-openwrt-shadowsocks/" itemprop="url">DIY - 网件 WNDR 4300 路由器配置全局科学上网</a></h1>
        

        <div class="post-meta">
          
          <span class="post-time">
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  2,442
                </span>
              

              

              
            </div>
          

          
              <div class="post-description">
                  文本记录了利用网件 WNDR 4300 路由器安装 OpenWrt 实现全局科学上网的路径与原理
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="shadowsocks-libev"><a href="#shadowsocks-libev" class="headerlink" title="shadowsocks-libev"></a>shadowsocks-libev</h2><p><code>shadowsocks-libev</code> 是一个 <code>shadowsocks</code> 协议的轻量级实现，其依赖于 <a href="http://software.schmorp.de/pkg/libev.html" target="_blank" rel="noopener">libev</a>，是 <code>shadowsocks-android</code>, <code>shadowsocks-ios</code> 以及 <code>shadowsocks-openwrt</code> 的上游项目。其具有以下特点：</p>
<ol>
<li>体积小巧，静态编译并打包后只有 100 KB。</li>
<li>高并发，基于 libev 实现的异步 I/O，以及基于线程池的异步 DNS，同时连接数可上万。</li>
<li>低资源占用。几乎不占用 CPU 资源，服务器端内存占用一般在 3MB 左右。<br>跨平台。适用于所有常见硬件平台，已测试通过的包括 x86，ARM 和 MIPS。也适用于大部分 POSIX 的操作系统或平台，包括 Linux，OS X 和 Cygwin 等。</li>
<li>协议及配置兼容。完全兼容 <code>shadowsocks</code> 协议，且兼容标准实现中的 JSON 风格配置文件，可与任意实现的 <code>shadowsocks</code> 客户端或服务端搭配使用。</li>
</ol>
<p><code>shadowsocks-libev</code> 包括服务端和客户端两部分，一共三个模块。</p>
<ol>
<li>ss-server: 服务器端，部署在远程服务器，提供 shadowsocks 服务。</li>
<li>ss-local: 客户端，提供本地 socks5 协议代理。</li>
<li>ss-redir: 客户端，提供本地透明代理，需要与 NAT 配合使用</li>
<li>ss-tunnel: 客户端，本地端口转发<br>官网地址：<br><a href="https://github.com/shadowsocks/shadowsocks-libev" target="_blank" rel="noopener">https://github.com/shadowsocks/shadowsocks-libev</a></li>
</ol>
<h2 id="准备一台安装-shadowsocks-libev-的海外服务器"><a href="#准备一台安装-shadowsocks-libev-的海外服务器" class="headerlink" title="准备一台安装 shadowsocks-libev 的海外服务器"></a>准备一台安装 shadowsocks-libev 的海外服务器</h2><h3 id="套用-bbr-拥塞算法"><a href="#套用-bbr-拥塞算法" class="headerlink" title="套用 bbr 拥塞算法"></a>套用 bbr 拥塞算法</h3><p>在搬瓦工购买一台 Ubuntu 16.04 x64 系统的 vps。首先查看内核版本:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ uname -r</span><br><span class="line"></span><br><span class="line">2.6.32-042stab128.2</span><br></pre></td></tr></table></figure></p>
<p>更新至最新版本内核:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt update</span><br><span class="line">$ sudo apt install --install-recommends linux-generic-hwe-16.04</span><br></pre></td></tr></table></figure></p>
<p>更新内核版本完成后，重启服务器:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo reboot</span><br></pre></td></tr></table></figure></p>
<p>要利用 <code>shadowsocks-libev</code> 科学上网，首先要有一台国外的服务器安装并运行 <code>shadowsocks</code> 服务端。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install shadowsocks-libev</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>具体系统安装指南参考<a href="https://github.com/shadowsocks/shadowsocks-libev" target="_blank" rel="noopener">Github</a>。</p>
</blockquote>
<p>上述命令会:</p>
<ul>
<li>安装 <code>ss-local</code> <code>ss-redir</code> <code>ss-server</code> <code>ss-tunnel</code> 到 <code>/usr/bin</code></li>
<li>新增开机启动脚本至 <code>/etc/init.d/shadowsocks-libev</code></li>
<li>配置文件 /etc/shadowsocks-libev/config.json (旧版是/etc/shadowsocks/config.json)</li>
<li>一些默认启动配置 /etc/default/shadowsocks-libev (旧版是/etc/default/shadowsocks)</li>
</ul>
<h3 id="配置服务端"><a href="#配置服务端" class="headerlink" title="配置服务端"></a>配置服务端</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vi /etc/shadowsocks-libev/config.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"server"</span>: <span class="string">"1.0.9.8"</span>,</span><br><span class="line">    <span class="string">"server_port"</span>: 1098,</span><br><span class="line">    <span class="string">"password"</span>: <span class="string">"killgfw"</span>,</span><br><span class="line">    <span class="string">"method"</span>: <span class="string">"aes-256-cfb"</span>        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>必须把 <code>server 1.0.9.8</code> 改成自己海外服务器的 ip 地址，或改成 0.0.0.0 表示监听本机。如果访问变慢，时断时续，可能是受到了干扰，可尝试改变加密方式，如改成 bf-cfb。</p>
<h3 id="修改防火墙设置"><a href="#修改防火墙设置" class="headerlink" title="修改防火墙设置"></a>修改防火墙设置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ufw allow 1098</span><br></pre></td></tr></table></figure>
<blockquote>
<p>1098 只是举例，配置文件中是哪个端口号，这里就是多少</p>
</blockquote>
<h3 id="控制-shadowsocks-libev"><a href="#控制-shadowsocks-libev" class="headerlink" title="控制 shadowsocks-libev"></a>控制 shadowsocks-libev</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo service shadowsocks-libev start</span><br><span class="line">$ sudo service shadowsocks-libev stop</span><br></pre></td></tr></table></figure>
<h3 id="查看-ss-server-是否已经启动并且带有-u-启动参数"><a href="#查看-ss-server-是否已经启动并且带有-u-启动参数" class="headerlink" title="查看 ss-server 是否已经启动并且带有 -u 启动参数"></a>查看 ss-server 是否已经启动并且带有 -u 启动参数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ps ax | grep ss-server</span><br><span class="line"></span><br><span class="line">/usr/bin/ss-server -c /etc/shadowsocks-libev/config.json -a root -u -f /var/run/shadowsocks-libev/shadowsocks-libev.pid</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其中有 <code>-u</code> 选项。如果 <code>shadowsocks</code> 客户端启用了 udp relay, 而服务端启动时不带 -u 参数，将无法正常工作。</p>
</blockquote>
<h2 id="在-OpenWrt-路由器上配置-shadowsocks-libev-客户端"><a href="#在-OpenWrt-路由器上配置-shadowsocks-libev-客户端" class="headerlink" title="在 OpenWrt 路由器上配置 shadowsocks-libev 客户端"></a>在 OpenWrt 路由器上配置 shadowsocks-libev 客户端</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ vi /etc/shadowsocks.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"server"</span>: <span class="string">"1.0.9.8"</span>,</span><br><span class="line">    <span class="string">"server_port"</span>: 1098,</span><br><span class="line">    <span class="string">"local_port"</span>: 7654,</span><br><span class="line">    <span class="string">"password"</span>: <span class="string">"killgfw"</span>,</span><br><span class="line">    <span class="string">"method"</span>: <span class="string">"aes-256-cfb"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>配置中几项参数需与服务端配置匹配。客户端的安装至 <a href="https://sourceforge.net/projects/openwrt-dist/files/shadowsocks-libev/" target="_blank" rel="noopener">https://sourceforge.net/projects/openwrt-dist/files/shadowsocks-libev/</a></p>
</blockquote>
<p>一切就绪后，使用 <code>ss-local -c /etc/shadowsocks.json</code> 在路由器测试代理上网。</p>
<h2 id="让-OpenWRT-正常安装软件"><a href="#让-OpenWRT-正常安装软件" class="headerlink" title="让 OpenWRT 正常安装软件"></a>让 OpenWRT 正常安装软件</h2><p>当我们刚给路由器刷上 OpenWRT 后，其只具备基本的上网功能，如果使用 <code>opkg update</code> 安装软件时，发现其根本不能 update，因为它连接的 <code>download.operwrt.org</code> 本身也在被墙列表中(或未被墙，但速度奇慢)。</p>
<h3 id="方法1-为-opkg-配置代理"><a href="#方法1-为-opkg-配置代理" class="headerlink" title="方法1: 为 opkg 配置代理"></a>方法1: 为 opkg 配置代理</h3><p>使用 SSH 远程登录路由器系统，找到 <code>/etc/opkg.conf</code> 文件，添加代理选项:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">option http_proxy http://proxy.example.org:8080/</span><br><span class="line">option ftp_proxy ftp://proxy.example.org:2121/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用以下选项进行服务器认证</span></span><br><span class="line">option proxy_username xxxx</span><br><span class="line">option proxy_password xxxx</span><br></pre></td></tr></table></figure></p>
<p>有时，因为 <code>busybox</code> 中 <code>wget</code> 的限制，代理服务器的认证可能失败。这时，可以尝试在代理服务器的 URL 中传入用户名和密码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">option http_proxy http://username:password@proxy.example.org:8080/</span><br><span class="line">option ftp_proxy http://username:password@proxy.example.org:2121/</span><br></pre></td></tr></table></figure></p>
<p>参考官方文档: <a href="https://wiki.openwrt.org/zh-cn/doc/techref/opkg" target="_blank" rel="noopener">https://wiki.openwrt.org/zh-cn/doc/techref/opkg</a></p>
<h3 id="方法2-调整本地-opkg-仓库"><a href="#方法2-调整本地-opkg-仓库" class="headerlink" title="方法2: 调整本地 opkg 仓库"></a>方法2: 调整本地 opkg 仓库</h3><p>参考 <a href="https://softwaredownload.gitbooks.io/openwrt-fanqiang/content/ebook/02.15.html" target="_blank" rel="noopener">https://softwaredownload.gitbooks.io/openwrt-fanqiang/content/ebook/02.15.html</a></p>
<h2 id="OpenWrt-科学上网原理"><a href="#OpenWrt-科学上网原理" class="headerlink" title="OpenWrt 科学上网原理"></a>OpenWrt 科学上网原理</h2><p>连接至路由器的家庭设备，所有流量都会经过路由器，而路由器会解析该条请求域名，至 <code>/etc/dnsmasq.d</code> 目录中查询 <code>accelerated-domains.china.conf</code> 配置清单，例如:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server=/10010.com/114.114.114.114</span><br><span class="line">server=/115.com/114.114.114.114</span><br></pre></td></tr></table></figure></p>
<p>如果任何用户访问 10010.com，<code>dnsmasq</code> 发现匹配项，则转发至国内域名服务器 114.114.114.114 查询该域名的 ip 地址。同一目录下的 <code>gfwlist.conf</code> 中包含:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server=/<span class="comment">#/127.0.0.1#3210</span></span><br></pre></td></tr></table></figure></p>
<p><code>#</code> 表示通配符，意为匹配所有域名，该文件将匹配的所有域名转发至本地端口 3210。由于 <code>dnsmasq</code> 会优先匹配具体规则，如果找不到该规则，则匹配泛化规则。因此，dnsmasq 会首先匹配 <code>accelerated-domains.china.conf</code> 上的域名，如果找不到匹配项，则匹配 <code>gfwlist.conf</code> 并转发至本地 3210 端口进行域名查询，而 3210 由本地 ss-tunel 客户端到远程服务器进行域名查询。</p>
<h3 id="etc-init-d-shadowsocks-脚本"><a href="#etc-init-d-shadowsocks-脚本" class="headerlink" title="/etc/init.d/shadowsocks 脚本"></a>/etc/init.d/shadowsocks 脚本</h3><p>查看 <code>/etc/init.d/shadowsocks</code> 脚本文件可得到:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">START=95</span><br><span class="line"></span><br><span class="line">SERVICE_USE_PID=1</span><br><span class="line">SERVICE_WRITE_PID=1</span><br><span class="line">SERVICE_DAEMONIZE=1</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">start</span></span>() &#123;</span><br><span class="line">	sed -i <span class="string">'s/114.114.114.114/127.0.0.1#3210/'</span> /etc/dnsmasq.d/gfwlist.conf</span><br><span class="line">	/etc/init.d/dnsmasq restart</span><br><span class="line"></span><br><span class="line">	service_start /usr/bin/ss-redir -b 0.0.0.0 -c /etc/shadowsocks.json -f /var/run/shadowsocks.pid</span><br><span class="line">	service_start /usr/bin/ss-tunnel -b 0.0.0.0 -c /etc/shadowsocks.json -l 3210 -L 8.8.8.8:53 -u </span><br><span class="line">	/usr/bin/shadowsocks-firewall</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">stop</span></span>() &#123;</span><br><span class="line">	sed -i <span class="string">'s/127.0.0.1#3210/114.114.114.114/'</span> /etc/dnsmasq.d/gfwlist.conf</span><br><span class="line">	/etc/init.d/dnsmasq restart</span><br><span class="line"></span><br><span class="line">	service_stop /usr/bin/ss-redir</span><br><span class="line">	service_stop /usr/bin/ss-tunnel</span><br><span class="line">	killall ss-redir</span><br><span class="line">	killall ss-tunnel</span><br><span class="line">	/etc/init.d/firewall restart</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该脚本的大致逻辑为:</p>
<ul>
<li>停止 <code>shadowsocks</code> 服务时，将 <code>dnsmasq</code> 泛域名匹配的规则改为查询国内 dns 域名的规则，即 <code>sed -i &#39;s/127.0.0.1#3210/114.114.114.114/&#39; /etc/dnsmasq.d/gfwlist.conf</code></li>
<li>启动 <code>shadowsocks</code> 服务时，如果以前停止过 <code>shadowsocks</code> 服务，要把泛域名匹配的解析改成通过<code>ss-tunnel 3210</code> 端口转发，<code>sed -i &#39;s/114.114.114.114/127.0.0.1#3210/&#39; /etc/dnsmasq.d/gfwlist.conf</code>。同时开启 <code>3210</code> 端口，并将收到的请求走 <code>ss-tunnel</code> 通道向远程服务器的发送向 <code>8:8:8:8:53</code> 查询 dns，即 <code>service_start /usr/bin/ss-tunnel -b 0.0.0.0 -c /etc/shadowsocks.json -l 3210 -L 8.8.8.8:53 -u</code></li>
<li><code>dnsmasq</code> 只负责域名查询分配转发，查询到 IP 地址后，再通过 <code>usr/bin/shdowsocks-firewall</code> 脚本判断是否要通过 <code>shadowsocks</code> 加密请求内容。</li>
</ul>
<blockquote>
<p>运行 <code>/etc/init.d/shadowsocks stop</code> 有时并没有结束 <code>ss-redir</code> 或 <code>ss-tunnel</code> 进程，即使 <code>killall</code> 有时还是不能杀掉进程，这种情况就只能重启路由器了。也就是说，修改了翻墙配置，有时必须重启路由器才能生效。</p>
</blockquote>
<h3 id="usr-bin-shdowsocks-firewall-脚本"><a href="#usr-bin-shdowsocks-firewall-脚本" class="headerlink" title="/usr/bin/shdowsocks-firewall 脚本"></a>/usr/bin/shdowsocks-firewall 脚本</h3><ol>
<li><p>如果请求指向自建 <code>shadowsocks</code> 服务器地址，立即返回，不做处理</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#create a new chain named SHADOWSOCKS</span></span><br><span class="line">iptables -t nat -N SHADOWSOCKS</span><br><span class="line">iptables -t nat -N SHADOWSOCKS_WHITELIST</span><br><span class="line"></span><br><span class="line"><span class="comment"># Ignore your shadowsocks server's addresses</span></span><br><span class="line"><span class="comment"># It's very IMPORTANT, just be careful.</span></span><br><span class="line">iptables -t nat -A SHADOWSOCKS -d 1.0.9.8 -j RETURN    </span><br><span class="line"><span class="comment">#iptables -t nat -A SHADOWSOCKS -d 1.0.9.7 -j RETURN</span></span><br><span class="line"><span class="comment">#iptables -t nat -A SHADOWSOCKS -d 1.0.9.6 -j RETURN</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果本地发出至局域网的请求，立即返回，不做处理</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Ignore LANs IP address</span></span><br><span class="line">iptables -t nat -A SHADOWSOCKS -d 0.0.0.0/8 -j RETURN</span><br><span class="line">iptables -t nat -A SHADOWSOCKS -d 10.0.0.0/8 -j RETURN</span><br><span class="line">iptables -t nat -A SHADOWSOCKS -d 127.0.0.0/8 -j RETURN</span><br><span class="line">iptables -t nat -A SHADOWSOCKS -d 169.254.0.0/16 -j RETURN</span><br><span class="line">iptables -t nat -A SHADOWSOCKS -d 172.16.0.0/12 -j RETURN</span><br><span class="line">iptables -t nat -A SHADOWSOCKS -d 192.168.0.0/16 -j RETURN</span><br><span class="line">iptables -t nat -A SHADOWSOCKS -d 224.0.0.0/4 -j RETURN</span><br><span class="line">iptables -t nat -A SHADOWSOCKS -d 240.0.0.0/4 -j RETURN</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果发出到中国的 IP 地址，立即返回，不做处理</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Ignore China IP address</span></span><br><span class="line"><span class="keyword">for</span> white_ip <span class="keyword">in</span> `cat /etc/chinadns_chnroute.txt`;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    iptables -t nat -A SHADOWSOCKS_WHITELIST -d <span class="string">"<span class="variable">$&#123;white_ip&#125;</span>"</span> -j MARK --<span class="built_in">set</span>-mark 1</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Check whitelist</span></span><br><span class="line">iptables -t nat -A SHADOWSOCKS -j SHADOWSOCKS_WHITELIST</span><br><span class="line">iptables -t nat -A SHADOWSOCKS -m mark --mark 1 -j RETURN</span><br></pre></td></tr></table></figure>
</li>
<li><p>其他全部转发至 <code>shdowsocks-libev</code> 本地客户端 <code>ss-redir</code> 监听的端口，由 <code>ss-redir</code> 负责和服务端进行加密通讯。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#for hulu.com</span></span><br><span class="line">iptables -t nat -A SHADOWSOCKS -p tcp --dport 1935 -j REDIRECT --to-ports 7654</span><br><span class="line">iptables -t nat -A SHADOWSOCKS -p udp --dport 1935 -j REDIRECT --to-ports 7654</span><br><span class="line"></span><br><span class="line"><span class="comment"># for Chrome browser and youtube.com</span></span><br><span class="line">iptables -t nat -A SHADOWSOCKS -p udp --dport 443 -j REDIRECT --to-ports 7654</span><br><span class="line"></span><br><span class="line"><span class="comment"># Anything else should be redirected to shadowsocks's local port</span></span><br><span class="line">iptables -t nat -A SHADOWSOCKS -p tcp -j REDIRECT --to-ports 7654</span><br><span class="line"><span class="comment"># Apply the rules</span></span><br><span class="line">iptables -t nat -A PREROUTING -p tcp -j SHADOWSOCKS</span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p><code>iptables -t nat -A SHADOWSOCKS -p tcp -j REDIRECT --to-ports 7654</code> 这里 7654 必须和 <code>OpenWrt</code> 路由器 <code>/etc/shadowsocks.json</code> 里的 <code>local_port</code> 保持一致</p>
<p>首先运行全代理模式，然后再执行白名单。在白名单比较长时冷启动的速度会比较快。</p>
</blockquote>
<blockquote>
<p>中国的 IP 列表较长，如果路由器硬件配置不是太好，可以把 Ignore China IP address 段注释掉，启用 Ignore Asia IP address 段。</p>
</blockquote>
<h3 id="控制-shadowsocks-本地客户端"><a href="#控制-shadowsocks-本地客户端" class="headerlink" title="控制 shadowsocks 本地客户端"></a>控制 shadowsocks 本地客户端</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ /etc/init.d/dnsmasq restart <span class="comment"># 重启 dnsmasq </span></span><br><span class="line">$ /etc/init.d/shadowsocks stop</span><br><span class="line">$ /etc/init.d/shadowsocks start</span><br><span class="line">$ /etc/init.d/shadowsocks <span class="built_in">enable</span> <span class="comment"># 设置 shadowsocks 在 OpenWrt 路由器启动时自动启动</span></span><br><span class="line">$ /etc/init.d/shadowsocks <span class="built_in">disable</span> <span class="comment"># 取消 shadowsocks 随机启动</span></span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://berdypango.github.io/linux-setup-a-new-ubuntu-server/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Frost He">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FrostHe.Handbook">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/linux-setup-a-new-ubuntu-server/" itemprop="url">搭建 Ubuntu 16.04 LTS</a></h1>
        

        <div class="post-meta">
          
          <span class="post-time">
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  1,111
                </span>
              

              

              
            </div>
          

          
              <div class="post-description">
                  近年来云计算服务器越来越流行，在适当的时机准备一台拥有公网 ip 的云服务器以备不时之需
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近租用了一台预装 <code>ubuntu</code> 操作系统(这里选择 <code>ubuntu</code> 是因为笔者对其预装的工具集比较熟悉)的服务器之后，还要为这台服务器做一些额外的配置以使其能够在互联网环境中正常运行。很多云服务提供商都提供了适配不同需求的预装环境，但为了对服务器的搭建过程有一个直观的感觉和更多的控制权，决定亲手过一遍这个过程。</p>
<blockquote>
<p>本篇文章涉及的所有指令细节可参考<a href="/linux/linux-account-and-group">Linux 基础 - 用户管理</a></p>
</blockquote>
<p>通常，配置一台裸机至少要完成以下几个步骤</p>
<ul>
<li>新建群组</li>
<li>新建用户，并为其分配群组</li>
<li>配置 <code>ssh</code></li>
<li>配置服务器安全策略</li>
</ul>
<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>在开始配置之前，我们需要知道该服务器的以下信息：</p>
<ul>
<li>服务器的公网 ip 地址</li>
<li>确认 22 端口打开</li>
<li>root 用户的初始密码</li>
</ul>
<p>在 windows 系统下启动 PuTTy，使用 <code>root</code> 用户远程登录到该服务器</p>
<h1 id="主机命名-hostname-可选的"><a href="#主机命名-hostname-可选的" class="headerlink" title="主机命名 hostname(可选的)"></a>主机命名 hostname(可选的)</h1><p>如果不想修改云服务提供商默认分配的主机名，可跳过此步。</p>
<p>执行命令 <code>hostname</code> 显示当前主机名<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hostname</span><br><span class="line">VM-0-4</span><br></pre></td></tr></table></figure></p>
<p>执行以下命令进行修改，修改完成后，再次执行命令以查看效果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sudo</span> hostname &lt;your-new-hostname&gt;</span><br><span class="line">$ hostname</span><br><span class="line">your-new-hostname</span><br></pre></td></tr></table></figure></p>
<h1 id="新建群组-groupadd"><a href="#新建群组-groupadd" class="headerlink" title="新建群组 - groupadd"></a>新建群组 - groupadd</h1><p>执行如下命令新建一个带有 <code>&lt;gid&gt;</code> 的群组<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sudo</span> groupadd &lt;your-new-group-name&gt; -g &lt;gid&gt;</span><br></pre></td></tr></table></figure></p>
<h1 id="新建用户-useradd"><a href="#新建用户-useradd" class="headerlink" title="新建用户 - useradd"></a>新建用户 - useradd</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sudo</span> useradd -u 2500 -m -c <span class="string">"FrostHe"</span> -s -g sudo -G pango pango</span><br></pre></td></tr></table></figure>
<p>该命令创建一个名为 <code>pango</code> 的用户，<code>uid</code> 为 2500，要求为该用户创建 Home 目录，使用预设值设置 <code>shell</code> 环境，加入初始群组 <code>sudo</code>，同时加入次要群组 <code>pango</code>。由于先前已经创建了群组，在创建该用户时就不会再创建与之同名的新的群组，而是将该用户加入到该群组下。</p>
<p>现在，新建用户 pango 还没有密码，设置密码之前是无法登录 shell 的，执行 <code>passwd</code> <username> 来为新用户指定密码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sudo</span> passwd pango</span><br><span class="line">Enter new Unix Password:</span><br><span class="line">Retype new Unix Password:</span><br></pre></td></tr></table></figure></username></p>
<blockquote>
<p><code>passwd</code> 指令在不接参数时表示修改当前登录用户的密码</p>
</blockquote>
<p>现在，退出 PuTTy 客户端，以新建用户名和密码登录，如果登录成功，则表明新用户创建无误。</p>
<h1 id="配置服务器安全策略"><a href="#配置服务器安全策略" class="headerlink" title="配置服务器安全策略"></a>配置服务器安全策略</h1><p>将云服务器的 22 端口暴露于互联网并允许 root 用户及一般用户以密码进行登录是不推荐的，特别是 root 帐号，一旦被攻击者破解那么服务器上的资源可任由其修改。为了使服务器免于这些危险，我们需要让这台服务器：</p>
<ul>
<li>禁用 root 帐号密码登录，仅启用公钥认证</li>
<li>开启防火墙并限定端口</li>
<li>设置 ip 登录策略及</li>
</ul>
<h2 id="禁用密码登录并启用-ssh-公钥登录"><a href="#禁用密码登录并启用-ssh-公钥登录" class="headerlink" title="禁用密码登录并启用 ssh 公钥登录"></a>禁用密码登录并启用 ssh 公钥登录</h2><p>以新建用户登录系统，修改 <code>sshd_config</code> 文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sudo</span> nano /etc/ssh/sshd_config</span><br><span class="line">PermitRootLogin no</span><br><span class="line">PublicAuthentication yes</span><br><span class="line">PasswordAuthentication no</span><br></pre></td></tr></table></figure></p>
<p>该配置对 ssh 客户端远程登录作出限制：启用公钥认证并禁用密码认证，同时禁止 <code>root</code> 远程登录。</p>
<blockquote>
<p>若要修改生效， <code>sshd</code> 进程需要重新读取该配置，但这会让已经通过密码登录的会话中断，并且在 public key 部署前没有任何机会重新进行远程连接，所以这一步放到最后来做。</p>
</blockquote>
<p>接下来在新用户 Home 目录下的 <code>.ssh/authorized_keys</code> 文件中复制 openssh 格式的公钥值。</p>
<blockquote>
<p>在 <code>/etc/ssh/sshd_config</code> 中有一行 <code>AuthorizedKeyFiles</code>，该行的默认值为 <code>.ssh/authorized_keys</code>，该项配置是 <code>sshd</code> 进程提取 <code>public key</code> 的依据，如果对该值进行了修改，那么这里新建的文件也必须要与之对应。</p>
</blockquote>
<p>现在执行 <code>sudo service sshd reload</code> 以使配置生效。此时重新打开一个 PuTTy 客户端，使用新用户密码登录，将收到错误对话框：<br><img src="/linux-setup-a-new-ubuntu-server/putty_authentication_error.png" title="尝试使用用户名密码通过 PuTTy 远程登录时报错"><br>在 Putty 中设置对应的私钥路径，重试即可登录成功：<br><img src="/linux-setup-a-new-ubuntu-server/putty_configuration_ppk.png" title="PuTTy private key 配置"></p>
<p>至此，一个基本的云服务器配置就完成了，有的云服务提供商推出了「<strong>安全组</strong>」功能，即从云端配置端口进出通道。更多安全配置查阅 <a href="/linux/linux-configure-csf">为 Linux 系统配置 CSF</a>。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://berdypango.github.io/linux-configure-csf/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Frost He">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FrostHe.Handbook">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/linux-configure-csf/" itemprop="url">为 Linux 系统配置 CSF</a></h1>
        

        <div class="post-meta">
          
          <span class="post-time">
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  2,150
                </span>
              

              

              
            </div>
          

          
              <div class="post-description">
                  本文介绍了基于 Linux 系统配置 csf 防火墙的注意事项
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>本文大纲:<br><!-- TOC --></p>
<ul>
<li><a href="#%E5%8A%9F%E8%83%BD">功能</a><ul>
<li><a href="#%E8%AE%A4%E8%AF%81%E5%A4%B1%E8%B4%A5%E6%A3%80%E6%B5%8B%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B">认证失败检测守护进程</a></li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E8%BF%BD%E8%B8%AA">进程追踪</a></li>
<li><a href="#%E7%9B%AE%E5%BD%95%E7%9B%91%E6%8E%A7">目录监控</a></li>
<li><a href="#%E6%B6%88%E6%81%AF%E6%9C%8D%E5%8A%A1">消息服务</a></li>
<li><a href="#%E7%AB%AF%E5%8F%A3%E6%B6%8C%E6%B5%81%E4%BF%9D%E6%8A%A4">端口涌流保护</a></li>
<li><a href="#port-knocking">Port Knocking</a></li>
<li><a href="#%E8%BF%9E%E6%8E%A5%E9%99%90%E5%88%B6%E4%BF%9D%E6%8A%A4">连接限制保护</a></li>
<li><a href="#portip-%E5%9C%B0%E5%9D%80%E9%87%8D%E5%AE%9A%E5%90%91">Port/IP 地址重定向</a></li>
<li><a href="#ui-%E9%9B%86%E6%88%90">UI 集成</a></li>
<li><a href="#ip-%E5%B1%8F%E8%94%BD%E5%88%97%E8%A1%A8">IP 屏蔽列表</a></li>
</ul>
</li>
<li><a href="#%E5%AE%89%E8%A3%85-configserver-firewall">安装 ConfigServer Firewall</a><ul>
<li><a href="#%E4%B8%8B%E8%BD%BD">下载</a></li>
<li><a href="#%E8%A7%A3%E5%8E%8B%E7%BC%A9">解压缩</a></li>
<li><a href="#%E5%AE%89%E8%A3%85">安装</a></li>
</ul>
</li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE">基本配置</a><ul>
<li><a href="#%E9%85%8D%E7%BD%AE%E7%AB%AF%E5%8F%A3">配置端口</a><ul>
<li><a href="#%E4%BB%BB%E4%BD%95%E4%B8%BB%E6%9C%BA">任何主机</a></li>
<li><a href="#apache">Apache</a></li>
<li><a href="#ftp-%E6%9C%8D%E5%8A%A1%E5%99%A8">FTP 服务器</a></li>
<li><a href="#%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8">邮件服务器</a></li>
<li><a href="#mysql-%E6%9C%8D%E5%8A%A1%E5%99%A8">MySQL 服务器</a></li>
</ul>
</li>
<li><a href="#%E8%BF%9B%E9%98%B6%E9%85%8D%E7%BD%AE">进阶配置</a></li>
<li><a href="#%E5%BA%94%E7%94%A8%E6%9B%B4%E6%94%B9">应用更改</a></li>
</ul>
</li>
<li><a href="#%E5%B1%8F%E8%94%BD%E4%B8%8E%E5%85%81%E8%AE%B8-ip-%E5%9C%B0%E5%9D%80">屏蔽与允许 ip 地址</a><ul>
<li><a href="#%E5%B1%8F%E8%94%BD-ip-%E5%9C%B0%E5%9D%80">屏蔽 ip 地址</a></li>
<li><a href="#%E5%85%81%E8%AE%B8-ip-%E5%9C%B0%E5%9D%80">允许 ip 地址</a></li>
<li><a href="#%E5%BF%BD%E7%95%A5-ip-%E5%9C%B0%E5%9D%80">忽略 ip 地址</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->
<p>Config Server Firewall(CSF) 基于一般的防火墙功能(数据包过滤)进行了扩展，支持大多数 Linux 发行版本，其支持列表可在其<a href="https://www.configserver.com/cp/csf.html" target="_blank" rel="noopener">官网</a>找到。以下以 ubuntu 系统为例介绍 CSF 的使用。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/linux-configure-csf/" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://berdypango.github.io/linux-document-search/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Frost He">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FrostHe.Handbook">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/linux-document-search/" itemprop="url">Linux 基础 - 指令与档案的搜索(which/whereis/locate/updatedb/find)</a></h1>
        

        <div class="post-meta">
          
          <span class="post-time">
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  1,056
                </span>
              

              

              
            </div>
          

          
              <div class="post-description">
                  本文简要介绍了 Linux 下搜索指令与档案相关的指令
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="which-寻找「可执行文件」"><a href="#which-寻找「可执行文件」" class="headerlink" title="which(寻找「可执行文件」)"></a>which(寻找「可执行文件」)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">which</span> [-a] <span class="built_in">command</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>-a</code>: 将所有定义在 <code>$PATH</code> 中与该指令相关的路径都列出来。</li>
</ul>
<p>例如:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">which</span> ifconfig</span><br><span class="line">/sbin/ifconfig</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">which</span> <span class="built_in">which</span></span><br><span class="line"><span class="built_in">alias</span> <span class="built_in">which</span>=<span class="string">'alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde'</span></span><br><span class="line">        /bin/<span class="built_in">alias</span></span><br><span class="line">        /usr/bin/<span class="built_in">which</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>这里涉及到了命令别名</p>
</blockquote>
<p><code>which</code> 预设是搜索 <code>PATH</code> 内定义的目录，有些 <code>bash</code> 内建的指令并没有在 <code>PATH</code> 中定义，所以有可能找不到，例如 <code>history</code> 指令。</p>
<h2 id="whereis"><a href="#whereis" class="headerlink" title="whereis"></a>whereis</h2><p><code>whereis</code> 仅针对特定目录进行查找，所以速度会比 <code>find</code> 指令快，想知道哪些目录，执行 <code>whereis -l</code> 即可。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ whereis [-bmsu] 档案名或目录名</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>-l</code>: 列出 <code>whereis</code> 查询的主要目录</li>
<li><code>-b</code>: 只找 <code>binary</code> 类型的文件</li>
<li><code>-m</code>: 只找在说明档 <code>manual</code> 路径下的档案</li>
<li><code>-s</code>: 只招 <code>source</code> 来源档案</li>
<li><code>-u</code>: 搜寻不在上述三个项目中的其他特殊档案</li>
</ul>
<p>举例:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ whereis ifconfig</span><br><span class="line">/sbin/ifconfig /usr/share/man/man8/ifconfig.8.gz</span><br></pre></td></tr></table></figure></p>
<h2 id="locate-updatedb"><a href="#locate-updatedb" class="headerlink" title="locate / updatedb"></a>locate / updatedb</h2><p>locate 在「已经建立的资料库(<code>/var/lib/mlocate/</code>)」中搜索，因此速度很快，但不同的 Linux 发行版建立资料库的预设周期都不同(CentOS 7.x 是每天更新一次)，如果在资料库新建之前使用该命令，有可能找不到目标资料，这时可执行 <code>updatedb</code> 手动更新资料库，<code>updatedb</code> 指令首先读取 <code>/etc/updatedb.conf</code> 配置文件，再去硬盘里搜索档案名，最后更新整个资料库档案，由于要进行硬盘操作，整个过程可能会比较慢。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ locate [-ir] 关键字</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>-i</code>: 忽略大小写</li>
<li><code>-c</code>: 不输出档案名称，仅计算找到的档案数量</li>
<li><code>-l</code>: 输出行数，如输出 5 行则是 <code>-l 5</code></li>
<li><code>-S</code>: 输出 <code>locate</code> 所使用的资料库档案的相关咨询，包括该资料库记录的档案/目录数量等</li>
<li><code>-r</code>: 后接正则表达式</li>
</ul>
<h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">$ find [PATH] [option] [action]</span><br><span class="line"></span><br><span class="line">选项与参数：</span><br><span class="line">1. 与档案权限及名称有关的参数：</span><br><span class="line">   -name filename：搜寻档案名称为 filename 的档案；</span><br><span class="line">   -size [+-]SIZE：搜寻比 SIZE 还要大 (+) 或小 (-) 的档案。这个 SIZE 的规格有：</span><br><span class="line">                   c: 代表 byte， k: 代表 1024 bytes。所以，要找比 50KB</span><br><span class="line">                   还要大的档案，就是『 -size +50k 』</span><br><span class="line">   -<span class="built_in">type</span> TYPE ：搜寻档案的类型为 TYPE 的，类型主要有：一般正规档案(f), 装置档案(b, c),</span><br><span class="line">                   目录(d), 连结档(l), socket(s), 及 FIFO(p) 等属性。</span><br><span class="line">   -perm mode ：搜寻档案权限『刚好等于』 mode 的档案，这个 mode 为类似 chmod</span><br><span class="line">                 的属性值，举例来说，`-rwsr-xr-x` 的属性为 4755 ！</span><br><span class="line">   -perm -mode ：搜寻档案权限『包含 mode 的权限』的档案，举例来说，</span><br><span class="line">                 我们要搜寻 `-rwxr--r--` ，亦即 0744 的档案，使用 -perm -0744，</span><br><span class="line">                 当一个档案的权限为 `-rwsr-xr-x` ，亦即 4755 时，也会被列出来，</span><br><span class="line">                 因为 `-rwsr-xr-x` 的属性已经包括 -rwxr--r-- 的属性了。</span><br><span class="line">   -perm /mode ：搜寻档案权限『包含任一 mode 的权限』的档案，举例来说，我们搜寻</span><br><span class="line">                 `-rwxr-xr-x` ，亦即 -perm /755 时，但一个档案属性为 `-rw-------`</span><br><span class="line">                 也会被列出来，因为他有 -rw.... 的属性存在！</span><br><span class="line"></span><br><span class="line">找出档名为passwd这个档案 </span><br><span class="line">[root@study ~]<span class="comment"># find / -name passwd</span></span><br><span class="line"></span><br><span class="line">找出档名包含了passwd这个关键字的档案 </span><br><span class="line">[root@study ~]<span class="comment"># find / -name "*passwd*" </span></span><br><span class="line"><span class="comment">#利用这个-name可以搜寻档名啊！预设是完整档名，如果想要找关键字，</span></span><br><span class="line"><span class="comment"># 可以使用类似* 的任意字元来处理</span></span><br><span class="line"></span><br><span class="line">找出/run目录下，档案类型为Socket的档名有哪些？</span><br><span class="line">[root@study ~]<span class="comment"># find /run -type s </span></span><br><span class="line"><span class="comment">#这个-type的属性也很有帮助喔！尤其是要找出那些怪异的档案，</span></span><br><span class="line"><span class="comment"># 例如socket 与FIFO 档案，可以用find /run -type p 或-type s 来找！</span></span><br><span class="line"></span><br><span class="line">搜寻档案当中含有SGID或SUID或SBIT的属性 </span><br><span class="line">[root@study ~]<span class="comment"># find / -perm /7000 </span></span><br><span class="line"><span class="comment">#所谓的7000就是---s--s--t ，那么只要含有s或t的就列出，所以当然要使用/7000，</span></span><br><span class="line"><span class="comment"># 使用-7000 表示要同时含有---s--s--t 的所有三个权限。而只需要任意一个，就是/7000 ～了乎？</span></span><br></pre></td></tr></table></figure>
<p>更多参数参考 <a href="http://linux.vbird.org/linux_basic/0220filemanager.php。" target="_blank" rel="noopener">http://linux.vbird.org/linux_basic/0220filemanager.php。</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://berdypango.github.io/linux-document-inspect/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Frost He">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FrostHe.Handbook">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/linux-document-inspect/" itemprop="url">Linux 基础 - 档案内容查阅(cat/tac/nl/more/less/head/tail/od/touch)</a></h1>
        

        <div class="post-meta">
          
          <span class="post-time">
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  1,444
                </span>
              

              

              
            </div>
          

          
              <div class="post-description">
                  本文介绍了 Linux 系统与档案内容查阅相关的指令
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="cat-concatenate"><a href="#cat-concatenate" class="headerlink" title="cat(concatenate)"></a>cat(concatenate)</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat [-AbEnTv] 档案名</span><br></pre></td></tr></table></figure>
<p>参数与选项:</p>
<ul>
<li><code>-A</code>: 忽略空白字符，列出不可见的特殊字符</li>
<li><code>-b</code>: 列出行号，仅针对非空白行</li>
<li><code>-E</code>: 将结尾的换行字符 <code>$</code> 显示出来</li>
<li><code>-n</code>: 列出行号，包括空白行</li>
<li><code>-T</code>: 将 <code>Tab</code> 以 <code>^|</code> 显示</li>
<li><code>-v</code>: 列出不可见的特殊字符</li>
</ul>
<blockquote>
<p>在使用 <code>cat -A</code> 指令后，Tab 以 <code>^|</code> 显示，而换行符以 <code>$</code> 显示，这样有助于查看空白部分到底是什么字符。</p>
</blockquote>
<h1 id="tac-反向串联"><a href="#tac-反向串联" class="headerlink" title="tac(反向串联)"></a>tac(反向串联)</h1><p><code>tac</code> 命令恰好是 <code>cat</code> 命令反写，<code>cat</code> 从第一行输出至最后一行，而 <code>tac</code> 从最后一行输出到第一行。</p>
<h1 id="nl-添加行号"><a href="#nl-添加行号" class="headerlink" title="nl(添加行号)"></a>nl(添加行号)</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nl [-bnw] 档案名</span><br></pre></td></tr></table></figure>
<p>参数与选项:</p>
<ul>
<li><code>-b</code>: 指定行号的方式，主要有两种:<ul>
<li><code>-ba</code>: 类似 <code>cat -n</code>，空行也列出行号</li>
<li><code>-bt</code>: 忽略空白行的行号，预设值</li>
</ul>
</li>
<li><code>-n</code>: 列出行号表示方法，主要三种:<ul>
<li><code>-n ln</code>: 行号位于左侧</li>
<li><code>-n rn</code>: 行号位于右侧</li>
<li><code>-n rz</code>: 行号位于右侧，且添零补齐</li>
</ul>
</li>
<li><code>-w</code>: 行号占位字符数<br>举例:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nl -ba -n rz -w 3 /etc/issue</span><br><span class="line">001 \S</span><br><span class="line">002 Kernel \r on an \m</span><br><span class="line">003</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="翻页-more-和-less"><a href="#翻页-more-和-less" class="headerlink" title="翻页(more 和 less)"></a>翻页(more 和 less)</h1><p><code>ln</code>, <code>cat</code> 和 <code>tac</code> 都是将档案的全部内容一次性输出到屏幕上，<code>more</code> 与 <code>less</code> 指令提供了翻页功能。</p>
<h2 id="more"><a href="#more" class="headerlink" title="more"></a>more</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">more /etc/man_db.conf</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This file is used by the man-db package to configure the man and cat paths.</span></span><br><span class="line"><span class="comment"># It is also used to provide a manpath for those without one by examining</span></span><br><span class="line"><span class="comment"># their PATH environment variable. For details see the manpath(5) man page.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">--More--(28%)</span><br></pre></td></tr></table></figure>
<p>使用 <code>more</code> 指令后，可以注意到最下端一行多出了一个百分比，此时如果按下:</p>
<ul>
<li><code>Space</code>: 下一页</li>
<li><code>b</code>: 上一页</li>
<li><code>Enter</code>: 下一行</li>
<li><code>q</code>: 退出 <code>more</code> 指令</li>
<li><code>/{字符串}</code>: 向下查找 「字符串」 匹配的文本，按下 <code>Enter</code> 开始查找，按下 <code>n</code> 查找下一个，</li>
<li><code>:f</code>: 显示档案名及当前显示的行数<h2 id="less"><a href="#less" class="headerlink" title="less"></a>less</h2><code>less</code> 在 <code>more</code> 的基础上做了改进，less 使用 <code>PGUp</code> 和 <code>PGDown</code> 来翻页。并且多出了一些选项:</li>
<li><code>Space</code>: 下一页</li>
<li><code>pagedown</code>: 下一页</li>
<li><code>pageup</code>: 上一页</li>
<li><code>/{字符串}</code>: 向下查找 「字符串」 匹配的文本</li>
<li><code>?{字符串}</code>: 向上查找 「字符串」 匹配的文本</li>
<li><code>n</code>: 重复前一个查找</li>
<li><code>N</code>: 反向重复前一个查找</li>
<li><code>g</code>: 跳转至第一行</li>
<li><code>G</code>: 跳转至最后一行</li>
<li><code>q</code>: 退出 <code>less</code> 指令</li>
</ul>
<blockquote>
<p><code>man</code> 指令是执行 <code>less</code> 指令产生的结果，所以两者在用法上是相通的</p>
</blockquote>
<h1 id="文本截取-head-和-tail"><a href="#文本截取-head-和-tail" class="headerlink" title="文本截取(head 和 tail)"></a>文本截取(head 和 tail)</h1><h2 id="head"><a href="#head" class="headerlink" title="head"></a>head</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head [-n number] 档案名</span><br></pre></td></tr></table></figure>
<p>选项与参数:</p>
<ul>
<li><code>-n</code>: 后接数字，代表显示前 n 行，如果不指定 <code>-n</code> 参数，默认情况下该指令显示前 10 行，如果指定为 <code>-100</code>，则表示显示最后 100 行之前的所有行<br>举例: <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">head /etc/man_db.conf <span class="comment"># 输出前 10 行</span></span><br><span class="line">head /etc/man_db.conf -n 20 <span class="comment"># 输出前 20 行</span></span><br><span class="line">head /etc/man_db.conf -n -100 <span class="comment"># 输出最后 100 行前的所有行</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail [-n number] 档案名</span><br></pre></td></tr></table></figure>
<p>选项与参数:</p>
<ul>
<li><code>-n</code>: 后接数字，表示输出最后 n 行，默认值为 10，</li>
<li><code>-f</code>: 表示实时侦测文档，<code>Ctrl + C</code> 来取消<br>举例:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tail /etc/man_db.conf <span class="comment"># 输出最后 10 行</span></span><br><span class="line">tail -n 20 /etc/man_db.conf <span class="comment"># 输出最后 20 行</span></span><br><span class="line">tail -n +100 /etc/man_db.conf <span class="comment"># 输出 100 行后的所有行</span></span><br><span class="line">tail -f /var/<span class="built_in">log</span>/messages  <span class="comment"># 实时监测该文档的内容，可与 -n 并用</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>如果希望输出某个文档的第 10-20 行，那么可以执行 <code>head -n 20 /etc/man_db.conf | tail -n 10</code>，意为先去前 20 行，再将其结果交给 <code>tail</code> 指令输出最后 10 行。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -n /etc/man_db.conf | head -n 20 | tail -n 10 <span class="comment"># 取 /etc/man_db.conf 的 10-20 行，并显示行号</span></span><br></pre></td></tr></table></figure>
<h1 id="非纯文本档案-od"><a href="#非纯文本档案-od" class="headerlink" title="非纯文本档案: od"></a>非纯文本档案: od</h1><p>上述的所有指令都是针对纯文本的档案读取，对非纯文本档案的读取使用 od 指令:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">od [-t TYPE] 档案名</span><br></pre></td></tr></table></figure></p>
<p>选项与参数:</p>
<ul>
<li><code>-t</code>: 接档案类型，类型有:<ul>
<li>a: 使用预设的字符输出</li>
<li>c: 使用 ASCII 输出</li>
<li>d[size]: 使用十进制(decimal)输出资料，每个整数占用 [size] 字节</li>
<li>f[size]: 使用浮点数(floating)输出资料，每个数占用 [size] 字节</li>
<li>o[size]: 利用八进(octal)制输出资料，每个整数占用 [size] 字节</li>
<li>x[size]: 利用十六进制(hexadecimal)来输出资料，每个整数占用 [size] 字节</li>
</ul>
</li>
</ul>
<blockquote>
<p>该命令可用于快速定位字符的 ASCII 编码，例如: echo password | od -t oCc</p>
</blockquote>
<h1 id="修改档案时间或新建档案-touch"><a href="#修改档案时间或新建档案-touch" class="headerlink" title="修改档案时间或新建档案: touch"></a>修改档案时间或新建档案: touch</h1><p>对于某个档案，其主要有 3 个时间变动的入口:</p>
<ul>
<li>modification time(mtime): 档案的「内容」更改时，会更新该时间</li>
<li>status time(ctime): 档案的「状态」改变时，会更新该时间，例如权限和属性被更改</li>
<li>access time(atime): 「档案的内容被读取」时，会更新该时间，例如用 <code>cat</code> 指令读取某个档案</li>
</ul>
<p>默认情况下，当使用 <code>ls</code> 指令时，得到的时间是 <code>mtime</code>，即该档案内容上次被修改的时间，如果发现时间不对，可 <code>touch</code> 指令修改时间:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch [-acdmt] 档案名</span><br></pre></td></tr></table></figure></p>
<p>选项和参数:</p>
<ul>
<li><code>-a</code>: 仅修改 aceess time</li>
<li><code>-c</code>: 仅修改档案时间，若档案不存在则不建立新档案</li>
<li><code>-d</code>: 修改 atime 和 mtime，后接目标时间，可用 –date=”日期或时间”代替</li>
<li><code>-m</code>: 仅修改 mtime</li>
<li><code>-t</code>: 修改 atime 和 mtime，后接目标时间，格式为 [YYYYMMDDhhmm]<br>举例:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">touch testtouch <span class="comment"># 建立新的空档案，三个时间都会更新会当前时间</span></span><br><span class="line">date; ll bashrc; ll - -time=atime bashrc; ll --time=ctime bashrc</span><br><span class="line">touch -d <span class="string">"2 days ago"</span> bashrc <span class="comment"># 修改</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p><code>;</code> 用于分割连续下达的指令，这些指令会依次执行，<code>ctime</code> 是无法通过指令修改的，即便是完全复制一条档案，也无法复制 <code>ctime</code>，该属性记录了档案的状态变化时间。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://berdypango.github.io/linux-document-management/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Frost He">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FrostHe.Handbook">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/linux-document-management/" itemprop="url">Linux 基础 - 档案与目录管理(ls/cp/rm/mv/basename/dirname)</a></h1>
        

        <div class="post-meta">
          
          <span class="post-time">
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  1,061
                </span>
              

              

              
            </div>
          

          
              <div class="post-description">
                  本文介绍了 Linux 系统与档案与目录管理相关的指令
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>档案管理主要涉及: </p>
<ul>
<li>显示档案详情</li>
<li>拷贝</li>
<li>删除档案</li>
<li>移动档案</li>
</ul>
<h1 id="ls-检视档案"><a href="#ls-检视档案" class="headerlink" title="ls(检视档案)"></a>ls(检视档案)</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ls [-aAdfFhilnrRSt] 档名或目录名</span><br><span class="line">ls [--color=&#123;never,auto,always&#125;] 档名或目录名</span><br><span class="line">ls [--full-time] 档名或目录名</span><br></pre></td></tr></table></figure>
<p>ls 常用的选项有:</p>
<ul>
<li><code>-a</code>: 全部档案，包括隐藏档案</li>
<li><code>-A</code>: 全部的档案，包括隐藏档案，但不包括 <code>.</code> 与 <code>..</code> 两个目录</li>
<li><code>-d</code>: 仅列出目录</li>
<li><code>-f</code>: 直接列出结果，而不进行排序(<code>ls</code> 预设会以名称排序)</li>
<li><code>-F</code>: 为档案名添加特殊符号以标识其类别，例如 <code>*</code> 代表可执行档案，<code>/</code> 代表目录，<code>=:</code> 代表 socket 档案，<code>|:</code> 代表 FIFO 档案。</li>
<li><code>-h</code>: 将档案容量以人类友好的方式列出(GB, KB)</li>
<li><code>-i</code>: 列出 inode 号码</li>
<li><code>-l</code>: 列出详情</li>
<li><code>-n</code>: 使用 UID 与 GID 而非用户名称和群组名称</li>
<li><code>-r</code>: 将排序结果反向输出</li>
<li><code>-R</code>: 递归显示所有目录</li>
<li><code>-S</code>: 以档案容量大小排序</li>
<li><code>-t</code>: 以时间排序</li>
</ul>
<p>ls 指令包含了很多功能，Linux 档案系统记录了与档案有关的权限和属性，这些数据都放在 i-node 里面，有关 i-node 的详情，见后文。</p>
<p>由于 <code>ls -l</code> 非常常用，很多 <code>Linux</code> 的发布版本使用 <code>ll</code> 指令使其成为 <code>ls -l</code> 的缩写，而这是由 Bash shell 的 alias 功能实现的，有关这部分内容，见后文。</p>
<h1 id="cp-复制档案或目录"><a href="#cp-复制档案或目录" class="headerlink" title="cp(复制档案或目录)"></a>cp(复制档案或目录)</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp [-adfilprsu] <span class="built_in">source</span> destination</span><br><span class="line">cp [options] source1 source2 source3 .... directory</span><br></pre></td></tr></table></figure>
<p>cp 常用选项:</p>
<ul>
<li><code>-i</code>: 若目标已经存在，则要求询问是否覆盖</li>
<li><code>-d</code>: 若源为 link 档，则复制 link 档的属性而非档案本身的属性</li>
<li><code>-f</code>: force 的简写，若目标档已经存在且无法开启，则移除后再试一次</li>
<li><code>-p</code>: 复制档案及其属性，备份常用</li>
<li><code>-r</code>: 启用递归复制</li>
<li><code>-s</code>: 复制为符号链接(symbolic link)</li>
<li><code>-l</code>: 复制为硬式链接(hard link)</li>
<li><code>--preserve=all</code>: 除了 <code>-p</code> 的相关属性外，还加入 SELinux 的属性，links，xattr 也复制。</li>
<li><code>-a</code>: 相当于 <code>-dr --preserve=all</code></li>
</ul>
<blockquote>
<p>如果不加任何选项，档案被复制后其属性会发生改变，如果想要完全复制档案，则需要加上 <code>-a</code> 选项。</p>
</blockquote>
<p>在复制其他用户的资料时(必须要有 Read 权限)，总是希望得到的档案权限归自身用户所有，所以 <code>cp</code> 指令预设复制后的档案归复制者所有，这意味着在不加任何选项的情况下，得到的档案权限与复制者用户一致。在使用 <code>cp</code> 指令进行复制时，考虑以下几点:</p>
<ul>
<li>是否需要完整保留原始档案的咨询？</li>
<li>原始档是否为符号链接档</li>
<li>原始档是否为特殊的档案，例如 FIFO，socket 等？</li>
<li>原始档是否为目录？</li>
</ul>
<h1 id="rm-移除档案或目录"><a href="#rm-移除档案或目录" class="headerlink" title="rm(移除档案或目录)"></a>rm(移除档案或目录)</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm [-fir]档案或目录</span><br></pre></td></tr></table></figure>
<p><code>rm</code> 指令关键选项:</p>
<ul>
<li><code>-f</code>: force 的简写，忽略不存在的档案，不会出现警告</li>
<li><code>-i</code>: 互动模式，在删除询问使用者</li>
<li><code>-r</code>: 递归删除</li>
</ul>
<blockquote>
<p>使用 <code>*</code> 通配符可以删除任意匹配的档案或目录</p>
</blockquote>
<p>Linux 系统下，为了防止档案被 root 误删，很多发行版预设加入了 <code>-i</code> 这个选项。但是使用 <code>rm -r</code> 这个指令系统不会再次询问，使用前要特别注意。如果确定目录不要了，那么使用 <code>rm -r</code> 来递归删除是不错的方式。</p>
<h1 id="mv-移动档案与目录，或更改名称"><a href="#mv-移动档案与目录，或更改名称" class="headerlink" title="mv(移动档案与目录，或更改名称)"></a>mv(移动档案与目录，或更改名称)</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv [-fiu] <span class="built_in">source</span> destination </span><br><span class="line">mv [options] source1 source2 source3 .... directory</span><br></pre></td></tr></table></figure>
<p><code>mv</code> 指令关键选项:</p>
<ul>
<li><code>-f</code>: force 的缩写，如果目标档已经存在，则不询问而直接覆盖</li>
<li><code>-i</code>: 互动模式，若目标档案已经存在，则会询问是否覆盖</li>
<li><code>-u</code>: 若目标档案已经存在，且原始档较新才会执行移动</li>
</ul>
<blockquote>
<p><code>-u</code> 选项可以用来测试新旧档案，看看是否需要搬移；<code>rm</code> 指令可以用来重命名文件，但 Linux 有另外一个 <code>rename</code> 指令可以进行批量改名。</p>
</blockquote>
<h1 id="basename-和-dirname"><a href="#basename-和-dirname" class="headerlink" title="basename 和 dirname"></a>basename 和 dirname</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">basename /etc/sysconfig/network</span><br><span class="line">network</span><br></pre></td></tr></table></figure>
<p><code>basename</code> 用于获取档案本身的名称<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dirname /etc/sysconfig/network</span><br><span class="line">/etc/sysconfig</span><br></pre></td></tr></table></figure></p>
<p><code>dirname</code> 用于获取包含档案的目录的完整路径</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://berdypango.github.io/linux-directory-operations/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Frost He">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FrostHe.Handbook">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/linux-directory-operations/" itemprop="url">Linux 基础 - 目录操作与 $PATH</a></h1>
        

        <div class="post-meta">
          
          <span class="post-time">
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  1,122
                </span>
              

              

              
            </div>
          

          
              <div class="post-description">
                  本文介绍了 Linux 系统有关目录的常用指令和 $PATH 变量的意义
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文大纲:<br><!-- TOC --></p>
<ul>
<li><a href="#%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84%E4%B8%8E%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84">绝对路径与相对路径</a></li>
<li><a href="#%E5%B8%B8%E7%94%A8%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C">常用目录操作</a><ul>
<li><a href="#cdchange-directory-%E5%8F%98%E6%8D%A2%E7%9B%AE%E5%BD%95">cd(change directory, 变换目录)</a></li>
<li><a href="#pwdprint-working-directory-%E6%98%BE%E7%A4%BA%E5%BD%93%E5%89%8D%E6%89%80%E5%9C%A8%E7%9B%AE%E5%BD%95">pwd(print working directory, 显示当前所在目录)</a></li>
<li><a href="#mkdirmake-directory-%E6%96%B0%E5%BB%BA%E7%9B%AE%E5%BD%95">mkdir(make directory, 新建目录)</a></li>
<li><a href="#rmdirremove-directory-%E5%88%A0%E9%99%A4%E7%9B%AE%E5%BD%95">rmdir(remove directory, 删除目录)</a></li>
</ul>
</li>
<li><a href="#%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F-path">执行程序的环境变量: $PATH</a></li>
</ul>
<!-- /TOC -->
<h1 id="绝对路径与相对路径"><a href="#绝对路径与相对路径" class="headerlink" title="绝对路径与相对路径"></a>绝对路径与相对路径</h1><p>Linux 中路径分为绝对路径与相对路径</p>
<ul>
<li>绝对路径：由根目录作为起始路径</li>
<li>相对路径：由当前所在路径作为起始路径，当前路径可用 <code>./</code> 表示</li>
</ul>
<blockquote>
<p>在编写 shell 脚本时最好采用绝对路径，因为这样不会随着脚本文件所在的路径而对代码执行结果产生影响</p>
</blockquote>
<h1 id="常用目录操作"><a href="#常用目录操作" class="headerlink" title="常用目录操作"></a>常用目录操作</h1><p>Linux 系统常见的目录操作指令有: </p>
<ul>
<li>cd: 变换目录</li>
<li>pwd: 显示当前的目录</li>
<li>mkdir: 创建新目录</li>
<li>rmdir: 删除目录</li>
</ul>
<h2 id="cd-change-directory-变换目录"><a href="#cd-change-directory-变换目录" class="headerlink" title="cd(change directory, 变换目录)"></a>cd(change directory, 变换目录)</h2><p>每一个登入 Linux 系统的用户第一个进入的目录都是该用户的 Home 目录，即 <code>~</code>，同样也可以执行 <code>cd ~</code> 回到 Home 目录，如果仅仅输入 <code>cd</code> 代表的就是 <code>cd ~</code>，<code>cd -</code> 代表回到前一个目录，在预设指令模式(bash shell)中，可以利用 tab 键来自动补齐路径。</p>
<h2 id="pwd-print-working-directory-显示当前所在目录"><a href="#pwd-print-working-directory-显示当前所在目录" class="headerlink" title="pwd(print working directory, 显示当前所在目录)"></a>pwd(print working directory, 显示当前所在目录)</h2><p>如果想要知道当前所在的工作目录，执行 <code>pwd</code> 即可。</p>
<p><code>-P</code> 选项是显示当前目录链接的真实目录，例如，ubuntu 系统在 /var/spool/mail 下执行 <code>pwd</code> 会显示 <code>/var/spool/mail</code>，而执行 <code>pwd -P</code> 指令会显示 <code>/var/mail</code>，这表明 <code>/var/spool/mail</code> 链接到了 <code>/var/mail</code>。</p>
<p>返回上一级目录执行 <code>ls -al</code> 我们会看到 mail 目录指向了 ../mail/。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">drwxr-xr-x 0 root   root 512 Sep 23  2017 ./</span><br><span class="line">drwxr-xr-x 0 root   root 512 Mar  1 01:54 ../</span><br><span class="line">drwxr-xr-x 0 root   root 512 Sep 23  2017 cron/</span><br><span class="line">lrwxrwxrwx 1 root   root   7 Sep 23  2017 mail -&gt; ../mail/</span><br><span class="line">drwx------ 0 syslog adm  512 Apr  5  2016 rsyslog/</span><br></pre></td></tr></table></figure></p>
<h2 id="mkdir-make-directory-新建目录"><a href="#mkdir-make-directory-新建目录" class="headerlink" title="mkdir(make directory, 新建目录)"></a>mkdir(make directory, 新建目录)</h2><p>默认情况下，执行 <code>mkdir /home/pango/testing</code> 目标目录需要一层一层的新建才行，为了递归创建目录，添加 <code>-p</code> 选项可以自动创建不存在的目录。</p>
<p>另外，通过 <code>-m</code> 选项可以在新建目录时为该目录指定权限，例如当执行 <code>mkdir -p -m 711 /home/pango/testing</code> 时，在该目录树上的所有新建的目录都会具有 <code>drwx--x--x</code> 权限。如果不指定 <code>-m</code> 选项，其默认权限会与 umask 有关，见后文。</p>
<h2 id="rmdir-remove-directory-删除目录"><a href="#rmdir-remove-directory-删除目录" class="headerlink" title="rmdir(remove directory, 删除目录)"></a>rmdir(remove directory, 删除目录)</h2><p>与 <code>mkdir</code> 指令类似，默认情况下，目标目录需要一层一层的删除才行，且被删除的目录必须为空，即该目录下不能存在任何目录或文件。</p>
<p>而 <code>-p</code> 提供了递归删除目录选项，且会删除指定目录下的任何目录和文件，该操作比较危险，使用时需谨慎。</p>
<h1 id="执行程序的环境变量-PATH"><a href="#执行程序的环境变量-PATH" class="headerlink" title="执行程序的环境变量: $PATH"></a>执行程序的环境变量: $PATH</h1><p>指令 <code>ls</code> 的二进制可执行程序所在的目录为 <code>/bin/ls</code>，可是为何可以在任何目录下执行 <code>ls</code> 这个指令呢？这就是环境变量 <code>$PATH</code> 的作用。</p>
<p>当执行 <code>ls</code> 指令时，系统会根据 <code>PATH</code> 的值去每个定义的目录下搜索名称为 ‘ls’ 的可执行文件，如果在 <code>PATH</code> 定义的目录中包含多个名称为 ‘ls’ 的可执行文件，那么先被找到的指令会被执行。</p>
<p>执行 <code>echo $PATH</code> 会在屏幕上打印出所有定义的路径值，<code>$</code> 表示环境变量，<code>PATH</code> 表示环境变量的键，注意 <code>PATH</code> 一定都是大写字母，其定义的多个路径每个之间由 <code>:</code> 分隔。</p>
<p>现在，如果将 <code>ls</code> 指令从 <code>/bin/ls</code> 通过 <code>mv /bin/ls /root/</code> 移动到 <code>/root/</code> 目录下，</p>
<ul>
<li>即使执行 <code>cd /root</code> 切换到与其相同的目录下，执行 <code>ls</code> 指令仍被告知找不到指定的指令，因为 <code>PATH</code> 中并未定义 <code>/root</code> 路径，系统搜索不到该指令。</li>
<li>可以通过使用绝对路径或相对路径来执行该指令: <code>/root/ls</code> 或 <code>./ls</code>。</li>
<li>可通过 <code>PATH=&quot;${PATH}:/root&quot;</code> 将 <code>/root</code> 加入到 <code>PATH</code> 变量中。</li>
</ul>
<p>此外，关于 <code>PATH</code> 需要注意以下几项: </p>
<ul>
<li>不同的用户的环境变量 <code>PATH</code> 的值是不同的。</li>
<li><code>PATH</code> 是可以修改的</li>
<li>相比修改 <code>PATH</code> 的值，优先使用绝对路径或相对路径来执行某个指令。</li>
<li>指令放置到正确的目录下</li>
<li>最好不要将当前目录 <code>.</code> 加入到 <code>PATH</code> 当中。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://berdypango.github.io/linux-directory-configuration/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Frost He">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FrostHe.Handbook">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/linux-directory-configuration/" itemprop="url">Linux 基础 - 目录配置</a></h1>
        

        <div class="post-meta">
          
          <span class="post-time">
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  2,216
                </span>
              

              

              
            </div>
          

          
              <div class="post-description">
                  本文记录了 Linux 系统下预设目录的划分依据，以及自定义软件放置数据的最佳实践
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>参考资料: <a href="http://linux.vbird.org/linux_basic/0210filepermission.php#dir" target="_blank" rel="noopener">http://linux.vbird.org/linux_basic/0210filepermission.php#dir</a></p>
<p>本文大纲:<br><!-- TOC --></p>
<ul>
<li><a href="#linux-%E7%9B%AE%E5%BD%95%E9%85%8D%E7%BD%AE">Linux 目录配置</a><ul>
<li><a href="#%E6%A0%B9%E7%9B%AE%E5%BD%95">根目录</a></li>
<li><a href="#usr-%E7%9A%84%E6%84%8F%E4%B9%89%E4%B8%8E%E5%86%85%E5%AE%B9">/usr 的意义与内容</a></li>
<li><a href="#var-%E7%9A%84%E6%84%8F%E4%B9%89%E4%B8%8E%E5%86%85%E5%AE%B9">/var 的意义与内容</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->
<h1 id="Linux-目录配置"><a href="#Linux-目录配置" class="headerlink" title="Linux 目录配置"></a>Linux 目录配置</h1><p>Linux 采用 FHS(Filesystem Hierarchy Standard) 标准作为配置目录结构的参考依据，目前，大多数 Linux 的发行版本都遵循了这套标准。FHS 将目录定义为四种交互形态，表格如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>可分享的(shareable)</th>
<th>不可分享的(unshareable)</th>
</tr>
</thead>
<tbody>
<tr>
<td>不变的(static)</td>
<td>/usr(软件所在位置)</td>
<td>/etc(配置目录)</td>
</tr>
<tr>
<td></td>
<td>/opt(第三方协议软件)</td>
<td>/boot(开机与核心档)</td>
</tr>
<tr>
<td>可变的(variable)</td>
<td>/var/mail(用户邮件信箱)</td>
<td>/var/run(程序相关)</td>
</tr>
<tr>
<td></td>
<td>/var/spool/news(新闻群组)</td>
<td>/var/lock(程序相关)</td>
</tr>
</tbody>
</table>
<ul>
<li>可分享的: 可分享给其他系统挂载使用的目录，包括可执行程序与邮件等</li>
<li>不可分享的: 仅与本地系统或配置有关的，分享给其他主机将无法直接使用</li>
<li>不变的: 例如函数库，文件说明系统管理员管理的主机服务配置文件等</li>
<li>可变的: 经常需要改变的资料，如登录档案，用户收取的新闻等。</li>
</ul>
<p>事实上, FHS 仅定义以下三层目录的用途：</p>
<ul>
<li>/(root, 根目录): 与开机系统有关</li>
<li>/usr(unix software resource): 与软件安装/执行有关</li>
<li>/var(variable): 与系统运作过程有关</li>
</ul>
<blockquote>
<p>从用户角度看，root 指系统的超级管理员身份，从目录角度看，root 指系统的根目录</p>
</blockquote>
<h2 id="根目录"><a href="#根目录" class="headerlink" title="根目录"></a>根目录</h2><p>所有的目录都是从根目录衍生出来。根目录与开机/还原/系统修复等动作有关，FHS 建议根目录不要放在非常大的分区内，且应用程序安装的软件最好也不要与根目录放在同一个分区内，内容越多的分区出错的几率也越高。以下是 FHS 定义的次目录：</p>
<hr>
<p>必须要存在的目录</p>
<table>
<thead>
<tr>
<th>档案</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>/bin</td>
<td>系统有多个放置可执行程序的目录，但 /bin 比较特殊，该目录放置的是<strong>「在单人维护模式下仍然能够执行的程序」</strong>，该目录的指令可以被 root 与一般用户执行，主要有 cat, chmod, chown, date, mv, mkdir, cp, bash 等常用指令</td>
</tr>
<tr>
<td>/boot</td>
<td>主要放置开机会使用的档案，包括 Linux 核心档案及开机选单与开机所需配置等</td>
</tr>
<tr>
<td>/dev</td>
<td>在 Linux 系统中，任何装置与外设都是以文件形态存在于这个目录中，存取该目录下的文件等同于存取某个设备，比较重要的有 /dev/null, /dev/zero, /dev/tty, /dev/loop, /dev/sd 等等</td>
</tr>
<tr>
<td>/etc</td>
<td>系统主要的<strong>⎡配置文件⎦</strong>几乎都放在该目录下，FHS 不建议放置任何可执行文件(binary)在这个目录下，例如 /etc/modprobe.d/, /etc/passwd, /etc/fstab, /etc/issue。同时，FHS 还建议：<ul><li>/etc/opt(必须): 这里放置 /opt 下第三方协议软件对应的配置信息</li><li> /etc/X11(建议): 与 X Window 有关的各种配置信息放置在这里，尤其是 xorg.conf 这个 X Server 的配置</li><li> /etc/sgml(建议): 与 SGML 格式有关的各项配置</li> <li>/etc/xml(建议): 与 XML 格式有关的各项配置</li></ul></td>
</tr>
<tr>
<td>/lib</td>
<td>系统的函数库非常多，<strong>「/lib 放置的是开机会用到以及在 /bin 或 /sbin 下的指令会调用的函数库」</strong>。另外，FHS 要求在该目录必须要存在: <ul><li>/lib/modules: 放置可插拔的核心相关模块(驱动程序等)</li></ul></td>
</tr>
<tr>
<td>/media</td>
<td>放置可移除的装置，包括软碟，光碟，DVD 等都暂时挂载于此。常见的有 /media/floppy, /media/cdrom 等</td>
</tr>
<tr>
<td>/mnt</td>
<td>暂时挂载额外装置的目录，早些时候该目录与 /media 用途相同，在有了 /media 之后，该目录就主要是暂时挂载用途了</td>
</tr>
<tr>
<td>/opt</td>
<td>第三方协议软件的目录(即非 Linux 发行版本自带的软件程序)，早些时候，这些软件多数放在 /usr/local 下</td>
</tr>
<tr>
<td>/run</td>
<td>早期的 FHS 规定系统开机后所产生的各项资讯应该要放置到 /var/run 目录下，新版的 FHS 则规范到 /run 底下。由于 /run 可以使用内存来模拟，因此具有更高的性能</td>
</tr>
<tr>
<td>/sbin</td>
<td>Linux 系统有非常多的指令用来设定系统环境，这些指令只有 root 才能使用，其他用户只能使用查询功能，/sbin 下包含了开机，修复，还原系统所需要的指令。某些服务器软件程序，一般放置在 /usr/sbin 中，而本机自行安装的软件产生的系统执行文件(system binary)，则放置在 /usr/local/sbin 中了，常见的指令包括: fdisk, fsck, ifconfig, mkfs 等等</td>
</tr>
<tr>
<td>/srv</td>
<td>srv 可视为「service」的缩写，某些网络服务启动后，需要取用的资料目录，例如 www，ftp 服务，如果这些服务不需要公开提供给互联网，那么建议放置到 /var/lib 下</td>
</tr>
<tr>
<td>/tmp</td>
<td>一般用户或正在执行的程序暂时放置档案的地方，任何用户都可以存取该目录，所以需要定期清理，FHS 建议在开机时应该要将 /tmp 下的资料都删除</td>
</tr>
<tr>
<td>/usr</td>
<td>见后文</td>
</tr>
<tr>
<td>/var</td>
<td>见后文</td>
</tr>
</tbody>
</table>
<p>FHS 建议可以存在的目录：</p>
<table>
<thead>
<tr>
<th>档案</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>/home</td>
<td>系统预设的用户 Home 目录，新用户的 Home 目录会默认创建在该目录下，其代号字符为：<ul><li><code>~</code>：当表当前用户的 Home 目录</li><li><code>~&lt;username&gt;</code>: 代表 username 的 Home 目录</li></ul></td>
</tr>
<tr>
<td>/lib/qual</td>
<td>存放与 /lib 不同格式的二进制函数库，例如 64 位 /lib64 函数库等</td>
</tr>
<tr>
<td>/root</td>
<td>系统管理员 root 的 Home 目录，如果进入单人维护模式而仅挂载根目录时，该目录就能够拥有 root 的 Home 目录，所以通常 root 用户的 Home 目录与根目录放置在同一个分区中</td>
</tr>
</tbody>
</table>
<h2 id="usr-的意义与内容"><a href="#usr-的意义与内容" class="headerlink" title="/usr 的意义与内容"></a>/usr 的意义与内容</h2><p>首先 <code>usr</code> 是 Unix Software Resource 的缩写，表示<strong>「操作系统软件资源」</strong>所放置的目录，而不是 User 的缩写。FHS 建议所有软件开发者应该将他们的资料分别合理的放置到该目录下的次目录中，而不要自行创建独立的目录。Linux 发行版本的所有内置软件都会放到 /usr 下，系统安装完毕后该目录会占用最多的硬盘容量，/usr 次目录的建议有：</p>
<hr>
<p>FHS 要求必须要存在的目录</p>
<table>
<thead>
<tr>
<th>档案</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>/usr/bin/</td>
<td>一般用户能够使用的指令都放在这里，目前 CentOS 7 已经将全部的用户指令放置于此，而使用链接将 /bin 链接至此，意即，/usr/bin 与 /bin 是一摸一样了。另外，FHS 要求在此目录下不应该有子目录。</td>
</tr>
<tr>
<td>/usr/lib/</td>
<td>基本与 /lib 相同，/lib 就是链接到此目录中的</td>
</tr>
<tr>
<td>/usr/local/</td>
<td>系统管理员在本机自行下载安装的软件建议安装到此目录</td>
</tr>
<tr>
<td>/usr/sbin/</td>
<td>非系统正常运行所需要的系统指令，目前 /sbin 链接到此目录中</td>
</tr>
<tr>
<td>/usr/share/</td>
<td>主要放置只读架构的资料档案，包括共享文件</td>
</tr>
</tbody>
</table>
<p>FHS 建议可以存在的目录</p>
<table>
<thead>
<tr>
<th>档案</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>/usr/games/</td>
<td>与游戏相关的资料目录</td>
</tr>
<tr>
<td>/usr/include</td>
</tr>
<tr>
<td>/usr/libexec</td>
<td>某些不会被一般用户常用的执行文件或脚本会放置在该目录</td>
</tr>
<tr>
<td>/usr/lib<qual></qual></td>
<td>与 /lib/<qual> 功能相同，/lib<qual> 就是链接到此目录</qual></qual></td>
</tr>
<tr>
<td>/usr/src</td>
<td>源代码放置目录</td>
</tr>
</tbody>
</table>
<h2 id="var-的意义与内容"><a href="#var-的意义与内容" class="headerlink" title="/var 的意义与内容"></a>/var 的意义与内容</h2><p>/var 会在系统运行过程中渐渐产生内容，包括缓存，日志及某些软件运行所产生的数据，例如 MySQL 的数据文件等，常见的次目录有：<br>FHS 要求必须要存在的目录</p>
<table>
<thead>
<tr>
<th>档案</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>/var/cache/</td>
<td>应用程序运行过程中产生的暂存数据</td>
</tr>
<tr>
<td>/var/lib/</td>
<td>应用程序运行过程中，需要使用的资料档案放置的目录，此目录下每个软件应该有自己的目录，举例来说，MySQL 的资料库应该放置到 /var/lib/mysql。</td>
</tr>
<tr>
<td>/var/lock/</td>
<td>用于对某些装置或档案资源进行排他加锁，目前此目录已移动到 /run/lock</td>
</tr>
<tr>
<td>/var/log/</td>
<td>至关重要，放置了程序运行所产生的日志文件</td>
</tr>
<tr>
<td>/var/mail/</td>
<td>放置个人电子邮件的目录，已移动到 /var/spool/mail/ 目录中</td>
</tr>
<tr>
<td>/var/run/</td>
<td>某些程序或服务启动后，会将他们的 PID 放置在这个目录下。与 /run 相同，链接到 /run</td>
</tr>
<tr>
<td>/var/spool/</td>
<td>该目录通常放置队列数据，crontab 文件就放置在 /var/spool/cron/ 目录中</td>
</tr>
</tbody>
</table>
<p>以 CentOS 7 为例，比较其目录结构与 FHS 规定的内容的差异：</p>
<ul>
<li>/bin –&gt; /usr/bin</li>
<li>/sbin –&gt; /usr/sbin</li>
<li>/lib –&gt; /usr/lib</li>
<li>/lib64 –&gt; /usr/lib64</li>
<li>/var/lock –&gt; /run/lock</li>
<li>/var/run –&gt; /run</li>
</ul>
<p>主要是将许多原本在根目录下 <code>/</code> 的资料移到了 <code>/usr</code> 中，然后设置了链接</p>
<img src="/linux-directory-configuration/dir_tree.jpg" title="目录树">
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://berdypango.github.io/linux-document-preset-and-hidden-privilage/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Frost He">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FrostHe.Handbook">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/linux-document-preset-and-hidden-privilage/" itemprop="url">Linux 基础 - 预设权限(umask)，隐藏权限(chattr/lsattr)和特殊权限(SUID/SGID/SBIT)</a></h1>
        

        <div class="post-meta">
          
          <span class="post-time">
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  1,438
                </span>
              

              

              
            </div>
          

          
              <div class="post-description">
                  本文介绍了 Linux 系统与档案目录预设和隐藏权限相关的指令
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="预设权限"><a href="#预设权限" class="headerlink" title="预设权限"></a>预设权限</h1><h2 id="umask"><a href="#umask" class="headerlink" title="umask"></a>umask</h2><p><code>umask</code> 表示当前用户建立档案和目录时的预设权限。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">umask</span></span><br><span class="line">0022</span><br></pre></td></tr></table></figure></p>
<p>umask 针对档案和目录的权限是不同的，对于新的档案，是不包括执行(x)权限的，而目录则包括所有权限，返回的数字是指应该减去的分数，进行反向计算，0022 表示，新的档案的权限为 <code>-rwxr-xr-x</code>。例如:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir <span class="built_in">test</span></span><br><span class="line">$ <span class="built_in">cd</span> <span class="built_in">test</span></span><br><span class="line">$ <span class="built_in">umask</span> 0022</span><br><span class="line">$ touch test_file</span><br><span class="line">$ mkdir test_dir</span><br><span class="line">$ ls -Al</span><br><span class="line"></span><br><span class="line">drwxr-xr-x 0 Pango Pango 512 May 14 23:23 test_dir</span><br><span class="line">-rw-r--r-- 1 Pango Pango   0 May 14 23:23 test_file</span><br></pre></td></tr></table></figure></p>
<p>umask -S 加上 -S 参数则显示正向计算的结果<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">umask</span> -S</span><br><span class="line">u=rwx, g=rx,o=rx</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>0022 表示，<code>user</code> 拥有全部权限，而 <code>group</code> 和 <code>others</code> 则被减去了 <code>write</code> 权限。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">umask</span> 002 <span class="comment"># 直接通过后接数字来设置 umask 的值。</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在架设 <code>SAMBA Server</code> 或 <code>FTP Server</code> 时，<code>umask</code> 的值涉及到你的用户能否对新建的档案进行进一步操作的问题。</p>
</blockquote>
<p>root 用户的 <code>umask</code> 是 022，一般用户则是 002，这是出于安全的考虑，关于 umask 预设设定可以参考 <code>/etc/bashrc</code> 这个文件，不过不建议修改该档案。</p>
<h1 id="隐藏权限"><a href="#隐藏权限" class="headerlink" title="隐藏权限"></a>隐藏权限</h1><h2 id="chattr"><a href="#chattr" class="headerlink" title="chattr"></a>chattr</h2><p>修改档案或目录的隐藏属性，<code>change attribute</code>。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chattr [+-=][ASacdistu] 档案或目录名称</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>+</code>: 追加一个特殊参数</li>
<li><code>-</code>: 移除一个特殊参数</li>
<li><code>=</code>: 设置特殊参数</li>
<li><code>A</code>: 当设定了该参数后，当读取此档案或目录时，其 <code>atime</code> 不会被修改</li>
<li><code>S</code>: 一般的档案是异步写入磁盘的，如果设置了 <code>S</code> 参数，则对档案进行的任何修改，都会以同步方式写入磁盘</li>
<li><code>a</code>: 该档案只能新增资料，而不能删除也不能修改资料，只有 root 用户能设定该属性</li>
<li><code>c</code>: 自动压缩档案，读取时自动解压缩，存储时先压缩再存储</li>
<li><code>d</code>: 当 dump 程序执行的时候，被设定为 <code>d</code> 属性的档案不参与备份。</li>
<li><code>i</code>: 使一个档案「无法被删除，修改，改名，设置连接」，只有 root 用户可以设置此属性。</li>
<li><code>s</code>: 硬删除，无法进行磁盘复原</li>
<li><code>u</code>: 与 <code>s</code> 相反，如果该档案被删除，可以使用相关工具复原。</li>
</ul>
<p>以上属性中最重要的当属 <code>a</code> 和 <code>i</code> 了。<code>+a</code> 常用于对某些非常重要的档案的安全控制，而 <code>+i</code> 则常用于日志档案。</p>
<h2 id="lsattr"><a href="#lsattr" class="headerlink" title="lsattr"></a>lsattr</h2><p>显示档案或目录的隐藏属性，<code>list attributes</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ lsattr -[adR] 档案或目录</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>-a</code>: 将隐藏档案的属性也显示出来</li>
<li><code>-d</code>: 如果连接的是目录，仅列出目录本身的属性而非目录内的档案</li>
<li><code>-R</code>: 递归显示</li>
</ul>
<h1 id="特殊权限"><a href="#特殊权限" class="headerlink" title="特殊权限"></a>特殊权限</h1><h2 id="SUID"><a href="#SUID" class="headerlink" title="SUID"></a>SUID</h2><p>Set UID 的缩写，该权限有以下限制和功能:</p>
<ul>
<li>SUID 仅对二进制程序有效</li>
<li>执行者对于该程序需要有 <code>x</code> 的执行权限</li>
<li>SUID 仅在执行该程序的过程中有效</li>
<li>执行者将获得该程序拥有者的权限。</li>
</ul>
<p>例如，<code>/etc/shadow</code> 档案保存了所有用户的密码，该文档的权限为 <code>--------- l root root</code>，意即该档案仅 <code>root</code> 用户可以强制写入，那么一般用户在执行 <code>passwd</code> 命令时其实是可以修改自己的密码的，这就是 SUID 的功能，即:</p>
<ol>
<li>一般用户对 <code>/usr/bin/passwd</code> 程序具有 <code>x</code> 权限</li>
<li><code>shadow</code> 档案拥有者是 <code>root</code> 用户</li>
<li>一般用户执行 <code>passwd</code> 的过程中，会「暂时」获得 <code>root</code> 的权限</li>
<li><code>/etc/shadow</code> 就能被一般用户执行的 <code>passwd</code> 修改。</li>
</ol>
<blockquote>
<p>SUID 对目录是无效的，其以 <code>s</code> 取代「拥有者用户」一栏的 <code>x</code> 权限。</p>
</blockquote>
<h2 id="SGID"><a href="#SGID" class="headerlink" title="SGID"></a>SGID</h2><p>当 <code>s</code> 出现在群组权限的执行权限上时，则称为 SGID。SGID 有如下功能:</p>
<ul>
<li>SGID 对二进制程序有用</li>
<li>使用该程序的用户必须对该程序有 <code>x</code> 权限</li>
<li>用户在执行过程中会获得该程序群组的权限</li>
</ul>
<p>当 SGIP 作用于目录时，将:</p>
<ul>
<li>用户对此目录具有 <code>r</code> 和 <code>x</code> 的权限，该用户能够进入此目录</li>
<li>用户在此目录下的有效群组将会变成该目录的群组<br>若用户在目录下有 <code>w</code> 权限，则用户新建的档案，该档案所属的群组与目录所属的群组相同。</li>
</ul>
<blockquote>
<p>当设置 SGID 后，将以 <code>s</code> 取代在「群组」权限一栏的 <code>x</code> 权限。</p>
</blockquote>
<h2 id="Sticky-Bit"><a href="#Sticky-Bit" class="headerlink" title="Sticky Bit"></a>Sticky Bit</h2><p>目前只针对目录有效，其作用是，用户对某个目录具有 <code>w</code> 和 <code>x</code> 权限时，在该目录下创建档案或目录后，仅用户自己与 <code>root</code> 才能删除这些档案或目录。该功能让多个用户在同一目录下管理与自己相关的文件。</p>
<blockquote>
<p>对目录设置 SBIT 后，将以 <code>t</code> 取代「其他用户」权限的 <code>x</code> 权限。</p>
</blockquote>
<h2 id="设定-SUID-SGID-SBIT"><a href="#设定-SUID-SGID-SBIT" class="headerlink" title="设定 SUID/SGID/SBIT"></a>设定 SUID/SGID/SBIT</h2><p>之前的权限设定是只有 3 个数字，加上 SUID/SGID/SBIT 之后变成了 4 个数字，执行 <code>chmod 4755 filename</code> 来为该文件新增特殊权限。<code>4755</code> 的字符串表示为 <code>-rwsr-xr-x</code>。</p>
<p><code>s</code> 与 <code>t</code> 都是取代 <code>x</code> 这个权限，但当权限为 <code>7666</code> 时，由于在「用户」，「群组」和「其他用户」三栏都不包含「执行(x)」权限，字符串将以大写 <code>S</code> 和 大写 <code>T</code> 来表示，以示该权限实际上无效。例如:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ chmod 7666 <span class="built_in">test</span>; ls -l <span class="built_in">test</span> </span><br><span class="line">-rw S rw S rw T 1 root root 0 Jun 16 02:53 <span class="built_in">test</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>除了数字法赋值权限之外，还可以使用 <code>u+s</code> 追加 <code>SUID</code> 权限、<code>g+s</code> 追加 <code>SGID</code> 权限和 <code>o+t</code> 追加 <code>SBIT</code> 权限。</p>
</blockquote>
<h2 id="file-观察档案类型"><a href="#file-观察档案类型" class="headerlink" title="file(观察档案类型)"></a>file(观察档案类型)</h2><p><code>file</code> 指令用于判断档案的类型，例如:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ file ~/.bashrc</span><br><span class="line">/root/.bashrc: ASCII text</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://berdypango.github.io/linux-profile-and-privilege/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Frost He">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FrostHe.Handbook">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/linux-profile-and-privilege/" itemprop="url">Linux 基础 - 档案与权限(chgrp/chown/chmod)</a></h1>
        

        <div class="post-meta">
          
          <span class="post-time">
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  1,978
                </span>
              

              

              
            </div>
          

          
              <div class="post-description">
                  本文记录了 Linux 系统下档案是什么，档案是如何组织的，包括权限的设定与划分
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>参考资料: <a href="http://linux.vbird.org/linux_basic/0210filepermission.php#filepermission_perm" target="_blank" rel="noopener">http://linux.vbird.org/linux_basic/0210filepermission.php#filepermission_perm</a></p>
<p>本文大纲:<br><!-- TOC --></p>
<ul>
<li><a href="#%E4%BF%AE%E6%94%B9%E6%A1%A3%E6%A1%88%E5%B1%9E%E6%80%A7%E5%8F%8A%E6%9D%83%E9%99%90">修改档案属性及权限</a><ul>
<li><a href="#%E6%9B%B4%E6%94%B9%E7%BE%A4%E7%BB%84">更改群组</a></li>
<li><a href="#%E6%9B%B4%E6%94%B9%E6%A1%A3%E6%A1%88%E6%8B%A5%E6%9C%89%E8%80%85">更改档案拥有者</a></li>
<li><a href="#%E6%9B%B4%E6%94%B9%E6%9D%83%E9%99%90">更改权限</a></li>
</ul>
</li>
<li><a href="#%E6%9D%83%E9%99%90%E7%9A%84%E6%84%8F%E4%B9%89">权限的意义</a></li>
</ul>
<!-- /TOC -->
<p>当执行 <code>ls -al</code> 后，当前目录下所有档案的详情被列出</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dr-xr-xr-x. 17 root root 4096 May 4 17:56 ..</span><br><span class="line">-rw-------. 1 root root 1816 May 4 17:57 anaconda-ks.cfg</span><br></pre></td></tr></table></figure>
<ul>
<li>第 1 列用一组字符组合来表示其类别和属性，该字符串的第一位标识该档案的类别，详情见后文，而后连续 9 个字符，每 3 个一组，表示<strong>该权限的拥有者</strong>，<strong>同群组的其他用户</strong>和<strong>其他用户</strong>对该档案的权限，例如 <code>-rwxr-xr--</code> 表示一个档案的权限为：<ul>
<li>该档案为文件</li>
<li>拥有者对其拥有读取，修改和执行权限</li>
<li>同一群组中的其他用户对其拥有读取和执行权限</li>
<li>其他用户对其仅有读取权限</li>
</ul>
</li>
<li>第 2 列表示有多少不同的档案名链接到该档案的 i-node，每个档案将会将它的权限与属性记录到档案系统的 i-node 中</li>
<li>第 3 列表示档案的拥有者用户</li>
<li>第 4 列表示该档案所属第群组</li>
<li>第 5 列表示该档案所占用第磁盘空间，预设单位为 bytes</li>
<li>第 6 列表示该档案的创建日期或修改日期</li>
<li>第 7 列为档案名</li>
</ul>
<h1 id="修改档案属性及权限"><a href="#修改档案属性及权限" class="headerlink" title="修改档案属性及权限"></a>修改档案属性及权限</h1><h2 id="更改群组"><a href="#更改群组" class="headerlink" title="更改群组"></a>更改群组</h2><p>chgrp: 该指令为 change group 的缩写，目标群组必须在 <code>/etc/group</code> 中存在，使用 <code>-R</code> 指定递归改变父级目录下的群组:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sudo</span> chgrp &lt;target-group&gt; -R filename/directory</span><br></pre></td></tr></table></figure></p>
<h2 id="更改档案拥有者"><a href="#更改档案拥有者" class="headerlink" title="更改档案拥有者"></a>更改档案拥有者</h2><p><code>chown</code> 为 change owner 的缩写，目标用户必须在 <code>/etc/passwd</code> 中存在，可使用 <code>-R</code> 选项指定递归更改选项。</p>
<p>该命令还可以顺便修改群组，例如:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sudo</span> chown user1:group1 filename</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>可使用 <code>.</code> 或者 <code>:</code> 来隔开用户名和群组名，但如果在用户名中包含 <code>.</code> 字符，则容易造成混淆，所以一般建议使用 <code>:</code> 来隔开用户名和群组。</p>
</blockquote>
<p><code>chown</code> 也可通过 <code>.</code> 直接更改群组,如:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sudo</span> chown .group1 filename</span><br></pre></td></tr></table></figure></p>
<p>更改群组一个常见的应用为，当通过 <code>cp</code> 复制一个档案时，也会同时复制命令执行者的属性与权限，此时更改属性和权限就显得尤其必要了</p>
<h2 id="更改权限"><a href="#更改权限" class="headerlink" title="更改权限"></a>更改权限</h2><p>chmod 为更改档案权限的指令，默认情况下，可使用字符来为三种角色指定权限，首先指定角色: </p>
<ul>
<li><code>u</code>: 代表拥有者，即 users</li>
<li><code>g</code>: 代表拥有者群组，即 group</li>
<li><code>o</code>: 代表其他，即 others</li>
<li><code>a</code>: 代表所有，即 all</li>
</ul>
<p>然后使用以下连字符修改权限: </p>
<ul>
<li>=: 代表赋值，指定</li>
<li>+: 代表增加权限</li>
<li>-: 代表移除权限</li>
</ul>
<p>例如 <code>chmod u=rwx,go=r-x filename</code> 表示设定档案的权限为 <code>rwxr-xr-x</code>，或 <code>chmod g+w filename</code> 在不知道原来权限的基础上增加群组的写入权限。</p>
<p><code>chmod</code> 可以使用数字或字符来更改档案的权限，数字代表的含义为: </p>
<ul>
<li>r: 4</li>
<li>w: 2</li>
<li>x: 1</li>
<li>-: -</li>
</ul>
<p>每种身份的权限由三者数字累加起来得到一个数字，例如 <code>chmod 740 filename</code> 表示拥有者具有 <code>rwx</code> 权限，同群组其他用户具有 <code>r--</code> 权限，其他用户则具有 <code>---</code> 权限。</p>
<h1 id="权限的意义"><a href="#权限的意义" class="headerlink" title="权限的意义"></a>权限的意义</h1><p>权限分为三种：</p>
<ul>
<li>r: 读取权限<ul>
<li>针对文件：读取文件的实际内容</li>
<li>针对目录：读取目录结构清单，例如使用 ls 指令</li>
</ul>
</li>
<li>w: 写入权限<ul>
<li>针对文件: 可编辑，新增或修改文件的内容，但不含<strong>删除</strong>操作</li>
<li>针对目录: 具有对改动该目录结构的权限，包含：<ul>
<li>新建文件与目录</li>
<li>删除已经存在的文件或目录(不受被删除文件和目录的权限限制)</li>
<li>重命名文件或目录</li>
<li>移动文件或目录</li>
</ul>
</li>
</ul>
</li>
<li>x: 执行权限<ul>
<li>针对文件: 执行文件(如果该文件可执行)</li>
<li>针对目录: 指示用户能否进入该目录，如执行 cd 指令<br>表格形式如下：</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>元件</th>
<th>内容</th>
<th>迭代物件</th>
<th>r</th>
<th>w</th>
<th>x</th>
</tr>
</thead>
<tbody>
<tr>
<td>文件</td>
<td>详细资料</td>
<td>文件夹文件</td>
<td>读取文件内容</td>
<td>修改文件内容</td>
<td>执行文件内容</td>
</tr>
<tr>
<td>目录</td>
<td>目录名称</td>
<td>可分类抽屉</td>
<td>读取目录内容</td>
<td>修改目录结构</td>
<td>进入该目录</td>
</tr>
</tbody>
</table>
<p>除了文件和目录两种档案之外，还有其他一些档案类型：</p>
<ul>
<li>常规文件(regular file)，常规文件档案，权限的第一栏为 <code>-</code>，例如 <code>-rwxrwxrwx</code>，常规文件又可分为三类：<ul>
<li>文本文件: 可以直接读取的内如，几乎所有的配置型文件都属于这一类，可执行 <code>cat &lt;filename&gt;</code> 来查看文件内容</li>
<li>二进制文件: Linux 系统仅认知且可执行二进制文件(binary file)，script 脚本及批处理不算，例如，当执行 <code>cat</code> 指令时，<code>cat</code> 就是一个 <code>binary file</code>。</li>
<li>数据文件(data): 供不同的程序自己使用的特殊格式的文件，例如，当使用 Linux 登入时，系统会将登录日志记录在 <code>/var/log/wtmp</code> 文件内，但该文件是一个数据文件，只能通过 <code>last</code> 指令读出来，若使用 <code>cat</code> 读取该文件会显示乱码</li>
</ul>
</li>
<li>目录(directory): 目录档案，权限第一栏为 <code>d</code>，例如 <code>drwxrwxrwx</code></li>
<li>链接(link): 类似于 <code>windows</code> 系统的快捷方式，第一栏为 <code>l</code>，例如 <code>lrwxrwxrwx</code><ul>
<li>软链接: 见 inode</li>
<li>硬链接: 见 inode</li>
</ul>
</li>
<li>设备与装置档案: 系统周边及存储等相关的档案，通常集中在 <code>/dev</code> 目录下，他们又分为：<ul>
<li>区块(block)设备档案: 存储资料，提供系统随机存储的设备，硬盘与软盘都属于这类，第一栏为 <code>b</code>，可查阅 <code>/dev/sda</code> 下的内容。</li>
<li>字符(character)设备档: 亦即外设，如键盘，鼠标等，这些设备的特点是<strong>「一次性读取」</strong>，不能截断输出，例如，不能让鼠标<strong>「跳跃到」</strong>另外一个地方，而是<strong>「连续滑动」</strong>到另一个地方。权限第一栏为 <code>c</code></li>
</ul>
</li>
<li>数据接口档案(sockets): 主要用于网络数据通信，第一栏为 <code>s</code>，该类型通常位于 <code>/run</code> 或 <code>/tmp</code> 这些目录中</li>
<li>数据传输接口档案(FIFO, pipe): FIFO(first in first out)也是一种特殊的档案类型，它是为了解决多个解决同时存取一个文件所造成的错误问题。第一栏为 <code>p</code></li>
</ul>
<blockquote>
<p>设备是系统文件，最好不好随意修改。</p>
</blockquote>
<p>windows 系统中可执行文件通常带有 <code>.exe</code> <code>.bat</code> 等扩展名，而 <code>Linux</code> 系统中基本没有所谓的「扩展名」概念，一个 <code>Linux</code> 文件能否被执行与它的权限栏 10 个属性有关，与其文件名或扩展名没有任何关系，只要其权限中带有 <code>x</code> 属性，该文件就可以被执行。</p>
<p>为了保持可读性，通常还是会在文件末尾加上扩展名以让用户了解该文件是什么，常用的扩展名有：</p>
<ul>
<li>*.sh: 脚本或批处理文件，因为这些文件基于 <code>shell</code> 写出，所以为其添加了 <code>.sh</code> 扩展名</li>
<li><em>Z, </em>.tar, <em>.tar.gz, </em>.zip, *.tgz: 压缩包文件，由不同的压缩程序如 gunzip, tar 等输出，所以根据不同的程序命名不同的扩展名</li>
<li><em>.html, </em>.php: php 语法写成的网页文件等</li>
</ul>
<p>总之，<code>Linux</code> 的文件名仅仅是为了让用户了解其用途而已，能否执行取决于文件权限，如果 <code>/bin/ls</code> 文件的可执行权限被移除，那么 <code>ls</code> 便无法使用了。</p>
<p>关于档案的几点注意：</p>
<ul>
<li>单一文件或目录文件名长度不超过 256 字节</li>
<li>名称中不得包含 * ? &gt; &lt; ; &amp; ! [ ] | \ ‘ “ ` ( ) { } 等特殊字符</li>
<li>第一个字符为 <code>.</code> 时，表示该档案为隐藏档案</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://berdypango.github.io/linux-account-and-group/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Frost He">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FrostHe.Handbook">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/linux-account-and-group/" itemprop="url">Linux 基础 - 用户和群组</a></h1>
        

        <div class="post-meta">
          
          <span class="post-time">
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  4,460
                </span>
              

              

              
            </div>
          

          
              <div class="post-description">
                  本文主要记录了 Linux 系统下与用户何群组相关的指令和操作指南
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>参考资料：</p>
<ul>
<li><a href="http://linux.vbird.org/linux_basic/0410accountmanager.php" target="_blank" rel="noopener">http://linux.vbird.org/linux_basic/0410accountmanager.php</a></li>
</ul>
<p>本文大纲:<br><!-- TOC --></p>
<ul>
<li><a href="#%E7%94%A8%E6%88%B7%E5%B8%90%E5%8F%B7%E7%AE%A1%E7%90%86">用户帐号管理</a><ul>
<li><a href="#%E6%96%B0%E5%BB%BA%E7%94%A8%E6%88%B7%E5%B8%90%E5%8F%B7---useradd">新建用户帐号 - useradd</a></li>
<li><a href="#%E8%AE%BE%E7%BD%AE%E5%B8%90%E5%8F%B7%E5%AF%86%E7%A0%81---passwd">设置帐号密码 - passwd</a></li>
<li><a href="#%E7%AE%A1%E7%90%86%E5%B8%90%E5%8F%B7%E5%AF%86%E7%A0%81%E7%AD%96%E7%95%A5---chage">管理帐号密码策略 - chage</a></li>
<li><a href="#%E4%BF%AE%E6%94%B9%E7%94%A8%E6%88%B7%E5%B8%90%E5%8F%B7%E4%BF%A1%E6%81%AF---usermod">修改用户帐号信息 - usermod</a></li>
<li><a href="#%E5%88%A0%E9%99%A4%E7%94%A8%E6%88%B7%E5%B8%90%E5%8F%B7---userdel">删除用户帐号 - userdel</a></li>
<li><a href="#%E7%94%A8%E6%88%B7%E7%AB%AF%E6%8C%87%E4%BB%A4---id-finger-chfn-chsh">用户端指令 - id, finger, chfn, chsh</a></li>
</ul>
</li>
<li><a href="#%E7%BE%A4%E7%BB%84%E7%AE%A1%E7%90%86">群组管理</a><ul>
<li><a href="#%E6%96%B0%E5%A2%9E%E7%BE%A4%E7%BB%84---groupadd">新增群组 - groupadd</a></li>
<li><a href="#%E4%BF%AE%E6%94%B9%E7%BE%A4%E7%BB%84---groupmod">修改群组 - groupmod</a></li>
<li><a href="#%E5%88%A0%E9%99%A4%E7%BE%A4%E7%BB%84---groupdel">删除群组 - groupdel</a></li>
<li><a href="#%E7%BE%A4%E7%BB%84%E7%AE%A1%E7%90%86%E5%91%98---gpasswd">群组管理员 - gpasswd</a></li>
<li><a href="#%E5%88%9D%E5%A7%8B%E7%BE%A4%E7%BB%84%E6%AC%A1%E8%A6%81%E7%BE%A4%E7%BB%84%E5%92%8C%E6%9C%89%E6%95%88%E7%BE%A4%E7%BB%84">初始群组，次要群组和有效群组</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->
<p>Linux 使用文件及配置相应的权限来存储用户帐号和群组信息，在成功创建好用户帐号之后，以下几处文件会发生相应的改变</p>
<ul>
<li>/etc/passwd: Linux 管理用户帐号的数据库</li>
<li>/etc/shadow: Linux 管理用户帐号密码配置的数据库</li>
<li>/etc/group: Linux 管理群组的数据库</li>
<li>/etc/gshadow: Linux 管理群组密码配置的数据库</li>
</ul>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/linux-account-and-group/" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://berdypango.github.io/linux-background-knowledge/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Frost He">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FrostHe.Handbook">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/linux-background-knowledge/" itemprop="url">Linux 基础 - 磁盘分区</a></h1>
        

        <div class="post-meta">
          
          <span class="post-time">
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  1,604
                </span>
              

              

              
            </div>
          

          
              <div class="post-description">
                  本文简要介绍了 Linux 系统的一些基础知识
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>参考资料: </p>
<ul>
<li><a href="http://linux.vbird.org/linux_basic/0130designlinux.php" target="_blank" rel="noopener">主机规划与磁盘分区</a></li>
</ul>
<p>Linux 所有的设备都以档案的形式参与到目录树中，包括磁盘分区，通常，SATA/USB 都是以 SCSI 模块驱动的，所以这些接口在系统中相当的档案名出现。</p>
<ul>
<li>物理磁盘以 <code>/dev/sd[ad]</code> 形式在档案系统中出现，如一台电脑有 6 个 SATA 口，第一和第五分别插入了硬盘，此时两者以 <code>/dev/sda</code> 和 <code>/dev/sdb</code> 在档案系统中呈现</li>
<li>虚拟化之后的磁盘以 <code>/dev/vd[ad]</code> 形式在档案系统中出现</li>
</ul>
<h1 id="硬盘和分区方式"><a href="#硬盘和分区方式" class="headerlink" title="硬盘和分区方式"></a>硬盘和分区方式</h1><p>物理硬盘以磁盘、机械臂、磁碟头与主轴马达组成，资料都写入在磁盘上，磁盘又分为「磁区(Sector)」与「磁轨(Track)」两种单位，其中磁区的物理量有两种大小: 512 字节和 4K 字节。</p>
<img src="/linux-background-knowledge/disk-structure.jpg" title="硬盘结构">
<h2 id="MSDOS-MBR"><a href="#MSDOS-MBR" class="headerlink" title="MSDOS(MBR)"></a>MSDOS(MBR)</h2><p>Master Boot Record，主开机记录，早期的 Windows 系统对硬盘进行分区的方式，其以第一磁区(512 字节)记录</p>
<ul>
<li>「开机管理程序」: 安装开机管理程序的地方，446 字节</li>
<li>「分区表」: 记录硬盘分区的状态，64 字节</li>
</ul>
<img src="/linux-background-knowledge/partition-1.png" title="MBR">
<p>由于分区表仅 64 字节大小，所以一块硬盘最多只能包含 4 个分区的信息，这 4 个分区信息被称为「主要(Primary)分区」或「扩展分区(Extended)」，且分区的最小存储单位为「磁柱(cylinder)」。</p>
<p>每块硬盘的 MBR 区域仅允许一个扩展分区，而该扩展分区主要用于划出更多的「逻辑分区」，逻辑分区可使用的磁柱区域被划定在扩展分区边界内，如下图所示:<br><img src="/linux-background-knowledge/partition-2.png"><br>这样，在 Linix 系统中的档案名为:</p>
<ul>
<li>P1:/dev/sda1</li>
<li>P2:/dev/sda2</li>
<li>L1:/dev/sda5</li>
<li>L2:/dev/sda6</li>
<li>L3:/dev/sda7</li>
<li>L4:/dev/sda8</li>
<li>L5:/dev/sda9</li>
</ul>
<p>系统会保留 MBR 的 4 个分区编号，所以逻辑分区以 <code>sda5</code> 开始。由于分区是以「磁柱」为单位的连续磁盘空间，所以分区时尤其要注意主分区与逻辑分区的划分，例如，主分区 P2 与逻辑分区 L1 是无法合并的。而 L1 和 L2 则是可以合并的。</p>
<p>由于每个分区表仅有 16 字节，因此系统无法识别硬盘空间在 2.2TB 以上的硬盘。而每当操作系统需要读写磁盘，都要从 MBR 的分区表中读取参考信息，一旦该硬盘的第一个磁区，即 MBR 损坏了，那么整个硬盘就无法使用了。鉴于这诸多的限制，后来有了 GPT 分区表。</p>
<h2 id="GPT-Guid-partition-table"><a href="#GPT-Guid-partition-table" class="headerlink" title="GPT(Guid partition table)"></a>GPT(Guid partition table)</h2><p>GPT 已经支持 4K 磁区，但为了兼容以往的 512 字节磁区。GPT 使用「逻辑区块地址(Logic Block Address)」来划分整个硬盘，而 LBA 预设大小为 512 字节，从 0 开始编号，即第一个 LBA 磁区为 LBA0。GPT 磁盘分区的最小物理单位为磁区。</p>
<p>GPT 使用前 34 个 LBA 磁区来记录分区信息，这与 MBR 将所有分区信息记录在第一个磁区上不同，且硬盘的最后 33 个 LBA 磁区作为备份，结构如下:<br><img src="/linux-background-knowledge/gpt_partition_1.jpg" title="GPT 分区"><br>从上图可以看到:</p>
<ul>
<li>LBA0(MBR 兼容磁区): 该磁区为了与 MBR 兼容，也将其分为「开机管理程序(446 字节)」和分区表(64 字节)两部分，而这里的分区表仅存放一个特殊的分区，以表示此磁盘为 GPT 格式。</li>
<li>LBA1(GPT表头记录): 该磁区记录了分区表的位置与大小与备份分区表的磁区位置。</li>
<li>LBA2 ~ 33(实际记录分区信息): 从 LBA2 开始，每个 LBA 都可以记录 4 个分区记录，所以默认情况下，最多可以支持 4 * 32 个分区，而每个 LBA 磁区容量为 512 字节，因此每个分区信息可用 128 字节空间(不同于 MBR 16 字节)，这可以识别高达 1ZB 的硬盘容量。</li>
</ul>
<p>GPT 分区表也没有了主分区，扩展分区和逻辑分区的概念，每个分区都独立存在。然而并不是所有操作系统都能够读取 GPT 的硬盘分区格式，这取决于「开机引导程序(BIOS 和 UEFI)」。</p>
<h2 id="BIOS"><a href="#BIOS" class="headerlink" title="BIOS"></a>BIOS</h2><p>没有软件程序的硬件是没有用的，操作系统的诞生是为了更好的调配各个硬件资源，但操作系统并不是电脑执行的第一个软件程序，主板首先加载的是写入主板上的开机引导程序，又称固件。</p>
<p>电脑开机后</p>
<ol>
<li>主板首先启动固件的 BIOS</li>
<li>BIOS 分析电脑有哪些设备，找到其第一个磁区的 MBR 位置，然后读取 446 字节的「开机管理程序」，然后 BIOS 将退出，全权交给开机管理程序(Boot Loader)</li>
<li>Boot Loader 是由操作系统提供的，因此它认识操作系统提供的文件系统以及启动操作系统所需的核心文件的位置，一旦操作系统的核心文件启动，后续的工作就交给操作系统了。</li>
</ol>
<p>BIOS 和 MBR 都是硬件支持的功能，而 Boot Loader 则是操作系统安装在 MBR 上的一个软件程序，Boot Loader 提供了:</p>
<ul>
<li>提供选单，用户可以选择不同的开机项目</li>
<li>加载核心文件，启动操作系统</li>
<li>转交给其他 Loader</li>
</ul>
<h2 id="UEFI-Unified-Extensible-Firmware-Interface"><a href="#UEFI-Unified-Extensible-Firmware-Interface" class="headerlink" title="UEFI(Unified Extensible Firmware Interface)"></a>UEFI(Unified Extensible Firmware Interface)</h2><p>UEFI 使用 C 语言，比起使用组合语言的传统 BIOS 更容易开发，同时支持了更多的功能，UEFI 更像是一个小型的操作系统，UEFI 大多用来作为操作系统启动之前的硬件检测、开机管理、软件设置等目的，一旦操作系统启动，UEFI 就会停止工作。更重要的是，UEFI 可以直接取得 GPT 分区表，并同时兼容 MBR 分区表。</p>
<h1 id="挂载-mount"><a href="#挂载-mount" class="headerlink" title="挂载(mount)"></a>挂载(mount)</h1><p>Linux 系统内的所有资料都是以文件的形态呈现的，因此整个 Linux 系统就是一个目录树，以根目录为根向下延伸。而文件和目录其实是放置在磁盘分区中，<strong>「挂载(mount)」</strong>就是目录树与磁盘分区的粘合剂。</p>
<p>挂载是利用一个目录作为入口点，将磁盘分区的资料放在该目录下。进入该目录，就进入了该磁盘分区，如下图所示:<br><img src="/linux-background-knowledge/dir_3.png" title="挂载示意图"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Frost He</p>
              <p class="site-description motion-element" itemprop="description">Stay hungry, stay foolish</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">53</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">21</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">37</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2015 &mdash; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Frost He</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>








        




  <script type="text/javascript">
    (function() {
      var hm = document.createElement("script");
      hm.src = "//tajs.qq.com/stats?sId=65458438";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>




















  
  
    <script type="text/javascript" src="//jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="//fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="//jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="//velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="//velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="//src/utils.js?v="></script>

  <script type="text/javascript" src="//src/motion.js?v="></script>



  
  

  

  


  <script type="text/javascript" src="//src/bootstrap.js?v="></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === '') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
