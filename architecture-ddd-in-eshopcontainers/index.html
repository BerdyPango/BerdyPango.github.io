<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="K2S73UudyU-JTh9S0U_KnOKgOvE7aW7EpO560okLyUU">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;blog.frosthe.net&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;images&quot;,&quot;scheme&quot;:&quot;Mist&quot;,&quot;version&quot;:&quot;8.5.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;always&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12,&quot;width&quot;:300},&quot;copycode&quot;:false,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:false,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:false,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;搜索...&quot;,&quot;empty&quot;:&quot;没有找到任何搜索结果：${query}&quot;,&quot;hits_time&quot;:&quot;找到 ${hits} 个搜索结果（用时 ${time} 毫秒）&quot;,&quot;hits&quot;:&quot;找到 ${hits} 个搜索结果&quot;}}</script><script src="/js/config.js"></script>
<meta name="description" content="本文提取 eShopOnContainers 参考项目配套的架构设计电子书 182-290 页的 DDD 部分论述，从中吸取和提炼了微软官方示例项目实现 DDD 与 CQRS 背后的思考">
<meta property="og:type" content="article">
<meta property="og:title" content="探寻 DDD 在 .NET 生态中的落地实现 - eShopOnContainers">
<meta property="og:url" content="https://blog.frosthe.net/architecture-ddd-in-eshopcontainers/index.html">
<meta property="og:site_name" content="FrostHe.Handbook">
<meta property="og:description" content="本文提取 eShopOnContainers 参考项目配套的架构设计电子书 182-290 页的 DDD 部分论述，从中吸取和提炼了微软官方示例项目实现 DDD 与 CQRS 背后的思考">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2018-12-29T12:38:26.000Z">
<meta property="article:modified_time" content="2018-12-31T07:14:39.435Z">
<meta property="article:author" content="Frost He">
<meta property="article:tag" content="ddd">
<meta property="article:tag" content="architecture">
<meta property="article:tag" content="cqrs">
<meta property="article:tag" content="mediator-pattern">
<meta property="article:tag" content="dotnet">
<meta property="article:tag" content="repository-pattern">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://blog.frosthe.net/architecture-ddd-in-eshopcontainers/">



<script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:false,&quot;isPost&quot;:true,&quot;lang&quot;:&quot;zh-CN&quot;,&quot;comments&quot;:true,&quot;permalink&quot;:&quot;https:&#x2F;&#x2F;blog.frosthe.net&#x2F;architecture-ddd-in-eshopcontainers&#x2F;&quot;,&quot;path&quot;:&quot;architecture-ddd-in-eshopcontainers&#x2F;&quot;,&quot;title&quot;:&quot;探寻 DDD 在 .NET 生态中的落地实现 - eShopOnContainers&quot;}</script>

<script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script>
<title>探寻 DDD 在 .NET 生态中的落地实现 - eShopOnContainers | FrostHe.Handbook</title>
  
  <script class="next-config" data-name="google_analytics" type="application/json">{&quot;tracking_id&quot;:&quot;UA-125853342-1&quot;,&quot;only_pageview&quot;:true}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>
  <div class="site-meta">
      <a
        href="/" class="brand" rel="start">
        
        <h1 class="site-title">FrostHe.Handbook</h1>
          <p class="site-subtitle">Talk less, do more</p>
        
      </a>
      </div>
      <div class="site-nav-right">
        <div class="toggle popup-trigger">
        </div>
      </div>
    </div>


<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-film fa-fw"></i>时间线</a></li>
        <li class="menu-item menu-item-about"><a href="/about" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar sidebar-active">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Frost He" src="/images/avatar.jpg">
    <p class="site-author-name" itemprop="name">Frost He</p>
    <p>Full-stack web developer<p>
        <div class="site-description" itemprop="description">
          <i class="fa fa-fw fa-map-marker-alt"></i>
          <span>Chengdu, China</span>
        </div>
      </div>
                <div class="links-of-author site-overview-item animated">
                    <span class="links-of-author-item">
                      <a href="https://github.com/BerdyPango" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;BerdyPango" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
                    </span>
                    <span class="links-of-author-item">
                      <a href="https://plus.google.com/yourname" title="Google → https:&#x2F;&#x2F;plus.google.com&#x2F;yourname" rel="noopener" target="_blank"><i class="fab fa-google fa-fw"></i></a>
                    </span>
                    <span class="links-of-author-item">
                      <a href="https://www.linkedin.com/in/frosthe0419/" title="Linkedin → https:&#x2F;&#x2F;www.linkedin.com&#x2F;in&#x2F;frosthe0419&#x2F;" rel="noopener" target="_blank"><i class="fab fa-linkedin fa-fw"></i></a>
                    </span>
                    <span class="links-of-author-item">
                      <a href="https://www.instagram.com/frosthe_pro/" title="Instagram → https:&#x2F;&#x2F;www.instagram.com&#x2F;frosthe_pro&#x2F;" rel="noopener" target="_blank"><i class="fab fa-instagram fa-fw"></i></a>
                    </span>
                    <span class="links-of-author-item">
                      <a href="https://steamcommunity.com/profiles/76561198049061021/" title="Steam → https:&#x2F;&#x2F;steamcommunity.com&#x2F;profiles&#x2F;76561198049061021&#x2F;" rel="noopener" target="_blank"><i class="fab fa-steam-square fa-fw"></i></a>
                    </span>
                </div>
              
        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.frosthe.net/architecture-ddd-in-eshopcontainers/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Frost He">
      <meta itemprop="description" content="Chengdu, China">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FrostHe.Handbook">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          探寻 DDD 在 .NET 生态中的落地实现 - eShopOnContainers
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-12-29 20:38:26" itemprop="dateCreated datePublished" datetime="2018-12-29T20:38:26+08:00">2018-12-29</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2018-12-31 15:14:39" itemprop="dateModified" datetime="2018-12-31T15:14:39+08:00">2018-12-31</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Architecture-and-Pattern/" itemprop="url" rel="index"><span itemprop="name">Architecture and Pattern</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>13k</span>
    </span>
</div>

            <div class="post-description">本文提取 eShopOnContainers 参考项目配套的架构设计电子书 182-290 页的 DDD 部分论述，从中吸取和提炼了微软官方示例项目实现 DDD 与 CQRS 背后的思考</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>参考资料:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/dotnet-architecture/eShopOnContainers">Github - eShopOnContainers</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/sQ8QBKhSIJ6YfX3Ri-NfCA">eShopOnContainers 知多少[1]：总体概览</a></li>
</ul>
<p>本文索引:</p>
<ul>
<li><a href="#eshoponcontainers">eShopOnContainers</a></li>
<li><a href="#%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC%E4%B8%8E%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F">架构风格与架构模式</a></li>
<li><a href="#%E4%B8%BA%E4%BD%95%E9%80%89%E6%8B%A9-cqrs">为何选择 CQRS</a><ul>
<li><a href="#%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0-cqrs">简单实现 CQRS</a></li>
</ul>
</li>
<li><a href="#%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E9%9D%A2%E5%90%91-ddd-%E7%9A%84-ordering-%E6%9C%8D%E5%8A%A1">设计与实现面向 DDD 的 Ordering 服务</a><ul>
<li><a href="#%E5%AE%9E%E4%BD%93">实体</a></li>
<li><a href="#%E5%80%BC%E5%AF%B9%E8%B1%A1">值对象</a></li>
<li><a href="#%E8%81%9A%E5%90%88">聚合</a></li>
<li><a href="#%E8%81%9A%E5%90%88%E6%A0%B9%E6%88%96%E6%A0%B9%E5%AE%9E%E4%BD%93">聚合根或根实体</a></li>
</ul>
</li>
<li><a href="#%E5%AE%9E%E7%8E%B0-net-core-%E7%9A%84%E5%9F%9F%E6%A8%A1%E5%9E%8B%E5%BE%AE%E6%9C%8D%E5%8A%A1">实现 .NET Core 的域模型微服务</a><ul>
<li><a href="#%E5%9C%A8-net-standard-%E5%BA%93%E4%B8%AD%E6%9E%84%E5%BB%BA%E5%9F%9F%E6%A8%A1%E5%9E%8B">在 .NET Standard 库中构建域模型</a></li>
<li><a href="#%E5%9C%A8%E5%AE%9E%E4%BD%93%E4%B8%AD%E5%B0%81%E8%A3%85%E6%95%B0%E6%8D%AE">在实体中封装数据</a></li>
<li><a href="#seedwork%E5%9F%9F%E6%A8%A1%E5%9E%8B%E4%B8%AD%E5%8F%AF%E9%87%8D%E7%94%A8%E7%9A%84%E5%9F%BA%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%8E%A5%E5%8F%A3">SeedWork(域模型中可重用的基类型及接口)</a><ul>
<li><a href="#iaggregateroot-%E6%8E%A5%E5%8F%A3">IAggregateRoot 接口</a></li>
<li><a href="#%E5%AE%9E%E4%BD%93%E5%9F%BA%E7%B1%BB">实体基类</a></li>
<li><a href="#%E4%BB%93%E5%82%A8%E6%8E%A5%E5%8F%A3">仓储接口</a></li>
<li><a href="#%E5%80%BC%E5%AF%B9%E8%B1%A1%E5%AE%9E%E7%8E%B0">值对象实现</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E5%8F%AF%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E6%9B%BF%E4%BB%A3-c-%E5%8E%9F%E7%94%9F%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B">使用可枚举类型替代 C# 原生枚举类型</a></li>
<li><a href="#%E5%9C%A8%E5%9F%9F%E6%A8%A1%E5%9E%8B%E4%B8%AD%E5%AE%9A%E4%B9%89%E5%8F%8A%E5%AE%9E%E7%8E%B0%E9%AA%8C%E8%AF%81">在域模型中定义及实现验证</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E8%AE%BE%E8%AE%A1%E5%8F%8A%E5%AE%9E%E7%8E%B0%E9%A2%86%E5%9F%9F%E4%BA%8B%E4%BB%B6">设计及实现领域事件</a><ul>
<li><a href="#%E5%AE%9E%E7%8E%B0%E5%9F%9F%E4%BA%8B%E4%BB%B6">实现域事件</a></li>
<li><a href="#%E5%8F%91%E5%B8%83%E5%9F%9F%E4%BA%8B%E4%BB%B6">发布域事件</a></li>
<li><a href="#%E8%B7%A8%E8%81%9A%E5%90%88%E5%8D%95%E4%B8%80%E4%BA%8B%E5%8A%A1%E8%BF%98%E6%98%AF%E5%A4%9A%E4%BA%8B%E5%8A%A1%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7">跨聚合单一事务还是多事务最终一致性</a></li>
<li><a href="#%E6%98%A0%E5%B0%84%E4%BA%8B%E4%BB%B6%E8%87%B3%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%99%A8">映射事件至事件处理器</a></li>
<li><a href="#%E5%9F%9F%E4%BA%8B%E4%BB%B6%E5%8F%AF%E4%BB%A5%E7%94%9F%E6%88%90%E9%9B%86%E6%88%90%E4%BA%8B%E4%BB%B6%E8%B7%A8%E8%B6%8A%E6%9C%8D%E5%8A%A1%E8%BE%B9%E7%95%8C">域事件可以生成集成事件跨越服务边界</a></li>
</ul>
</li>
<li><a href="#%E5%AE%9E%E7%8E%B0%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%8C%81%E4%B9%85%E5%8C%96%E5%B1%82">实现基础设施持久化层</a><ul>
<li><a href="#%E6%AF%8F%E4%B8%AA%E8%81%9A%E5%90%88%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E4%BB%93%E5%82%A8">每个聚合定义一个仓储</a></li>
</ul>
</li>
</ul>
<h2 id="eShopOnContainers"><a href="#eShopOnContainers" class="headerlink" title="eShopOnContainers"></a>eShopOnContainers</h2><p><a target="_blank" rel="noopener" href="https://github.com/dotnet-architecture/eShopOnContainers">eShopOnContainers</a> 是微软官方推出的基于 .NET Core 和 Docker 实现的一整套微服务架构体系的参考项目，以下简称「参考项目」。其各个子系统的复杂度迥异，因此文章一再强调不要把一个子系统的架构模式应用在所有系统上，本文主要提取了该书对 <code>Ordering</code> 子系统的实现思路。在阅读这些内容之前，我们至少应该对以下概念有所了解:</p>
<ul>
<li><a href="/categories/Domain-Driven-Design/">领域驱动设计</a>的基本概念</li>
<li><a href="/architecture-cqrs">CQRS</a></li>
<li><a href="/architecture-repository-pattern/">Repository 模式</a></li>
<li><a href="/architecture-mediator-pattern/">Mediator 模式</a></li>
</ul>
<h2 id="架构风格与架构模式"><a href="#架构风格与架构模式" class="headerlink" title="架构风格与架构模式"></a>架构风格与架构模式</h2><p>无论是 CQRS 还是 DDD，都不是「架构风格(architecture styles)」，它们是「架构模式(architecture patterns)」，微服务，SOA，事件驱动架构是「架构风格」，而「架构模式」描述了一个子系统或组件的构建方式。不同的有界上下文应该采用不同的「架构模式」。</p>
<p>在实际介绍 DDD 之前，文章用了大量篇幅论述了有关 CQRS(Command and Query Responsibility Segregation) 的方法论。</p>
<h2 id="为何选择-CQRS"><a href="#为何选择-CQRS" class="headerlink" title="为何选择 CQRS"></a>为何选择 CQRS</h2><p>CQRS 是一种分离读写数据的架构模式，以下是 <strong>Bertrand Meyer</strong> 在其著作 <strong>Object Oriented Software Construction</strong> 首次对对两者的定义:</p>
<ul>
<li>Queries: 返回结果但不改变系统的状态，无副作用(These return a result and do not change the state of the system, and they are free of side effects.)</li>
<li>Commands: 改变系统的状态(These change the state of a system.)</li>
</ul>
<p>在参考项目的实现中，其高层视图为:</p>

<p>简单起见，参考项目的「读」和「写」操作同一个数据库，但核心的思路是，「读」被处理成一种非常轻量的「幂等」操作；而「写」则暗示系统的状态变化，这意味着在处理「写」操作时要格外小心，任何业务规则的变化都可能引起一系列域模型的改变。因此，查询通常伴随着 ViewModels，命令则与域模型息息相关，将两者进行分离的目的在于<strong>将查询以及如何组装视图数据从域模型对事务及数据更新的限制条件中独立出来</strong>。</p>
<h3 id="简单实现-CQRS"><a href="#简单实现-CQRS" class="headerlink" title="简单实现 CQRS"></a>简单实现 CQRS</h3><p>参考项目的实现方法非常简单:</p>

<p>图中的 <code>API Interface</code> 代表了 <code>Ordering.API</code> ASP.NET Core 项目，其 <code>Controllers</code> 直接调用 <code>Infrastructure</code> 中的 ORM 对象(这里是 Dapper)，再以 <code>dynamic</code> 类型作为 ViewModel 返回结果，其结构及源代码如下:</p>

<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IOrderQueries</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Task&lt;Order&gt; <span class="title">GetOrderAsync</span>(<span class="params"><span class="built_in">int</span> id</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OrderQueries</span> : <span class="title">IOrderQueries</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;Order&gt; <span class="title">GetOrderAsync</span>(<span class="params"><span class="built_in">int</span> id</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> (<span class="keyword">var</span> connection = <span class="keyword">new</span> SqlConnection(_connectionString))</span><br><span class="line">        &#123;</span><br><span class="line">            connection.Open();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> result = <span class="keyword">await</span> connection.QueryAsync&lt;<span class="built_in">dynamic</span>&gt;(</span><br><span class="line">               <span class="string">@&quot;select o.[Id] as ordernumber,o.OrderDate as date, o.Description as description,</span></span><br><span class="line"><span class="string">                    o.Address_City as city, o.Address_Country as country, o.Address_State as state, o.Address_Street as street, o.Address_ZipCode as zipcode,</span></span><br><span class="line"><span class="string">                    os.Name as status, </span></span><br><span class="line"><span class="string">                    oi.ProductName as productname, oi.Units as units, oi.UnitPrice as unitprice, oi.PictureUrl as pictureurl</span></span><br><span class="line"><span class="string">                    FROM ordering.Orders o</span></span><br><span class="line"><span class="string">                    LEFT JOIN ordering.Orderitems oi ON o.Id = oi.orderid </span></span><br><span class="line"><span class="string">                    LEFT JOIN ordering.orderstatus os on o.OrderStatusId = os.Id</span></span><br><span class="line"><span class="string">                    WHERE o.Id=@id&quot;</span></span><br><span class="line">                    , <span class="keyword">new</span> &#123; id &#125;</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (result.AsList().Count == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> KeyNotFoundException();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> MapOrderItems(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>值得注意的是:</p>
<ol>
<li>这里的 <code>OrderQueries</code> 类型直接在 <code>Ordering.API</code> 项目中实现，在哪一层实现并不重要，<strong>重点在于，用于表现层的数据可能来自于数据库不同的表，这些数据可能分属于不同的域对象，然而 Query 本身绕过了整个域模型而直接从数据库表提取数据</strong>，这解释了前文提及的<strong>查询独立于域模型的限制</strong>，这种方式为开发人员在更新查询时提高了灵活性和生产力。</li>
<li>这里直接以 <code>dynamic</code> 动态类型作为返回结果，但这不是必须的，传统上我们习惯创建对应的 <code>ViewModel</code> 静态类型。返回动态类型的好处在于，当为数据表增减列或修改列名时，无需在静态类型同步这些改变，这也暗示了这些类型仅仅是服务于表现层的数据包装，它们只是 DTO。但也存在缺点，比如无法对返回类型进行版本控制，无法自动集成 <code>Swashbuckle</code> 等。</li>
</ol>
<hr>
<h2 id="设计与实现面向-DDD-的-Ordering-服务"><a href="#设计与实现面向-DDD-的-Ordering-服务" class="headerlink" title="设计与实现面向 DDD 的 Ordering 服务"></a>设计与实现面向 DDD 的 Ordering 服务</h2><p>面对复杂性，聚合根必须确保所有处理不变性和业务规则的逻辑都经过统一的入口(聚合根实体)与关联的实体进行交互，下图展示了 <code>Ordering</code> 服务以 DDD 实现划分的不同的层以及它们的依赖关系:</p>



<h3 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h3><p>域实体主要由其身份标识、连续性和持久化定义，实体的标识可跨越多个有界上下文或微服务。实体实现其代表的业务规则和读写状态数据，但并非所有实体都必须包含逻辑，这些实体通常都是一个聚合中的子实体，因为多数逻辑都在聚合根中实现。相反，如果大量逻辑放置在服务层(传统项目中的业务逻辑层)中，最终将导致贫血模型。</p>

<p>然而，如果业务场景非常简单，看上去像是贫血模型的域模型也是足够的，重点在于，创建这些模型的出发点是为了便于「数据映射」还是「领域驱动」。两者的区别在于，「数据映射」仅仅从持久化的角度考虑，而忽略了模型在业务领域中代表的概念。根据业务复杂度选用合适的架构模式非常重要，这也是为何参考项目中的 <code>Catalog</code> 微服务以「数据驱动」模式实现而 <code>Ordering</code> 微服务以「领域驱动」模式实现。实体的详细描述可参考<a href="/ddd-tactical-entity/">这里</a>。 </p>
<h3 id="值对象"><a href="#值对象" class="headerlink" title="值对象"></a>值对象</h3><p>值对象不包含身份标识，其仅为一组数据的「逻辑集合」，有关值对象的详细描述可参考<a href="/ddd-tactical-value-object/">这里</a>。</p>
<h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><p>聚合描述了一系列或一组高度内聚的实体和行为，定义聚合通常以事务作为边界，一个典型的例子为: 一个 <code>Order</code>，通常包含一个 <code>Item</code> 列表，<code>Item</code> 通常被定义为<strong>实体</strong>，但 <code>Item</code> 是 <code>Order</code> 聚合的子实体，并将 <code>Order</code> 实体作为其根实体，而类似 <code>Order</code> 这样的<strong>实体</strong>通常被称为「聚合根」。聚合表示了一组必须维持「事务一致性」的对象，识别聚合通常由一个业务概念开始，并考虑在其事务边界内所需的所有实体。考虑「事务性边界」通常是识别一个聚合的起点。</p>
<h3 id="聚合根或根实体"><a href="#聚合根或根实体" class="headerlink" title="聚合根或根实体"></a>聚合根或根实体</h3><p>一个「聚合」至少由一个「实体」组成——聚合根，它可能包含多个子实体、值对象。<strong>聚合根最重要的职责是确保聚合边界内的一致性，它必须是修改聚合的唯一入口</strong>。下图展示了 <code>Buyer</code> 聚合和 <code>Odrer</code> 聚合，包括它们的聚合根实体、子实体及值对象</p>

<p><code>Buyer</code> 代表了只包含一个实体的聚合。为了在聚合之间维持清晰的边界，一个最佳实践是禁止在一个聚合中直接引用另一个聚合，转而利用外键进行引用。如下代码中，<code>Order</code> 实体仅包包了一个 <code>Buyer</code> 聚合的外键，而非对象引用:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Order</span> : <span class="title">Entity</span>, <span class="title">IAggregateRoot</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span> DateTime _orderDate;</span><br><span class="line"><span class="keyword">public</span> Address Address &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span>? _buyerId; <span class="comment">//FK pointing to a different aggregate root</span></span><br><span class="line"><span class="keyword">public</span> OrderStatus OrderStatus &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">readonly</span> List&lt;OrderItem&gt; _orderItems;</span><br><span class="line"><span class="keyword">public</span> IReadOnlyCollection&lt;OrderItem&gt; OrderItems =&gt; _orderItems;</span><br><span class="line"><span class="comment">//… Additional code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="实现-NET-Core-的域模型微服务"><a href="#实现-NET-Core-的域模型微服务" class="headerlink" title="实现 .NET Core 的域模型微服务"></a>实现 .NET Core 的域模型微服务</h2><p>有了前文对概念理论的解释，接下来，将探索基于 ASP.NET Core 实现以 DDD 设计的 Ordering 服务。</p>
<h3 id="在-NET-Standard-库中构建域模型"><a href="#在-NET-Standard-库中构建域模型" class="headerlink" title="在 .NET Standard 库中构建域模型"></a>在 .NET Standard 库中构建域模型</h3><p>首先来看参考项目的 <code>Ordering</code> 工程的文件组织：</p>

<p><code>Order</code> 和 <code>Buyer</code> 两个聚合所包含的实体和值对象均位于其对应的目录下，同时:</p>
<ul>
<li>聚合中包含了 <code>IRepository</code> 接口，这些接口的实现必须放置在域模型之外的层——基础设施层，这样与基础设施有关的实现不至于污染域模型</li>
<li><code>SeedWork</code> 目录包含了定义实体及值对象的基类</li>
</ul>
<p>深入 <code>Order</code> 聚合，可以清晰的看出为了维持事务边界，聚合所包含的不同职责的类型:</p>

<p>打开其中任何一个类型，无论是实体，值对象还是枚举类型，都继承自 <code>SeedWork</code> 文件夹下的类型，关于这些基类的实现，我们稍后会详述。</p>
<h3 id="在实体中封装数据"><a href="#在实体中封装数据" class="headerlink" title="在实体中封装数据"></a>在实体中封装数据</h3><p>实体中一个常见的问题是，他们暴露了一些 <code>public</code> 的 <code>Collection</code> 类型，消费这些类型的开发人员不经意间可能会修改集合的元素，这种情况就会绕过集合本身所代表的业务规则，从而导致对象保持无效的状态。为了避免类似情况，可以将集合类型定义为 <code>IReadOnlyCollection</code>，并显式暴露修改集合的方法。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> IReadOnlyCollection&lt;OrderItem&gt; OrderItems &#123;<span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddOrderItem</span>(<span class="params">productId, productName, pictureUrl, unitPrice, discount, units</span>)</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><code>AddOrderItem</code> 定义在 <code>Order</code> 聚合根中，其实现会包含验证，创建等与业务规则相关的逻辑(特别是与该集合中其他元素有关的逻辑)。另一方面，实体类型不应该将任何 <code>Setter</code> 方法暴露出来，<strong>修改实体状态应该由显式定义的描述业务规则的方法完成</strong>。</p>
<h3 id="SeedWork-域模型中可重用的基类型及接口"><a href="#SeedWork-域模型中可重用的基类型及接口" class="headerlink" title="SeedWork(域模型中可重用的基类型及接口)"></a>SeedWork(域模型中可重用的基类型及接口)</h3><p><code>Seedwork</code> 是由 <strong>Michael Feathers</strong> 提出，并由 <strong>Martin Fowler</strong> 推广的用于概括这些类型的名称，也可以自行将其命名为 <code>Common</code>，<code>SharedKernel</code> 等。下图展示了 <code>Ordering</code> 域模中这些基类及接口:</p>


<h4 id="IAggregateRoot-接口"><a href="#IAggregateRoot-接口" class="headerlink" title="IAggregateRoot 接口"></a>IAggregateRoot 接口</h4><p>一个空接口，仅用于标记某些实体为聚合根，实现了该接口的实体通常意味着保持业务逻辑一致性的逻辑都实现在该实体中，所有子实体的创建或更新都必须经过该类型。</p>
<h4 id="实体基类"><a href="#实体基类" class="headerlink" title="实体基类"></a>实体基类</h4><p>查看 <code>Entity</code> 类型，定义了 <code>ID</code>，相等性比较器方法，域事件列表等。关于域事件将在后文中详述。</p>
<h4 id="仓储接口"><a href="#仓储接口" class="headerlink" title="仓储接口"></a>仓储接口</h4><p>将接口定义于域模型中遵循了抽象与实现分离的模式，同时仓储又结合了 CQRS 模式，仅是对聚合的「增删改」操作。</p>
<h4 id="值对象实现"><a href="#值对象实现" class="headerlink" title="值对象实现"></a>值对象实现</h4><p>唯一标识是实体及聚合用于身份跟踪的基础，而系统中还存在着大量无需进行标识及跟踪的对象和数据集合，它们是值对象。值对象可以引用实体，例如，一个程序生成了一个从 A 点至 B 点的路线，该「路线」是一个值对象，但它会引用 A 点和 B 点，A 点和 B 点则可能是代表「城市」或「街道」的实体类型。值对象是两个特征:</p>
<ul>
<li>无需身份标识</li>
<li>不变性</li>
</ul>
<p>以上特性意味着在实现值对象基类时，仅需考虑以它们的值来区别不同的对象。</p>
<h4 id="使用可枚举类型替代-C-原生枚举类型"><a href="#使用可枚举类型替代-C-原生枚举类型" class="headerlink" title="使用可枚举类型替代 C# 原生枚举类型"></a>使用可枚举类型替代 C# 原生枚举类型</h4><p>在 <code>SeedWork</code> 目录下有一个 <code>Enumeration</code> 的抽象类，其定义如下:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Enumeration</span> : <span class="title">IComparable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Enumeration</span>(<span class="params"></span>)</span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Enumeration</span>(<span class="params"><span class="built_in">int</span> id, <span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Id = id;</span><br><span class="line">        Name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">ToString</span>(<span class="params"></span>)</span> =&gt; Name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">IEnumerable</span>&lt;<span class="title">T</span>&gt; <span class="title">GetAll</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span>) <span class="keyword">where</span> T : Enumeration</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> fields = <span class="keyword">typeof</span>(T).GetFields(BindingFlags.Public |</span><br><span class="line">        BindingFlags.Static |</span><br><span class="line">        BindingFlags.DeclaredOnly);</span><br><span class="line">        <span class="keyword">return</span> fields.Select(f =&gt; f.GetValue(<span class="literal">null</span>)).Cast&lt;T&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">bool</span> <span class="title">Equals</span>(<span class="params"><span class="built_in">object</span> obj</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> otherValue = obj <span class="keyword">as</span> Enumeration;</span><br><span class="line">        <span class="keyword">if</span> (otherValue == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">var</span> typeMatches = GetType().Equals(obj.GetType());</span><br><span class="line">        <span class="keyword">var</span> valueMatches = Id.Equals(otherValue.Id);</span><br><span class="line">        <span class="keyword">return</span> typeMatches &amp;&amp; valueMatches;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">CompareTo</span>(<span class="params"><span class="built_in">object</span> other</span>)</span> =&gt; Id.CompareTo(((Enumeration)other).Id);</span><br><span class="line">        <span class="comment">// Other utility methods ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建该类型的意图在于扩展由于 C# 语言原生 <code>enum</code> 类型的限制而无法应用的场景，例如，原生的 <code>enum</code> 类型仅支持单个值，并且无法通过简单的手段遍历枚举值。但这不是必须的，以下是一个 <code>CardType</code> 可枚举类型的实现:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CardType</span> : <span class="title">Enumeration</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> CardType Amex = <span class="keyword">new</span> CardType(<span class="number">1</span>, <span class="string">&quot;Amex&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> CardType Visa = <span class="keyword">new</span> CardType(<span class="number">2</span>, <span class="string">&quot;Visa&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> CardType MasterCard = <span class="keyword">new</span> CardType(<span class="number">3</span>, <span class="string">&quot;MasterCard&quot;</span>);</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">CardType</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CardType</span>(<span class="params"><span class="built_in">int</span> id, <span class="built_in">string</span> name</span>): <span class="title">base</span>(<span class="params">id, name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">IEnumerable</span>&lt;<span class="title">CardType</span>&gt; <span class="title">List</span>(<span class="params"></span>)</span> =&gt; Enumeration.GetAll&lt;CardType&gt;();</span><br><span class="line">    <span class="comment">// Other util methods</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="在域模型中定义及实现验证"><a href="#在域模型中定义及实现验证" class="headerlink" title="在域模型中定义及实现验证"></a>在域模型中定义及实现验证</h4><p>在 DDD 中，验证规则可被视为「不变条件」，聚合的主要职责之一是在跨多个子实体的状态变化中维持「不变条件」，实体对象可能包含若干个「不变条件」，必须总是验证为真。举例来说，<code>OrderItem</code> 的 <code>Quantity</code> 值必须总是一个正整数，且总是包含有效的 <code>ProductName</code> 和 <code>Price</code> 值。聚合根对象必须确保这些对象的有效性，当不满足「不变条件」时应该发出通知或抛出异常。多数不易察觉的 Bug 都是由于对象处于「非预期」的状态导致的。</p>
<p>有效性验证通常在实体的构造器或更新状态的方法中实现，以下代码段展示了实体有效性验证最简单的手段——抛出异常:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetAddress</span>(<span class="params">Address address</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    _shippingAddress = address?? <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="keyword">nameof</span>(address));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更多先进的实现手段可参考:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.codeproject.com/Tips/790758/Specification-and-Notification-Patterns">Specification and Notification Patterns</a></li>
<li><a target="_blank" rel="noopener" href="https://martinfowler.com/articles/replaceThrowWithNotification.html">Martin Fowler. Replacing Throwing Exceptions with Notification in Validations</a></li>
<li><a target="_blank" rel="noopener" href="http://gorodinski.com/blog/2012/05/19/validation-in-domain-driven-design-ddd/">Lev Gorodinski. Validation in Domain-Driven Design (DDD)</a></li>
</ul>
<hr>
<h2 id="设计及实现领域事件"><a href="#设计及实现领域事件" class="headerlink" title="设计及实现领域事件"></a>设计及实现领域事件</h2><p>在语义上，「域事件」和「集成事件」在行为上似乎是同一个概念——都表达了某个事件的发生。但它们的作用范围和协调目的都不一样。「域事件」仅仅是将消息推送至某个「域事件分发器」，而它可由 IoC 或其他方式实现。而「集成事件」则用于向其他系统广播刚刚提交的事务，消费方可能是某个微服务、有界上下文或外部应用程序。这意味着「集成事件」仅在实体成功持久化时发生，如果失败，对于其他系统来说，该操作就像没有发生过一样。</p>
<p>而「域事件」的作用范围是<strong>同一个域中某个聚合的操作需要引起另外的聚合执行额外的操作</strong>，这种由单个聚合引起的「副作用」应该由「域事件」承担，如下图所示:</p>

<p>查看参考项目的源代码，当用户提交一个订单:</p>
<ol>
<li><code>Ordering.API</code> 从外部接收一个请求，请求模型为 <code>CreateOrderDraftCommand</code> 类型</li>
<li><code>Controller</code> 调用 <code>Mediator</code> 发送该请求<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Route(<span class="meta-string">&quot;draft&quot;</span>)</span>]</span><br><span class="line">[<span class="meta">HttpPost</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IActionResult&gt; <span class="title">GetOrderDraftFromBasketData</span>(<span class="params">[FromBody] CreateOrderDraftCommand createOrderDraftCommand</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> draft  = <span class="keyword">await</span> _mediator.Send(createOrderDraftCommand);</span><br><span class="line">    <span class="keyword">return</span> Ok(draft);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>CreateOrderDraftCommandHandler</code> 处理该请求，创建 <code>Order</code> 对象，并返回一个 <code>OrderDraftDTO</code> 对象<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Task&lt;OrderDraftDTO&gt; <span class="title">Handle</span>(<span class="params">CreateOrderDraftCommand message, CancellationToken cancellationToken</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> order = Order.NewDraft();</span><br><span class="line">    <span class="keyword">var</span> orderItems = message.Items.Select(i =&gt; i.ToOrderItemDTO());</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> orderItems)</span><br><span class="line">    &#123;</span><br><span class="line">        order.AddOrderItem(item.ProductId, item.ProductName, item.UnitPrice, item.Discount, item.PictureUrl, item.Units);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Task.FromResult(OrderDraftDTO.FromOrder(order));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>Order.NewDraft()</code> 方法返回一个 <code>IsDraft = true</code> 的 <code>Order</code> 对象，确认需要持久化之后，创建 <code>OrderStartedDomainEvent</code> 的实例，并添加至 <code>Order</code> 实体的 <code>DomainEvents</code> 集合属性，后者是一个 <code>MediatR.INotification</code> 的只读集合。<code>Ordering.Infrastructure.MediatorExtension</code> 的扩展方法 <code>DispatchDomainEventsAsync</code> 检测当前实体的 <code>DomainEvents</code> 发生变化时借由 <code>Mediator</code> 发布事件。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">DispatchDomainEventsAsync</span>(<span class="params"><span class="keyword">this</span> IMediator mediator, OrderingContext ctx</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> domainEntities = ctx.ChangeTracker</span><br><span class="line">        .Entries&lt;Entity&gt;()</span><br><span class="line">        .Where(x =&gt; x.Entity.DomainEvents != <span class="literal">null</span> &amp;&amp; x.Entity.DomainEvents.Any());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> domainEvents = domainEntities</span><br><span class="line">        .SelectMany(x =&gt; x.Entity.DomainEvents)</span><br><span class="line">        .ToList();</span><br><span class="line"></span><br><span class="line">    domainEntities.ToList()</span><br><span class="line">        .ForEach(entity =&gt; entity.Entity.ClearDomainEvents());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> tasks = domainEvents</span><br><span class="line">        .Select(<span class="keyword">async</span> (domainEvent) =&gt; &#123;</span><br><span class="line">            <span class="keyword">await</span> mediator.Publish(domainEvent);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> Task.WhenAll(tasks);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>Ordering.API.Application.DomainEventHandlers.OrderStartedEvent</code> 命名空间下我们看到了两个响应 <code>OrderStartedDomainEvent</code> 事件的 <code>SendEmailToCustomerWhenOrderStartedDomainEventHandler</code> 和<code>ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler</code> 处理器类型。</li>
</ol>
<blockquote>
<p>另外，可以在聚合根实体中订阅其子实体中的域事件。举例来说，<code>OrderItem</code> 实体在价格高于某个特定值或数量太多时发起事件，聚合根在收到这些事件后处理为全局计算或聚合计算。</p>
</blockquote>
<p>重要的是理解事件通信并不直接在聚合中实现，而应由单独的域事件处理器(Domain Event Handler)来处理域事件，域事件的消费方是应用层和其他聚合，两者的数量且会随着时间不断增长，在设计时应尽可能考虑开闭原则和单一职责原则，基于域事件的通信方式可以更好的分离职责:</p>
<ol>
<li>发送命令(例如，<code>CreateOrder</code>)</li>
<li>在命令处理器中接收命令<ul>
<li>执行聚合的单一事务</li>
<li>如果产生副作用，广播域事件(例如，OrderStartedDomainEvent)</li>
</ul>
</li>
<li>其他聚合或应用层响应域事件，例如:<ul>
<li>验证或创建 <code>Buyer</code> 和 <code>PaymentMethod</code></li>
<li>创建并广播一个相关的集成事件至其他微服务，或触发一个外部动作(如发送 Email)</li>
<li>处理其他副作用</li>
</ul>
</li>
</ol>
<p>如下图所示:</p>

<p>与命令处理器不同的是，命令处理器只能被处理一次，而域事件可由一个或多个处理器响应，两者服务的目的不同，后者可以保证当业务功能增加时仅需增加更多的消费方而无需修改原有的部分。</p>
<h3 id="实现域事件"><a href="#实现域事件" class="headerlink" title="实现域事件"></a>实现域事件</h3><p>在 C# 中，域事件类型包含所有与该事件相关的数据，定义为简单的数据集类型，与 DTO 类型类似:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OrderStartedDomainEvent</span> : <span class="title">INotification</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> UserId &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> CardTypeId &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> CardNumber &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> CardSecurityNumber &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> CardHolderName &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> DateTime CardExpiration &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> Order Order &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrderStartedDomainEvent</span>(<span class="params">Order order,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="built_in">int</span> cardTypeId, <span class="built_in">string</span> cardNumber,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="built_in">string</span> cardSecurityNumber, <span class="built_in">string</span> cardHolderName,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   DateTime cardExpiration</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Order = order;</span><br><span class="line">        CardTypeId = cardTypeId;</span><br><span class="line">        CardNumber = cardNumber;</span><br><span class="line">        CardSecurityNumber = cardSecurityNumber;</span><br><span class="line">        CardHolderName = cardHolderName;</span><br><span class="line">        CardExpiration = cardExpiration;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于事件是过去发生的事情，所以定义域事件的类型必须是不可变类型，上述类型中的属性均为只读属性，构造器是唯一为这些属性赋值的地点。值得一提的是，如果需要对 <code>DomainEvent</code> 进行序列化和反序列化，则需要在这些属性中加入 <code>private set</code>。</p>
<h3 id="发布域事件"><a href="#发布域事件" class="headerlink" title="发布域事件"></a>发布域事件</h3><p>发布领域事件有两种方向的思潮，一种是当事件发生时立即推送至其对应的处理器，另一种是先将其添加至内存集合中，在提交事务之前或之后集中分发域事件，参考项目采用了第二种方法，还方法的好处可参考 <a target="_blank" rel="noopener" href="https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/">A better domain events pattern</a>。</p>
<p>决定在提交事务前后分发域事件与否非常重要，这意味着「副作用」是在事务边界之内还是之外。参考项目采用了延期集中分发事件的方式，实体首先将发生的事件添加至其 <code>DomainEvents</code> 集合，其定义在 <code>Entity</code> 基类中:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Entity</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;INotification&gt; _domainEvents;</span><br><span class="line">    <span class="keyword">public</span> List&lt;INotification&gt; DomainEvents =&gt; _domainEvents;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddDomainEvent</span>(<span class="params">INotification eventItem</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _domainEvents = _domainEvents ?? <span class="keyword">new</span> List&lt;INotification&gt;();</span><br><span class="line">        _domainEvents.Add(eventItem);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RemoveDomainEvent</span>(<span class="params">INotification eventItem</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _domainEvents?.Remove(eventItem);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//... Additional code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当事务提交至数据库时，所有的域事件会在这时进行分发，参考项目使用了 <code>MediatR</code> 和 <code>EF Core</code>:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OrderingContext</span> : <span class="title">DbContext</span>, <span class="title">IUnitOfWork</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;<span class="built_in">bool</span>&gt; <span class="title">SaveEntitiesAsync</span>(<span class="params">CancellationToken cancellationToken = <span class="literal">default</span>(CancellationToken</span>))</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">await</span> _mediator.DispatchDomainEventsAsync(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">var</span> result = <span class="keyword">await</span> <span class="keyword">base</span>.SaveChangesAsync();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式也使得实体对发布事件的实现解除了耦合。</p>
<h3 id="跨聚合单一事务还是多事务最终一致性"><a href="#跨聚合单一事务还是多事务最终一致性" class="headerlink" title="跨聚合单一事务还是多事务最终一致性"></a>跨聚合单一事务还是多事务最终一致性</h3><p>跨聚合事务的一致性问题一直是业界争论的焦点，早期的 DDD 作者们主张将事务边界划分得越小越好，即单一事务仅与单个聚合相关，产生的任何副作用交由另外的事务，并由最终一致性确保状态正确。随着技术实现的发展，跨聚合事务的应用场景越屈合理化，特别是当某个聚合发布的域事件会引起其他聚合的状态改变，如果原始事务提交成功而改变其他聚合状态的事务提交失败，那么这两个聚合将产生不一致性。确保最终一致性将引入更多的代码复杂度，而像 EF Core 等类似的工具已经提供了跨数据库的分布式事务功能，从实现层面确保了跨聚合单一事务的可能性。意即，原始事务及其域事件产生的副作用事务同属一个 <code>Scope</code>，任何一步提交失败，整个 <code>Scope</code> 都将回滚。参考项目采用了这种实现方式。</p>
<h3 id="映射事件至事件处理器"><a href="#映射事件至事件处理器" class="headerlink" title="映射事件至事件处理器"></a>映射事件至事件处理器</h3><p>分发事件完成之后，我们需要某种组件将事件推送至对应的事件处理器。一种方式是采用「消息队列」或「事件总线」，它们通常用于实现跨进程的异步通信，而对于域事件来说有点大材小用，因为域事件和域事件处理器属于同一个进程，只是实现在不同的层中。另一种方式是将域事件与处理器在 IoC 中注册，推送事件时动态解析处理器，如下图所示:</p>

<p>参考项目采用了 <code>MediatR</code> 库来实现这一环节</p>
<h3 id="域事件可以生成集成事件跨越服务边界"><a href="#域事件可以生成集成事件跨越服务边界" class="headerlink" title="域事件可以生成集成事件跨越服务边界"></a>域事件可以生成集成事件跨越服务边界</h3><p>值得提及的一点是，域事件处理器可以利用「事件总线」发布集成事件。</p>
<hr>
<h2 id="实现基础设施持久化层"><a href="#实现基础设施持久化层" class="headerlink" title="实现基础设施持久化层"></a>实现基础设施持久化层</h2><p>数据持久化组件提供了在有界上下文边界内访问数据的功能，它们包含了诸如「仓储」和「工作单元」等的实现类型。</p>
<h3 id="每个聚合定义一个仓储"><a href="#每个聚合定义一个仓储" class="headerlink" title="每个聚合定义一个仓储"></a>每个聚合定义一个仓储</h3><p>应该为聚合或聚合根定义一个仓储，在 DDD 模式中，仓储是在持久化层面修改聚合的唯一通道。仓储与聚合是一对一关系，负责控制其不变条件与事务的持久化工作。如前文讨论的那样，查询可以借由另外的通道实现(如 CQRS)，因为查询不会更改系统的状态。</p>
<p>必须强调的是，每个聚合有且只能有一个对应的仓储，而不是为每个实体或每张数据库表创建仓储，下图展示了 <code>Ordering</code> 域下各个模型的关系:</p>

<p>或者确切的说，仓储仅面向聚合根实体创建，在代码实现上可采用泛型仓储接口约束类型参数必须实现如上文提及过的 <code>IAggregateRoot</code> 接口，而具体的仓储实现可在基础设施层中定义，正如参考项目那样:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IRepository</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="title">IAggregateRoot</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IOrderRepository</span> : <span class="title">IRepository</span>&lt;<span class="title">Order</span>&gt;&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Microsoft.eShopOnContainers.Services.Ordering.Infrastructure.Repositories</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OrderRepository</span> : <span class="title">IOrderRepository</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尽管论述了很多使用「仓储」所带来的好处，但它不是实现 DDD 的必要条件。<strong>Jimmy Bogard</strong> 指出，仓储隐藏了持久化机制的具体实现，不使用模拟仓储的原因在于始终要采用集成测试来覆盖测试代码，采用 CQRS 模式之后也意味着对采用仓储模式的需求减弱了。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/ddd/" rel="tag"><i class="fa fa-tag"></i> ddd</a>
              <a href="/tags/architecture/" rel="tag"><i class="fa fa-tag"></i> architecture</a>
              <a href="/tags/cqrs/" rel="tag"><i class="fa fa-tag"></i> cqrs</a>
              <a href="/tags/mediator-pattern/" rel="tag"><i class="fa fa-tag"></i> mediator-pattern</a>
              <a href="/tags/dotnet/" rel="tag"><i class="fa fa-tag"></i> dotnet</a>
              <a href="/tags/repository-pattern/" rel="tag"><i class="fa fa-tag"></i> repository-pattern</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/architecture-event-driven-communication/" rel="prev" title="跨微服务实现事件驱动的异步通信">
                  <i class="fa fa-chevron-left"></i> 跨微服务实现事件驱动的异步通信
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/hobby-project-how-to-make-a-raspberry-pi-game-console/" rel="next" title="DIY - 自制树莓派便携游戏机">
                  DIY - 自制树莓派便携游戏机 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2015 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Frost He</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">381k</span>
  </span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
